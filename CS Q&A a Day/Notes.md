22.09.12  
## Q. 라우터의 라우팅 기술인 정적라우팅과 동적라우팅에 대해 설명해주세요.  

A. 정적 라우팅(Static Routing)은 송수신 호스트 사이에서 패킷 전송이 이루어지기 전에 경로 정보를 라우터에 미리 저장하여 중개하는 방식이다. 패킷을 중개하기 위한 최적의 경로 정보는 개별 라우터별로 저장하여 관리하는데, 운용 중인 네트워크 구성에 변화가 생기면 이에 적절하게 대처할 수 없다는 문제점이 있다. 즉, 라우터에 보관된 경로 정보가 고정되어 변화된 정보를 갱신하기가 용이하지 않으며, 특히 네트워크 내부의 혼잡도를 반영할 수 없다.  
  
동적 라우팅(Dynamic Routing)은 라우터에서 사용하는 경로 정보를 네트워크 상황에 따라 적절하게 변경하는 방식으로, 경로 정보의 변경 주기에 따라 계속 보완할 수 있다. 따라서 현재의 네트워크 상황을 고려해 최적 경로 정보를 선택할 수 있지만, 경로 정보를 수집하고 관리하는 등의 복잡한 작업이 추가로 필요하다. 이는 네트워크에 새로운 부하를 가해 성능에 부정적인 영향을 미친다.
  
동적 라우팅 방식을 사용하려면 현재의 네트워크 링크 상태를 점검해 이를 새로운 경로 배정 시 적용해야 한다. 각 라우터에서는 주변 라우터의 존재 유무와 전송 지연 시간 등을 확인할 수 있어야 한다. 또한 각 라우터가 획득한 경로 정보를 다른 라우터에 통보함으로써, 네트워크의 최신 경로 정보를 신속하게 공유하고 갱신해야 한다.
  
[네이버 지식백과] 라우팅

https://m.blog.naver.com/dreamxpeed/221671848467

22.09.13
## Q. 전송계층의 기능 중 멀티플렉싱과 디멀티플렉싱 기술에 대해 설명해주세요.

A. 멀티플렉싱(다중화)은 데이터 전송에서 두 개 이상의 데이터 송신 장치가 각각의 통신로를 갖도록 한 개의 전송 매체를 공유시키는 기능이다. 디멀티플렉싱(역다중화)은 원래의 독립 신호 또는 이들 신호의 군(群)을 복원시키기 위해 다중화된 복합 신호를 분리하여, 원래의 신호 또는 신호의 군으로 복원하는 과정이다.

[네이버 지식백과] 다중화, 역다중화  

https://m.blog.naver.com/kiseop91/221554095982

22.09.14
## Q. 고정IP와 유동IP에 대해서 설명해주세요.

A. **고정 IP 주소**  
공인 IP 주소든 가상 IP 주소든 컴퓨터 등에 IP 주소를 설정하려면, 누군가(주로 서버 시스템)가 IP 주소를 컴퓨터에 배급, 할당해 줘야 한다. 공인 IP 주소라면 해당 인터넷 서비스 업체의 주소 할당 서비스가, 가상 IP 주소라면 인터넷 공유기가 이 역할을 수행한다. 이때 IP 주소를 할당 받는 컴퓨터 등은 이를 자동으로 설정할지, 아니면 수동으로 설정할지를 선택할 수 있다. 고정 IP 주소는 사용자가 직접 IP 주소를 입력해 주소를 설정하는 방식을 말한다. IP 주소가 변경되면 안 되는 컴퓨터(파일 공유 서버 등) 등에 적합한 것으로 일반적으로 특별한 경우 외에는 사용할 기회가 거의 없다. 윈도우의 네트워크 연결 속성 페이지에서 '다음 IP 주소 사용' 옵션을 선택하고, 원하는 IP 주소를 4개 마디에 맞게 입력하면 된다(각 마디는 255를 넘을 수 없다).

**유동 IP 주소**  
IP 주소를 할당하는 특정 서버가 보내 주는 정보 그대로 컴퓨터에 자동 설정되는 방식이다. 이를 'DHCP(Dynamic Host Configuration Protocol)' 서비스라 하는데, 컴퓨터가 부팅하면 DHCP 서버에 IP 주소 할당을 요청하고, 이를 수신한 DHCP 서버가 해당 컴퓨터에 IP 주소 등의 네트워크 정보를 전달하면, 컴퓨터에서는 이를 자동으로 등록, 설정하게 된다. 이 DHCP 서비스는 컴퓨터 수가 많은 환경에서 특히 간편하고 유용하다. 이론적으로 컴퓨터가 매번 부팅할 때마다(즉 IP 할당 요청이 발생할 때마다) IP 주소는 변경되지만, 이전에 할당 받았던 IP 주소 그대로 재할당 받는 경우가 더 많다. 인터넷 공유기는 가상 IP 주소를 생성(NAT 서비스)하여 각 컴퓨터 등에 자동 할당(DHCP 서비스)하는 역할을 동시에 수행하는 것이다.

1. 컴퓨터가 부팅되며 DHCP 서버가 존재함을 탐지한다
2. DHCP 서버는 컴퓨터에 IP 주소 등이 할당되어 있는지 확인한다
3. 컴퓨터가 DHCP 서버에 IP 주소 할당을 요청한다
4. DHCP 서버는 IP 주소 할당 현황에 따라 IP 주소 등의 정보를 컴퓨터에 할당한다

물론 DHCP 서비스를 적용했어도 특정 컴퓨터에 고정 IP 주소를 할당해야 한다면, (앞서 설명한 대로) 윈도우 네트워크 속성 페이지에서 '다음 IP 주소 사용' 설정을 이용하면 된다. 그럼 그 컴퓨터는 IP 주소 자동 할당 목록에서 제외된다.

[네이버 지식백과] IP 주소 - 컴퓨터 네트워크의 전화번호 (용어로 보는 IT, 이문규, IT 동아)

https://yoo11052.tistory.com/32?category=945084

22.09.16
## Q. 버퍼링(Buffering)에 대해서 설명해주세요.

A. 컴퓨터 시스템에서의 처리를 어떤 장치로부터 다른 장치로 데이터를 일방통행으로 전송할 때 양자의 속도차를 수정하기 위하여 중간에서 데이터를 일시적으로 기억 장소에 축적하는 수법. 이 방식에 의하면 고속 중앙 처리 장치(CPU)와 저속 입출력 장치의 작동 속도를 조정할 수 있으며, 컴퓨터 시스템 전체의 처리 능력이 향상된다. 현재 거의 모든 컴퓨터 시스템에서 채용하고 있다.

[네이버 지식백과] 완충(buffering)

https://m.blog.naver.com/jk130694/220677902462

22.09.17
## Q. 선점 스케줄링과 비선점 스케줄링의 차이점에 대해서 설명해주세요.

A. 선점 스케줄링(preemptive scheduling)은 한 프로세스가 중앙 처리 장치(CPU)를 점유했을 때 또 다른 프로세스가 그 CPU를 점유할 수 있도록 하는 것이다. 선점 스케줄링은 높은 우선 순위의 프로세스들이 긴급을 요할 때 유용하며, 대화식 시분할 시스템에서 빠른 응답 시간을 유지하는 데 대단히 중요하다.

비선점 스케줄링(non-preemptive scheduling)은 작업이 프로세스로 생성되어 CPU를 할당받으면 프로세스가 종료되거나 입출력 조작을 위해 자발적으로 중지될 때까지 계속 실행되도록 보장하는 스케줄링 정책이다. 한 프로세스가 일단 CPU를 할당받으면 다른 프로세스가 CPU를 강제로 뺏을 수 없는 방식이다. 비선점 스케줄링은 프로세스 간의 오버헤드(overhead)가 적어 효율적이나, 대화식 시분할 시스템에는 적합하지 않고, 긴 작업이 짧은 작업을 오랫동안 기다리게 되는 경우가 발생되는 단점이 있다.

[네이버 지식백과] 선점 스케줄링, 비선점 스케줄링

https://www.uname.in/m/252

22.09.18
## Q. 데이터베이스의 차수와 카디널리티에 대해서 설명해주세요.

A. **차수**  
하나의 릴레이션에서 속성의 전체 개수를 릴레이션의 차수(degree)라고 한다. 모든 릴레이션은 최소 1 이상의 차수를 유지해야 한다. 릴레이션의 차수는 일반적으로 자주 변하지 않는다는 정적인 특징이 있다.

**카디널리티**  
하나의 릴레이션에서 투플의 전체 개수를 릴레이션의 카디널리티(cardinality)라고 한다. 투플이 없는 릴레이션이 존재할 수도 있다. 새로운 투플이 계속 삽입되거나 기존 투플이 삭제될 수 있으므로 릴레이션의 카디널리티는 일반적으로 자주 변한다는 동적인 특징이 있다.

[네이버 지식백과] 차수, 카디널리티

https://jhnyang.tistory.com/108

22.09.19
## Q. 후보키, 기본키, 대체키의 상관관계에 대해서 설명해주세요.

A. **후보키**(candidate key)는 유일성과 최소성을 만족하는 속성 또는 속성들의 집합이다. 최소성(minimality)은 키를 구성하고 있는 여러 속성 중에서 하나라도 없으면 투플을 유일하게 구별할 수 없는, 꼭 필요한 최소한의 속성들로만 키를 구성하는 특성이다. 그러므로 하나의 속성으로 구성된 키는 당연히 최소성을 만족한다.

릴레이션에서 투플을 구별하기 위해 여러 개의 후보키를 모두 사용할 필요는 없다. 데이터베이스 설계자나 관리자는 여러 후보키 중에서 기본적으로 사용할 키를 반드시 선택해야 하는데 이것이 **기본키**(primary key)다. 만약 후보키가 한 개만 존재하면 당연히 해당 후보키를 기본키로 선택해야 하겠지만 여러 개일 경우에는 데이터베이스 사용 환경을 고려하여 적합한 것을 기본키로 선택하면 된다.

**대체키**(alternate key)는 기본키로 선택되지 못한 후보키들이다. 이름에서 알 수 있듯이 대체키는 기본키를 대신할 수 있지만 기본키가 되지 못하고 탈락한 이유가 있을 수 있다. 따라서 기본키로 선택되지 못한 속성 집합이 대체키가 된다.

![image](https://dbscthumb-phinf.pstatic.net/4515_000_1/20160715112620819_1D1GTA96B.jpg/ka26_87_i1.jpg?type=w406_fst_n&wm=Y)

[네이버 지식백과] 후보키, 기본키, 대체키

https://computer-science-student.tistory.com/195

22.09.20
## Q. 도메인 제약조건에 대해서 설명해주세요.

A.
<li>각 애트리뷰트 값이 반드시 <b>원자값</b>이어야 함</li>
<li>애트리뷰트 값의 디폴트 값, 가능한 값들의 범위 등을 지정할 수 있음</li>
<li>데이터 형식을 통해 값들의 유형을 제한하고, CHECK 제약 조건을 통해 값들의 범위를 제한할 수 있음</li>
<li>SQL2는 도메인을 명시적으로 정의하는 것을 허용하지만, 오라클은 지원하지 않음</li>
<br>
  
https://rainbow97.tistory.com/entry/Database-02-4-%EB%AC%B4%EA%B2%B0%EC%84%B1-%EC%A0%9C%EC%95%BD%EC%A1%B0%EA%B1%B4

22.09.21
## Q. 물리적 데이터베이스의 히프파일과 순차파일에 대해서 설명해주세요.

A. **히프 파일**(Heap File)  
- 삽입된 순서대로 레코드를 파일 내에 배치하는 것으로서 파일의 마지막에 새로운 레코드를 삽입한다.

**순서 파일**Sequential File)  
- 레코드 필드들 중에서 순서 필드라고 하는 한 필드 값의 순서대로 디스크에 물리적으로 정렬할 수 있다.

https://swin9333.tistory.com/65

22.09.22
## Q. 트랜잭션의 원자성에 대해서 예를 들어 설명해주세요.

A. 트랜잭션의 **원자성**(atomicity)은 트랜잭션을 구성하는 연산들이 모두 정상적으로 실행되거나 하나도 실행되지 않아야 한다는 all-or-nothing 방식을 의미한다. 만약 트랜잭션을 수행하다가 장애가 발생하여 작업을 완료하지 못했다면, 지금까지 실행한 연산들 모두 처리를 취소하고 데이터베이스를 트랜잭션 작업 전의 상태로 되돌려 트랜잭션의 원자성을 보장해야 한다. 트랜잭션의 원자성을 보장하면 트랜잭션을 구성하는 연산 중 일부만 처리한 결과를 데이터베이스에 반영하는 일이 없게 된다.

[네이버 지식백과] 원자성

https://hanamon.kr/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98-acid-%EC%84%B1%EC%A7%88/

22.09.23  
## Q. SQL조건절에 사용되는 ANY / ALL 의 차이를 설명해주세요.

A. **ANY 연산자**는 주로 서브쿼리에 사용되며 하나라도 만족하는 값이 있다면 true를 반환한다.

**ALL 연산자**는 전체 만족해야 true를 반환하는 특징을 가지고 있다.

https://lhoris.tistory.com/136 

22.09.25
## Q. 현재 레코드에 공유로크가 걸려있는 경우 해당 레코드에 공유로크와 독점로크를 요청했을 때 결과를 설명해주세요.

A. 공유로크가 걸려있는 경우, 공유로크를 요청하면 허용하게 되고, 독점로크를 요청하면 대기하게 된다.

https://velog.io/@chez_kwak/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-9.-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98

22.09.26
## Q. WAL이 무엇이고 왜 필요한지 설명해주세요.

A. **WAL**(Write-Ahead-Logging)
- WAL이란 Write-Ahead Logging의 약자로 로그 선행 기입
- WAL을 사용하는 시스템에서 모든 수정은 적용을 하기 전에 먼저 로그에 기록된다.
- 트랜잭션 발생시 로그에 일단 기입하여 기록을 남기고, 특정 데이터가 쌓이면 이를 flush 해 DB의 disk에 DATA BLOCK 형태로 write하게 된다.
- 일단 Log에 적히게 되면 누가 조회를 하던간에 같은 데이터를 보여주는 일관성 (Consistency)을 보장하게 되고 서버가 다운되도 이미 Log에 기입되어 있기 때문에 원자성 (Atomicity)도 보장할 수 있다.
- REDO 및 UNDO 정보를 모두 로그에 기록하며, buffer를 비우기 전에 로그파일에 기록

https://nays111.tistory.com/12

22.09.27
## Q. 멀티프로그래밍과 멀티태스킹의 차이점에 대해 설명해주세요.

A. **멀티 프로그래밍** (Multi-programming)  
초기의 컴퓨터에서는 하나의 프로그램이 메모리에 올라가면 하나의 프로그램만 CPU가 처리를 진행할 수 있었다. 이 과정에서 프로세서의 처리 속도와 입출력 속도 간의 차이로 인해, 입출력이 완료될 때까지 프로세서는 idle한 상태가 된다. 따라서 이는 프로세서의 자원 낭비로 이루어진다.  
프로세서가 입출력 작업의 종료를 대기할 동안 하나의 프로세서에서 다른 프로그램을 수행할 수 있도록 하는 것이 멀티프로그래밍이다.

**멀티 태스킹** (Multi-tasking)  
Task란 운영체제에서 처리하는 작업의 단위 또는 정해진 일을 수행하기 위한 명령어 집합을 뜻하는데 (process 보다 확장된 개념), 멀티 태스킹은 task를 OS의 스케쥴링에 의해 task를 번갈아가며 수행하는 것을 의미한다.  
여러개의 task를 자주 번갈아가며 수행하다보니 사용자는 동시에 여러 task가 수행되고 있다고 느끼게 된다.

https://velog.io/@chy0428/OS-%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EC%84%B8%EC%8B%B1

22.09.28
## Q. 다섯 가지 점근 표기법에 대해 설명해주세요.

A.  
| 표기법 |         대략적 의미        |
|:------:|:--------------------------:|
| f=ω(g) |     f는 g보다 크다, f>g    |
| f=Ω(g) | f는 g보다 크거나 같다, f≥g |
| f=Θ(g) |   f는 g와 대략 같다, f=g   |
| f=O(g) | f는 g보다 작거나 같다, f≤g |
| f=o(g) |     f는 g보다 작다, f<g    |

https://ratsgo.github.io/data%20structure&algorithm/2017/09/13/asymptotic/

22.09.29
## Q. 데드락(Deadlock) 회피 기법인 은행원 알고리즘에 대해 설명해주세요.

A. **데드락**(교착상태) 회피는 데드락이 빠질 가능성이 있는지 없는지 운영체제가 검사하고 빠질 가능성이 없을 경우에만 자원을 할당함으로써 문제 발생을 피하는 방법이다.

데드락 회피 기법 중 하나인 **은행원 알고리즘**은, 교착상태에 빠질 가능성이 있는지 판단하기 위해 상태를 '안전상태(safe state)'와 '불안전상태(unsafe state)'로 나누고, 안전상태를 유지할 수 있는 요구만을 수락하고 불안전 상태를 초래할 사용자의 요구는 나중에 만족될 수 있을 때까지 계속 거절하는 알고리즘이다.

https://jhnyang.tistory.com/102

22.09.30
## Q. 인터럽트(interrupt)의 정의와 종류에 대해 설명해주세요.

A.  
정의: 프로그램을 실행하는 도중에 예기치 않은 상황이 발생할 경우 현재 실행 중인 작업을 즉시 중단하고, 발생된 상황에 대한 우선 처리가 필요함을 CPU에게 알리는 것.  
지금 수행 중인 일보다 더 중요한 일(ex. 입출력, 우선 순위 연산 등)이 발생하면 그 일을 먼저 처리하고 나서 하던 일을 계속해야 한다.

종류: 외부 인터럽트, 내부 인터럽트, 소프트웨어 인터럽트

https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/Interrupt.md

22.10.01
## Q. 2단계 로킹 프로토콜에 대해서 설명해주세요.

A. 기본 로킹 규약의 문제를 해결하고 트랜잭션의 직렬 가능성을 보장하기 위해 lock과 unlock 연산의 수행 시점에 대한 새로운 규약을 추가한 것이 **2단계 로킹 규약**(2PLP;2 Phase Locking Protocol)이다. 트랜잭션 스케줄의 모든 트랜잭션이 2단계 로킹 규약을 준수하면 해당 스케줄은 직렬 가능성이 보장된다.

[네이버 지식백과] 2단계 로킹 규약

https://noil0816.tistory.com/153

22.10.02
## Q. 컨테이너의 종류와 각각의 특징에 대해 아는대로 모두 설명해주세요.

A.
- 시퀀스 컨테이너: 데이터를 선형적으로 저장하고 삽입된 요소의 순서가 그대로 유지된다.
- 연관 컨테이너: 관련있는 데이터를 하나의 쌍으로 저장하는 컨테이너로 보통 균형 이진 트리나 해시 테이블을 사용하여 구현된다.
- 어댑터 컨테이너: 기존 커너테이너의 인터페이스를 제한하거나 변형하여 만든 컨테이너로 반복자를 지원하지 않아 STL 알고리즘을 이요할 수 없다.

https://techbless.github.io/2020/11/04/C-STL-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EC%9A%94%EC%95%BD-%EC%A0%95%EB%A6%AC/

22.10.04
## Q. 거품 정렬(Bubble Sort)의 구현 방식, 시간복잡도, 공간복잡도, 장단점에 대해 설명해주세요.

A.  
구현 방식:
1. 1회전에 첫 번째 원소와 두 번째 원소를, 두 번째 원소와 세 번째 원소를, 세 번째 원소와 네 번째 원소를, … 이런 식으로 (마지막-1)번째 원소와 마지막 원소를 비교하여 조건에 맞지 않는다면 서로 교환한다.
2. 1회전을 수행하고 나면 가장 큰 원소가 맨 뒤로 이동하므로 2회전에서는 맨 끝에 있는 원소는 정렬에서 제외되고, 2회전을 수행하고 나면 끝에서 두 번째 원소까지는 정렬에서 제외된다. 이렇게 정렬을 1회전 수행할 때마다 정렬에서 제외되는 데이터가 하나씩 늘어난다.

시간복잡도: O(n^2)

공간복잡도: O(n)

장점:  
- 구현이 매우 간단하고, 소스코드가 직관적이다.
- 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않다. => 제자리 정렬(in-place sorting)
- 안정 정렬(Stable Sort) 이다.

단점:  
- 시간복잡도가 최악, 최선, 평균 모두 O(n^2)으로, 굉장히 비효율적이다.
- 정렬 돼있지 않은 원소가 정렬 됐을때의 자리로 가기 위해서, 교환 연산(swap)이 많이 일어나게 된다.

https://gyoogle.dev/blog/algorithm/Bubble%20Sort.html

22.10.05
## Q. 단일 연결리스트에서 중간 삽입과 삭제를 O(n)이 아니라 $\Theta$(1)로 만들 수 있는 이유에 대해 설명해주세요.

A. 삽입 시에는 새로운 노드를 만들고 앞 노드의 주소칸만 수정하면 되고, 삭제 시에는 원하는 노드를 삭제하고 앞 노드의 주소칸만 수정하면 되기 때문이다.

https://gusdnd852.tistory.com/100

22.10.06
## Q. 파일접근 방식인 순차접근과 임의접근에 대해 설명해주세요.

A. **순차 접근(Sequential Access)**  
원하는 레코드를 찾기 위해 파일의 현재 위치에서 차례대로 탐색을 실시하는 접근 방법이다. 특별한 구현이 없다면, 레코드를 접근할 때마다 디스크를 물리적으로 움직여야하기 때문에 매우 비효율적이다.

**임의 접근(Random Access)**  
시스템이나 프로그래머가 원하는 위치부터 파일을 읽는 접근 방법이다. 5번 레코드를 접근하기 위해 1, 2, 3, 4, 5 레코드를 모두 접근하는 것이 아니라 5번 레코드를 바로 접근하기 때문에 직접 접근(direct access)라고도 한다. 단 한번의 디스크 접근을 통해 레코드에 접근하기 때문에 항상 순차 접근보다 성능이 좋거나 같다.

https://untitledtblog.tistory.com/64

22.10.07
## Q. 퀵 정렬(Quick Sort)의 구현 방식, 시간복잡도, 공간복잡도, 장단점에 대해 설명해주세요.

A.
구현 방식:  
1. 배열 가운데서 하나의 원소를 고른다. 이렇게 고른 원소를 피벗(pivot) 이라고 한다.
2. 피벗 앞에는 피벗보다 값이 작은 모든 원소들이 오고, 피벗 뒤에는 피벗보다 값이 큰 모든 원소들이 오도록 피벗을 기준으로 배열을 둘로 나눈다. 이렇게 배열을 둘로 나누는 것을 분할(Divide) 이라고 한다. 분할을 마친 뒤에 피벗은 더 이상 움직이지 않는다.
3. 분할된 두 개의 작은 배열에 대해 재귀(Recursion)적으로 이 과정을 반복한다.

시간복잡도: 평균 O(nlog₂n), 최악의 경우 O( $n^2$ )

공간복잡도: O(n)

장점:
- 불필요한 데이터의 이동을 줄이고 먼 거리의 데이터를 교환할 뿐만 아니라, 한 번 결정된 피벗들이 추후 연산에서 제외되는 특성 때문에, 시간 복잡도가 O(nlog₂n)를 가지는 다른 정렬 알고리즘과 비교했을 때도 가장 빠르다.
- 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않는다.

단점:
- 불안정 정렬(Unstable Sort) 이다.
- 정렬된 배열에 대해서는 Quick Sort의 불균형 분할에 의해 오히려 수행시간이 더 많이 걸린다.

https://www.google.com/search?q=quick+sort+time+complexity&oq=quick+sort+time+&sourceid=chrome&ie=UTF-8


22.10.08
## Q. List, Set, Map의 차이점에 대해 설명해주세요.

A.
1. List: 저장공간이 필요에 의해 자동으로 늘어난다(순서가 있는 저장공간)
- 특징: 순서가 있고, 중복을 허용(배열과 유사)
- 장점: 가변적인 배열(배열이 자동으로 늘어남)
- 단점: 원하는 데이터가 뒤쪽에 위치하는 경우 속도가 느림
- 방식: equals()를 이용한 데이터 검색

2. Set: 집합. 순서가 없다. 집합이므로 중복된 데이터가 들어갈 수 없다. 중복되지 않는 숫자(데이터)를 구할 때 사용하면 유용하다.
- 특징: 순서가 없고, 중복을 허용하지 않는다.
- 장점: 빠른 속도
- 단점: 단순 집합의 개념으로 정렬하려면 별도의 처리가 필요하다.

3. Map: 키와 데이터를 같이 저장
- 특징: Key(키)와 Value(값)으로 나눠서 데이터 관리. 순서는 없으며, 키에 대한 중복은 없음
- 장점: 빠른 속도
- 단점: Key의 검색 속도에 의해 속도가 좌우

https://milkoon1.tistory.com/44

22.10.09
## Q. 기아상태를 설명하는 식사하는 철학자 문제에 대해 설명해주세요.(운영체제)

A. 식사하는 철학자들 문제는 전산학에서 동시성과 교착 상태를 설명하는 예시로, 여러 프로세스가 동시에 돌아갈 때 교착 상태가 나타나는 원인을 직관적으로 알 수 있다.  
다섯 명의 철학자가 원탁에 앉아 있고, 각자의 앞에는 스파게티가 있고 양옆에 젓가락이 한 짝씩 있다. 그리고 각각의 철학자는 다른 철학자에게 말을 할 수 없다. 이때 철학자가 스파게티를 먹기 위해서는 양 옆의 젓가락 짝을 동시에 들고 있어야 한다. 이때 각각의 철학자가 왼쪽의 젓가락 짝을 들고 그 다음 오른쪽의 젓가락 짝을 들어서 스파게티를 먹는 알고리즘을 가지고 있으면, 다섯 철학자가 동시에 왼쪽의 젓가락 짝을 든 다음 오른쪽의 젓가락 짝을 들 때까지 무한정 기다리는 교착 상태에 빠지게 될 수 있다.  
또한 어떤 경우에는 동시에 젓가락 양짝을 집을 수 없어 식사를 하지 못하는 기아 상태가 발생할 수도 있고, 몇몇 철학자가 다른 철학자보다 식사를 적게 하는 경우가 발생하기도 한다.

https://starbirds.tistory.com/68

22.10.10
## Q. 삽입 정렬(Insertion Sort)의 구현 방식, 시간복잡도, 공간복잡도, 장단점에 대해 설명해주세요.

A.  
- 구현 방식  
1. 정렬은 2번째 위치(index)의 값을 temp에 저장한다.
2. temp와 이전에 있는 원소들과 비교하여 삽입해나간다.
3. '1'번으로 돌아가 다음 위치(index)의 값을 temp에 저장하고, 반복한다.
- 시간복잡도: 최선의 경우 O(n), 평균과 최악의 경우 O( $n^2$ )
- 공간복잡도: O(n)
- 장점:
  - 알고리즘이 단순하다.
  - 대부분의 원소가 이미 정렬되어 있는 경우, 매우 효율적일 수 있다.
  - 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않는다. → 제자리 정렬(in-place sorting)
  - 안정 정렬(Stable Sort)이다.
  - Selection Sort나 Bubble Sort과 같은 O( $n^2$ ) 알고리즘에 비교하여 상대적으로 빠르다.
- 단점:
  - 평균과 최악의 시간복잡도가 O( $n^2$ )으로 비효율적이다.
  - Bubble Sort와 Selection Sort와 마찬가지로, 배열의 길이가 길어질수록 비효율적이다.  

https://gyoogle.dev/blog/algorithm/Insertion%20Sort.html

22.10.11
## Q. 단일 연결리스트와 원형 연결리스트를 구별하는 방법에 대해 설명해주세요.

A.  
- 단순 연결 리스트와 다르게 원형 연결 리스트는 꼬리가 머리를 가리키는 구조
- 단순 연결 리스트에서 꼬리가 머리를 가리키게만 하면 됨
  - 단순 연결 리스트의 마지막 노드는 NULL을 가리킴
  - 원형 연결 리스트의 마지막 노드는 첫 번째 노드를 가리킴

https://seongkyun.github.io/data_structure/2019/03/20/data_structure/

22.10.12
## Q. IPC(Inter-Process Communication)가 무엇인가요?

A. 프로세스들 사이의 통신 기법으로서 크게 공유 기억 장치 기법과 메시지 시스템 기법이 있다. 공유 기억 장치 기법은 통신하는 프로세스들 사이에 어떤 변수를 공유하고 이 공유 변수를 이용해서 정보를 교환하도록 한다. 메시지 시스템 방법은 통신을 제공하는 책임을 운영 체제가 가지고 프로세스가 메시지를 교환할 수 있게 한다.  

[네이버 지식백과] 프로세서 간 통신(interprocessor communication)

https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/IPC(Inter%20Process%20Communication).md

22.10.13
## Q. 합병 정렬(Merge Sort)의 구현 방식, 시간복잡도, 공간복잡도, 장단점에 대해 설명해주세요.(알고리즘)

A. 병합 정렬이라고도 부르며, 분할 정복 방법을 통해 구현. 빠른 정렬로 분류되며, 퀵소트와 함께 많이 언급되는 정렬 방식이다.  
구현 방식:
1. 리스트를 반으로 나눈다
2. 왼쪽 리스트와 오른쪽 리스트를 각각 정렬한다
3. 정렬된 두 리스트를 하나의 정렬된 리스트로 합병한다.  

시간복잡도: 평균 Θ(nlogn), 최악 O(nlogn)  
공간복잡도: O(n)  
장점: 길이가 긴 리스트에서 다른 정렬 방식보다 빠르게 동작한다.  
단점: 이미 정렬이 되어있어도 전체 과정을 진행해야 한다.

https://gyoogle.dev/blog/algorithm/Merge%20Sort.html

22.10.14
## Q. 큐에 비해 원형큐가 가지는 장단점을 설명해주세요.(자료구조)

A. 장점: 데이터를 출력한 영역을 재사용할 수 없다는 선형큐의 단점을 해결할 수 있다.  
단점: 큐의 길이만큼의 원소를 저장할 수 있기 때문에, 원형큐의 사이즈를 미리 알고 있어야 한다.

https://reakwon.tistory.com/30

22.10.15
## Q. 삽입 정렬(Insertion Sort)의 구현 방식, 시간복잡도, 공간복잡도, 장단점에 대해 설명해주세요.(알고리즘)

A.  
구현 방식: 2번째 원소부터 시작하여 그 앞(왼쪽)의 원소들과 비교하여 삽입할 위치를 지정한 후, 원소를 뒤로 옮기고 지정된 자리에 자료를 삽입하여 정렬하는 알고리즘.
1. 정렬은 2번째 위치(index)의 값을 temp에 저장한다.
2. temp와 이전에 있는 원소들과 비교하며 삽입해나간다.
3. '1'번으로 돌아가 다음 위치(index)의 값을 temp에 저장하고, 반복한다.

시간복잡도: O( $n^2$ )

공간복잡도: O(n)

장점:
- 알고리즘이 단순하다.
- 대부분의 원소가 이미 정렬되어 있는 경우, 매우 효율적일 수 있다.
- 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않는다. -> 제자리 정렬(in-place sorting)
- 안정 정렬(stable sort)이다.
- Selection Sort나 Bubble Sort과 같은 O( $n^2$ ) 알고리즘에 비교하여 상대적으로 빠르다.

단점:
- 평균과 최악의 시간복잡도가 O( $n^2$ )으로 비효율적이다.
- Bubble Sort와 Selection Sort와 마찬가지로, 배열의 길이가 길어질수록 비효율적이다.

https://gyoogle.dev/blog/algorithm/Insertion%20Sort.html

22.10.17
## Q. 최소 스패닝 트리(Minimum Spanning Tree)의 개념과 특징, 사용 사례에 대해 설명해주세요.(알고리즘)

A. 한 그래프의 스패닝 트리들 중에서 가중값의 합이 가장 작은 것.  
모든 꼭지점을 연결하면서 사이클이 생기지 않는 모든 가능한 스패닝 트리 중에서 간선의 가중치 합이 최소가 된다.  
통신 회사에서 케이블을 매설하려고 할 때, 집을 꼭짓점으로, 케이블을 간선으로, 케이블 매설 비용을 가중치로 하는 그래프를 생각하면, 최소 스패닝 트리가 통신 회사 입장에서 가장 경제적인 방법이 된다.

[네이버 지식백과] 최소 스패닝 트리  
[Wikipedia] Minimun spanning tree

22.10.18
## Q. Race Condition이란 무엇인가요?(운영체제)

A. 두 개 이상의 프로세스가 공통 자원을 병행적으로(concurrently) 읽거나 쓸 때, 공용 데이터에 대한 접근이 어떤 순서에 이루어졌는지에 따라 그 실행 결과가 달라지는 상황.

https://drehzr.tistory.com/m/87

22.10.19
## Q. 힙 정렬(Heap Sort)의 구현 방식, 시간복잡도, 공간복잡도, 장단점에 대해 설명해주세요.(알고리즘)

A. 구현 방식:  
1. 완전이진 트리로 정렬할 원소들을 최대 힙 트리로 구성한다.
2. 원소 하나씩 추출(삭제)하여 배열의 뒤부터 저장한다.
3. 최댓값부터 삭제되며, 삭제되는 순서로 정렬된다.

시간복잡도: O(nlogn)

공간복잡도: O(nlogn)

장점: 항상 O(nlogn)이라는 시간 복잡도를 가져 효율적이다.

단점: 불안정 정렬이다. 이상적일 경우에 퀵정렬보다 느리다. 데이터 상태에 따라 다른 정렬에 비해 느린 편이다.

[네이버 지식백과] 힙 정렬

https://velog.io/@jaeyunn_15/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B0%81-%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B9%84%EA%B5%90

https://gyoogle.dev/blog/algorithm/Heap%20Sort.html

22.10.20
## Q. 모바일 기기용 주소록에 BST와 HashTable 중 어떤 자료구조를 사용하는 것이 좋은가요? 이유와 함께 설명해주세요.(자료구조)

A. 모바일 기기용 주소록을 위해서는 이진 탐색 트리(Binary Search Tree, BST)를 사용하는 것이 해시 테이블(Hash Table)을 사용하는 것보다 좋다. 해시 테이블은 서로 다른 두 개의 키값이 해시 함수에 의해 같은 해시값으로 변환되는 해시 충돌이 일어날 수 있다. 이진 탐색 트리는 범위 기반 쿼리가 가능하다. 또한 메모리 효율 측면에서도 이진 탐색 트리가 더 유리하다.

https://algorfati.tistory.com/123

https://adevspoon.com/?code=CraoR_VdQ88QEcGkHil4mvWlchcI-MEvvCJHnyFcBLjvVPro7wvnxFb3iVtr3XPQrmViMAo9dJkAAAGD9Zmmqw

22.10.21
## Q. 내부 단편화와 외부 단편화의 차이점에 대해 설명해주세요.

A.  
내부 단편화: 기억 장치가 의도된 바 없이 할당될 때 일어난다. 공간이 낭비된다. "내부"라는 용어는 필요 없는 기억 자료가 할당된 영역 안에 있지만 쓰이지 않는 것을 말한다. 운영체제의 메모리 관리기법 중 페이징을 이용할 때 발생할 수 있다. 일정 크기의 페이지에 프로세스 할당시, 프로세스의 크기가 페이지보다 작을 경우 내부 단편화가 발생한다.  
외부 단편화: 여유 공간이 여러 조각으로 나뉘는 현상을 말한다. 프로그램이 다양한 크기의 기억 장소의 남은 영역을 할당하고 할당을 해제할 때 일어나며, 할당 알고리즘이 약화된다. 비록 남은 기억 공간을 사용할 수 있지만, 조각이 너무 작게 나 있어서 응용 프로그램의 성능을 뒷받쳐 주지 못하기 때문에 효과적으로 사용하지 못하게 된다. "외부"라는 용어는 사용할 수 없는 기억 장소가 할당된 영역 밖에 있다는 것을 뜻한다.

[위키백과] 단편화  

https://m.blog.naver.com/rbdi3222/220623825770

22.10.22
## Q. 크루스칼 알고리즘(Kruskal's Algorithm)에 대해 설명해주세요.(알고리즘)

A. 그래프 내의 모든 정점들을 가장 적은 비용으로 연결하기 위해 사용되는 최소 신장 트리 알고리즘. 그래프 간선들을 가중치의 오름차순으로 정렬해 놓은 뒤, 사이클을 형성하지 않는 선에서 정렬된 순서대로 간선을 선택한다.

https://chanhuiseok.github.io/posts/algo-33/

22.10.23
## Q. Red-Black Tree에 대해 설명해주세요.(자료구조)

A. 레드-블랙 트리(Red-Black Tree)는 이진 트리의 특수한 형태로서, 컴퓨터 공학 분야에서 숫자 등의 비교 가능한 자료를 정리하는 데 쓰이는 자료구조이다. 레드-블랙 트리에서는 리프 노드들은 비어있고, 자료를 가지고 있지 않다. 레드-블랙 트리는 각각의 노드가 레드나 블랙인 색상 속성을 가지고 있다. 이진 탐색 트리가 가지고 있는 일반적인 조건에 다음과 같은 추가적인 조건을 만족하면 레드-블랙 트리가 된다.

1. 노드는 레드 혹은 블랙 중의 하나이다.
2. 루트 노드는 블랙이다.
3. 모든 리프 노드들(NIL)은 블랙이다.
4. 레드 노드의 자식노드 양쪽은 언제나 블랙이다. (즉, 레드 노드는 연달아 나타날 수 없으며, 블랙 노드만이 레드 노드의 부모 노드가 될 수 있다.)
5. 어떤 노드로부터 시작되어 그에 속한 하위 리프 노드에 도달하는 모든 경로에는 리프 노드를 제외하면 모두 같은 개수의 블랙 노드가 있다.

위 조건들을 만족하게 되면, 레드-블랙 트리는 가장 중요한 특성을 나타내게 된다: 루트 노드부터 가장 먼 루트 노드 경로까지의 거리가, 가장 가까운 루트 노드 경로까지의 거리의 두 배보다 항상 작다. 다시 말해서 레드-블랙 트리는 개략적으로 균형이 잡혀 있다. 따라서 삽입, 삭제, 검색 시 최악의 경우에서의 시간복잡도가 트리의 높이에 따라 결정되기 때문에 보통의 이진 탐색 트리에 비해 효율적이라고 할 수 있다.

[위키백과] 레드-블랙 트리

https://blogshine.tistory.com/102

22.10.24
## Q. RDBMS와 Nospl의 차이점을 설명해주세요.(데이터베이스)

A.  
관계형 데이터베이스(RDBMS)는 정해진 스키마에 따라 데이터를 저장해야 하므로 명확한 데이터 구조를 보장한다는 장점이 있는 반면, 테이블 간 관계를 맺고 있어 시스템이 커질 경우 JOIN문이 많은 복잡한 쿼리가 만들어질 수 있고, 성능 향상을 위해서는 서버의 성능을 향상시키는 Scale-up만을 지원하기에 비용이 기하급수적으로 늘어날 수 있으며, 스키마로 인해 데이터가 유연하지 못하고 스키마가 변경될 경우 번거롭고 어렵다는 단점이 있다.  
Nosql(Not Only SQL)은 스키마가 없기 때문에 유연하고 자유로운 데이터 구조를 가질 수 있으므로 언제든 저장된 데이터를 조정하고 새로운 필드를 추가할 수 있으며, 데이터 분산이 용이하며 성능 향상을 위한 Scale-up 뿐만이 아닌 Scale-out 또한 가능하다는 장점이 있는 반면, 데이터 중복이 발생할 수 있으며 중복된 데이터가 변경될 경우 수정을 모든 컬렉션에서 수행해야 하고, 스키마가 존재하지 않기에 명확한 데이터 구조를 보장하지 않으며 데이터 구조 결정이 어려울 수 있다는 단점이 있다.

https://khj93.tistory.com/entry/Database-RDBMS%EC%99%80-NOSQL-%EC%B0%A8%EC%9D%B4%EC%A0%90#:~:text=NoSQL%EC%9D%B4%EB%9E%80(Not%20Only%20SQL,%EA%B4%80%EA%B3%84%EB%A5%BC%20%EC%A0%95%EC%9D%98%ED%95%98%EC%A7%80%20%EC%95%8A%EC%8A%B5%EB%8B%88%EB%8B%A4.

22.10.25
## Q. 선택 정렬(Selection Sort)의 구현 방식, 시간복잡도, 공간복잡도, 장단점에 대해 설명해주세요.(알고리즘)

A.  
구현 방식:
1. 주어진 배열 중에 최솟값을 찾는다.
2. 그 값을 맨 앞에 위치한 값과 교체한다.
3. 맨 처음 위치를 뺀 나머지 배열을 같은 방법으로 교체한다.

시간복잡도: O( $n^2$ )

공간복잡도: O(n)

장점: 알고리즘이 단순하다, 많은 교환이 일어나야 하는 자료상태에서 비교적 효율적이다, 다른 메모리 공간을 필요로 하지 않는다.

단점: 시간복잡도 측면에서 비효율적이다, 불안정 정렬이다.

https://gyoogle.dev/blog/algorithm/Selection%20Sort.html

22.10.26
## Q. 기아상태와 교착상태의 차이점에 대해 설명해주세요.(운영체제)

A. 교착 상태는 프로세스가 실행을 위해 진행되지 않고 각 프로세스가 다른 프로세스에 의해 획득된 리소스를 기다리는 조건인 반면 기아 상태에서는 우선순위가 높은 프로세스가 우선순위가 낮은 프로세스를 방지하는 리소스를 지속적으로 사용하여 리소스를 확보한다.

https://ko.gadget-info.com/difference-between-deadlock

22.10.27
## Q. 연관 컨테이너의 종류와 각각의 특징에 대해 설명해주세요.(자료구조)

A.  
**연관 컨테이너**(associate container)는 키(key)와 값(value)처럼 관련있는 데이터를 하나의 쌍으로 저장하는 컨테이너이다. 키와 값을 이용한 연관 컨테이너는 요소들에 대한 빠른 접근을 제공해준다. 하지만 연관 컨테이너는 삽입되는 요소의 위치를 지정할 수는 없다. 이러한 연관 컨테이너는 보통 균형 잡힌 이진 탐색 트리(balanced binary search tree)나 해시 테이블(hash table)을 이용하여 구현한다.  

종류:
1. set: 집합(set) 컨테이너는 저장하는 데이터 그 자체를 키로 사용하는 가장 단순한 연관 컨테이너이다. 검색 속도가 매우 빠르다. 키의 중복을 허용하지 않는다.
2. multiset: 키의 중복을 허용하므로, 같은 값을 여러 번 저장할 수 있다.
3. map: 맵(map) 컨테이너는 키와 값의 쌍으로 데이터를 관리하는 진정한 연관 컨테이너이다. 검색 속도가 매우 빠르다. 키의 중복을 허용하지 않는다.
4. multimap: 값의 중복을 허용하므로, 하나의 키가 여러 개의 값과 연관될 수 있다.

http://www.tcpschool.com/cpp/cpp_container_associate

22.10.28
## Q. 쉘 정렬(Shell Sort)의 구현 방식, 시간복잡도, 공간복잡도, 장단점에 대해 설명해주세요.(알고리즘)

A. 구현 방식:
1. 일정한 간격으로 배열을 분류한다.
2. 연속적이지 않은 여러 부분 배열을 생성한다.
3. 각 부분 배열에 삽입 정렬을 이용하여 정렬한다.
4. 모든 부분 배열이 정렬되면 다시 전체 배열을 부분 배열로 만들며 반복한다.(부분 배열로 나눌 때 간격은 홀수가 좋으나, 짝수가 나오면 +1을 해서 홀수로 만든다.)
5. 부분 배열의 개수가 1이 될 때까지 반복한다.

시간복잡도: 평균 O( $n^{1.5}$ ), 최악 O( $n^2$ )

공간복잡도: O(n)

장점: 버블정렬보다 빠르다.

단점: 구조가 복잡하고 이해하기 어렵다.

[네이버 지식백과, 위키백과] 쉘 정렬

https://yabmoons.tistory.com/247

22.10.29
## Q. Array와 ArrayList의 차이점에 대해 설명해주세요.(자료구조)

A.  
Array는 고정 길이이다. 따라서, 정해진 길이의 배열을 모두 채우면, 새로운 데이터를 추가하고 싶을 경우 새로운 배열을 만들어주어야 한다.  
ArrayList는 가변 길이이다. 하지만 내부적으론 배열로 구성되어 있다.  

https://velog.io/@humblechoi/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-Array-vs-ArrayList

22.10.30
## Q. Race Condition이 발생하는 경우는 언제인가요?(운영체제)

A.
## [OS] Race Condition

공유 자원에 대해 여러 프로세스가 동시에 접근할 때, 결과값에 영향을 줄 수 있는 상태

> 동시 접근 시 자료의 일관성을 해치는 결과가 나타남

<br>

#### Race Condition이 발생하는 경우

1. ##### 커널 작업을 수행하는 중에 인터럽트 발생

   - 문제점 : 커널모드에서 데이터를 로드하여 작업을 수행하다가 인터럽트가 발생하여 같은 데이터를 조작하는 경우
   - 해결법 : 커널모드에서 작업을 수행하는 동안, 인터럽트를 disable 시켜 CPU 제어권을 가져가지 못하도록 한다.

2. ##### 프로세스가 'System Call'을 하여 커널 모드로 진입하여 작업을 수행하는 도중 문맥 교환이 발생할 때

   - 문제점 : 프로세스1이 커널모드에서 데이터를 조작하는 도중, 시간이 초과되어 CPU 제어권이 프로세스2로 넘어가 같은 데이터를 조작하는 경우 ( 프로세스2가 작업에 반영되지 않음 )
   - 해결법 : 프로세스가 커널모드에서 작업을 하는 경우 시간이 초과되어도 CPU 제어권이 다른 프로세스에게 넘어가지 않도록 함

3. ##### 멀티 프로세서 환경에서 공유 메모리 내의 커널 데이터에 접근할 때

   - 문제점 : 멀티 프로세서 환경에서 2개의 CPU가 동시에 커널 내부의 공유 데이터에 접근하여 조작하는 경우
   - 해결법 : 커널 내부에 있는 각 공유 데이터에 접근할 때마다, 그 데이터에 대한 lock/unlock을 하는 방법

https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/Race%20Condition.md#os-race-condition

22.10.31
## Q. 그리디 알고리즘(Greedy Algorithm)이 무엇인지 설명하고 그리디 알고리즘의 종류에 대해 아는 대로 이야기해주세요.(알고리즘)

A. 그리디 알고리즘이란 현재 상황에서 가장 좋은 것(최선의 선택)을 고르는 알고리즘이다.  
종류:
- 선택 정렬
- 배낭 문제
- 최소 신장 트리
- 단일 출발지 최단 경로
- 스케줄링 문제
- 프림 알고리즘
- 크루스컬 알고리즘
- 다익스트라 알고리즘
- 허프만 코딩
- 포드-풀커슨 알고리즘

https://velog.io/@contea95/%ED%83%90%EC%9A%95%EB%B2%95%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98
https://www.programiz.com/dsa/greedy-algorithm

22.11.01
## Q. 시퀀스 컨테이너의 조건과 종류, 각각의 특징에 대해 설명해주세요.(자료구조)

A. **시퀀스 컨테이너**(sequence container)
- 메모리 상에서 모든 요소가 직전 순서로 배치되어 순서가 존재해야 한다. 즉, 첫 번째 요소와 마지막 요소를 제외한 모든 요소는 앞뒤로 컨테이너의 요소가 존재해야 한다.
- 반복자가 이동할 때 요소의 순서가 변경되지 않음을 보장하기 위해 반복자는 최소 순방향 반복자를 사용해야 한다.
- 시퀀스 컨테이너는 직선 순서로 배치되어 명확한 순서가 존재하므로 특정 위치에 대한 참조가 가능해야 한다.

종류:
- vector: 벡터 컨테이너는 동적 배열의 클래스 템플릿으로 가장 기본이 되는 컨테이너로, 데이터가 들어가고 나올 수 있는 입출구가 뒤쪽 하나이며 앞쪽은 막혀있는 형태이다. 따라서 데이터를 넣을 때도 뒤에서부터 쌓이고 데이터를 꺼낼 때는 맨 뒤에서부터 뺄 수 있다.
- deque: 디큐 컨테이너는 vector 컨테이너를 개선한 컨테이너로, double-ended queue를 의미하며 양쪽에 끝이 있는 큐(queue)라는 뜻이다. vector는 뒤쪽에서만 요소의 삽입과 삭제가 가능했지만 deque는 양 끝에서 빠르게 요소를 삽입하거나 삭제할 수 있다.
- list: 리스트 컨테이너는 vector, deque와 같은 시퀀스 컨테이너이지만 노드 기반 컨테이너로 이중 연결 리스트(double linked list)의 클래스 템플릿 표현이다. 노드 기반이기 때문에 [ ]이나 at() 함수를 통한 임의 접근은 불가능하지만 컨테이너의 모든 요소에서 양방향 접근을 통해 빠른 삽입과 삭제가 가능하다.

https://winterflower.tistory.com/113

22.11.02
## Q. 페이징이란 무엇인가요?(운영체제)

A. 페이징(paging)이란 논리주소의 고정된 페이지(Page)라고 불리는 블록들로 분할 관리하는 기법이다. 각각의 페이지는 물리 메모리의 프레임과 맴핑한다. 페이지를 가리키는 논리주소에서 프레임을 가리키는 물리주소로 변환한다.

https://jhnyang.tistory.com/m/290

22.11.03  
## Q. 인터넷과 인트라넷의 차이점에 대해서 설명해주세요.(네트워크)

A.  
인터넷(internet): 통신망과 통신망들이 연결되어 있는 망들의 집합들을 의미한다. 중앙의 호스트 컴퓨터도 없고, 관리하는 단체 및 조직도 없다. 서로의 통신망이 연결된 서비스이다. 전세계를 망라하는 초거대 통신 네트워크 망의 집합체이다.  
인트라넷(intranet): 네트워크 기술을 이용하여 특정 단체의 내부업무를 통합하는 정보시스템을 의미한다. 인터넷이 아닌 별도의 통신망을 이용하여 조직 내부시스템을 구축하는 것이다.  
공통점: 같은 통신망을 이용한다.  
차이점: 모든 사람이 사용하는지, 특정 대상만 사용하는지

https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=bloghkit&logNo=220576307382

22.11.04
## Q. 다익스트라 알고리즘(Dijkstra's Algorithm)에 대해 설명해주세요.(알고리즘)

A. 다익스트라 알고리즘은 그래프에서 한 정점(노드)에서 다른 정점까지의 최단 경로를 구하는 알고리즘 중 하나이다. 현재 위치한 노드의 인접한 방문하지 않은 노드 중 거리가 가장 짧은 노드를 방문하는 것을 반복하는 알고리즘이다. 가중치가 양수일 때만 사용 가능하다는 중요한 특징이 있다.

https://velog.io/@717lumos/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BCDijkstra-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98

22.11.05
## Q. 보조인덱스와 클러스터링 인덱스의 차이에 대해 설명해주세요.(데이터베이스)

A.  
보조 인덱스
- 데이터와 인덱스를 각각 다른 위치에 저장
- 인덱스는 해당 데이터의 위치에 대한 포인터를 포함
- 테이블당 여러 개 생성 가능

클러스터형 인덱스
- 키 값에 대한 테이블의 데이터 행을 정렬하는 인덱스의 한 유형
- 테이블의 데이터를 정렬해서 저장되는 순서를 정의
- 테이블당 하나만 생성 가능
- 행 데이터를 인덱스로 지정한 열에 맞춰서 자동으로 정렬

https://jie0025.tistory.com/107

22.11.06
## Q. 운영체제와 커널의 차이점에 대해 설명해주세요.(운영체제)

A.  
운영체제: 시스템 리소스를 관리하는 시스템 소프트웨어. 사용자와 시스템 하드웨어 간의 인터페이스 역할을 한다.  
커널: 운영체제의 핵심. 시스템 작동을 시작하기 위해 주 메모리에 로드되는 운영 체제의 첫 번째 프로그램. 사용자가 입력한 명령을 컴퓨터가 이해하도록 변환한다.

https://ko.gadget-info.com/difference-between-kernel

22.11.07
## Q. 그래프와 트리의 차이점에 대해 설명해주세요.(자료구조)

A.   
그래프와 트리는 모두 비선형 자료구조이다. 인접(전후) 원소들 간에 트리는 1:n 관계로, 그래프는 n:m 관계로 배치된다. 트리는 사이클이 없는 연결 그래프이고, 그래프는 트리의 성질을 포함하면서 사이클을 허용한다.

https://bigsong.tistory.com/33

22.11.08
## Q. 프로토콜에 대해서 설명해주세요.(네트워크)

A. 프로토콜(Protocol): 통신 프로토콜 또는 통신 구약은 컴퓨터나 원거리 통신 장비 사이에서 메시지를 주고 받는 양식과 규칙의 체계이다. 즉 통신 규약 및 약속이다.

프로토콜의 기본 요소
- 구문(Syntax): 전송하고자 하는 데이터의 형식(Format), 부호화(Coding), 신호 레벨(Signal Level) 등을 규정
- 의미(Semantics): 두 기기 간의 효율적이고 정확한 정보 전송을 위한 협조 사항과 오류 관리를 위한 제어 정보를 규정
- 시간(Timing): 두 기기 간의 통신 속도, 메시지의 순서 제어 등을 규정

프로토콜의 종류
|          계층          |                프로토콜                |
|:----------------------:|:--------------------------------------:|
| 응용(Application)      | HTTP, SMTP, FTP, Telnet                |
| 표현(Presentation)     | ASCII, MPEG, JPEG, MIDI                |
| 세션(Session)          | NetBIOS, SAP, SDP, NWLink              |
| 전송(Transport)        | TCP, UDP, SPX                          |
| 네트워크(Network)      | IP, IPX                                |
| 데이터 링크(Data Link) | Ethernet, Token Ring, FDDI, Apple Talk |
| 물리(Physical)         | 없음                                   |

프로토콜의 기능  
단편화(Fragmentation)와 재합성(Assembly)  
단편화: 송신 측에서는 긴 데이터 블록을 손쉽게 전송할 수 있도록 크기가 똑같은 작은 블록으로 나누어 전송
재합성: 수신 측에서 쪼개진 작은 데이터 블록을 재합성하여 원래의 메시지로 복원하는 기능

캡슐화(Encapsulation)  
각 프로토콜에 적합한 데이터 블록을 만들려고 데이터에 정보를 추가하는 것  
플래그, 주소, 제어 정보, 오류 검출 부호 등을 부착하는 기능

연결 제어(Connection Control)  
비연결 데이터 전송(데이터그램)과 연결 위주 데이터 전송(가상회선)을 위한 통신로를 개설, 유지, 종결하는 기능

흐름 제어(Flow Control)  
데이터양이나 통신속도 등이 수신 측의 처리 능력을 초과하지 않도록 조정하는 기능

오류 제어(Error Control)  
데이터 전송 중 발생할 수 있는 오류나 착오 등을 검출하고 정정하는 기능

순서 결정(Sequencing)  
연결 위주의 데이터를 전송할 때 송신 측이 보내는 데이터 단위 순서대로 수신 측에 전달하는 기능

주소 설정(Addressing)  
발생지, 목적지 등의 주소를 명기하여 데이터를 정확하게 전달하는 기능

동기화(Synchronization)  
두 통신 객체의 상태(시작, 종류, 검사 등)를 일치시키는 기능

다중화(Multiplexing)  
하나의 통신로를 여러 개로 나누거나 회선 여러 개를 하나의 통신로로 변환시켜 다수의 가입자가 동시에 사할 수 있도록 하는 기능

전송 서비스(Transmission Service)  
통신 객체를 사용하기 쉽도록 별도로 추가 서비스(패리티 검사, 보안도, 서비스 등급, 우선순위 등)를 제공하는 기능

https://computer-science-student.tistory.com/377

22.11.09
## Q. 칸 알고리즘(Kahn's Algorithm)에 대해 설명해주세요.(알고리즘)

A. 위상 정렬 알고리즘 중 하나이다. 궁극적인 위상 정렬로써 같은 순서 속에 있는 꼭짓점에 의해 선택된다.

https://www.techiedelight.com/ko/kahn-topological-sort-algorithm/

22.11.10
## Q. 기본키와 엔티티 무결성 제약 조건에 대해서 설명해주세요.(데이터베이스)

A. 기본키와 엔티티 무결성 제약조건(entity integrity constraint)
- 기본키가 각 튜플들을 식별하기 위하여 사용되기 때문에 릴레이션의 기본키를 구성하는 어떤 애트리뷰트도 Null값을 가질 수 없다는 제약조건
- 대체키에는 적용되지 않음(기본키에만 적용)
- 사용자는 릴레이션을 생성하는 데이터 정의문에서 어떤 애트리뷰터가 릴레이션의 기본키의 구성요소인가를 DBMS에게 알려줌

https://rainbow97.tistory.com/entry/Database-02-4-%EB%AC%B4%EA%B2%B0%EC%84%B1-%EC%A0%9C%EC%95%BD%EC%A1%B0%EA%B1%B4

22.11.11
## Q. URL과 URI의 차이에 대해 설명해주세요.(네트워크)

A.  
URI(Uniform Resource Identifier): 특정 리소스를 식별하는 통합 자원 식별자. 웹기술에서 사용하는 논리적 또는 물리적 리소스를 식별하는 고유한 문자열 시퀀스이다.  
URL(Uniform Resource Locator): 흔히 웹 주소라고도 하는, 컴퓨터 네트워크 상에서 리소스가 어디 있는지 알려주기 위한 규약. URI의 서브셋이다.  
URI는 식별하고 URL은 위치를 가리킨다.

https://www.charlezz.com/?p=44767

22.11.12
## Q. CPU 스케줄링 알고리즘의 종류와 각각에 대해 아는대로 설명해주세요.(운영체제)

A.
- FCFS(First Come, First Serve): 먼저 도착한 프로세스를 먼저 처리하는 스케줄링 알고리즘이다.
- SJF(Shortest Job First): 최단적업우선 스케줄링 알고리즘이다. 여기서 최단작업이란 CPU버스트 타임이 가장 짧은 프로세스를 말한다.
- Priority Scheduling(우선순위 스케줄링): 미리 주어진 프로세스의 우선순위에 따라서 스케줄링하는 방식이다.
- Round Robin(라운드 로빈): 정해진 시간 할당량만큼 프로세스를 할당한 뒤, 작업이 끝난 프로세스는 준비완류 큐(순환 큐)의 가장 마지막에 가서 재할당을 기다린다.
- Multilevel-Queue(다단계 큐): 준비완료 큐를 여러 개의 큐로 분류하여 각 큐가 각각 다른 스케줄링 알고리즘을 가지는 방식.
- Multilevel-Feedback-Queue(다단계-피드백 큐): 기존 다단계 큐 방식은 특정 프로세스가 큐에 고정되는 방식인 반면 다단계 피드백 큐에서는 큐와 큐 사이에 프로세스가 이동하는 걸 허용한다.

https://dduddublog.tistory.com/23

22.11.13
## Q. Stack 2개로 queue를 구현하는 방법을 섦명해주세요.(자료구조)

A.  
1. Stack1로는 data를 입력받는다.
2. Stack2로는 data를 pop한다.
3. Stack2가 비어있다면 Stack1에서 Stack2로 data를 옮긴다.

https://velog.io/@wonhee010/Stack-2%EA%B0%9C%EB%A1%9C-Queue-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0

22.11.14
## Q. 프림 알고리즘(Prim's Algorithm)에 대해 설명해주세요.(알고리즘)

A. MST(최소신장트리)를 찾기 위한 그리디 패러다임 알고리즘.
1. 임의의 점 하나를 선택하여 T에 넣는다.
2. T 밖에 있는 점들 중에서 T에 있는 점과 가장 가까운 점을 T에 추가한다.
3. 2를 n-1회 수행한다.

https://www.weeklyps.com/entry/%ED%94%84%EB%A6%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Prims-algorithm

22.11.15
## Q. 데이터 사전(data dictionary)에 대해서 설명해주세요.(데이터베이스)

A. 데이터 사전(Data Dictionary)이란?
- 데이터 사전이란 대부분 읽기전용으로 제공되는 테이블 및 부들의 집합으로 데이터베이스 전반에 대한 정보를 제공한다.
- 오라클 데이터베이스는 명령이 실행될 때마다 데이터 사전을 Access 한다.
- DB작업 동안 Oracle은 데이터 사전을 읽어 객체의 존재여부와 사용자에게 적합한 Access 권한이 있는지를 확인한다. 또한 Oracle은 데이터 사전을 계속 갱신하여 데이터베이스 구조, 감사, 사용자권한, 데이터 등의 변경사항을 반영한다.

https://tragramming.tistory.com/75

22.11.16
## Q. 라우터와 스위치의 차이에 대해 말씀해주세요.(네트워크)

A.  
**스위치**  
- 목적지로 출발한 데이터를 중간에 적합한 경로로 스위칭해주는 역할. 데이터링크 계층에 속해있으므로 MAC주소 기반으로 동작한다.

**라우터**
- 목적지로 가는 적합한 경로를 찾아주는 라우팅 기능을 한다. 네트워크 계층에 속해있으므로 IP주소를 기반으로 동작한다.

**라우터와 스위치의 차이**
- 라우터는 네트워크 계층에서 IP주소를 기반으로 동작하며 스위치는 데이터링크 계층에서 MAC주소를 기반으로 동작한다.
- 스위치는 브로드캐스트 도메인을 구분할 수 없는 반면 라우터는 브로드캐스트 도메인을 구분하여 서로 다른 네트워크 대역을 구분한다.
- 스위치는 불명확한 목적지를 가진 데이터를 처리할 때 모든 포트로 데이터를 퍼뜨리는 브로드캐스트를 하지만 라우터는 해당 데이터를 버린다.
- 스위치는 관리자의 설정이 필요없지만 라우터는 관리자의 설정으로 라우팅 테이블 생성과 통신을 해야 한다.

https://velog.io/@jihoon97/%EC%8A%A4%EC%9C%84%EC%B9%98-%EB%9D%BC%EC%9A%B0%ED%84%B0%EC%9D%98-%EC%B0%A8%EC%9D%B4

22.11.17
## Q. CISC와 RISC의 차이에 대해 설명해주세요.(운영체제)

A.  
**CISC(Complex Instruction Set Computer)**
- 필요한 모든 명령어 셋을 갖추도록 설계된 마이크로프로세서

**RISC(Reduced Instruction Set Computer)**
- 가장 자주 사용되는 명령어만으로 개수를 줄인 마이크로프로세서

**차이점**
|        분류       |                                 CISC컴퓨터                                 |                                 RISC컴퓨터                                 |
|:-----------------:|:--------------------------------------------------------------------------:|:--------------------------------------------------------------------------:|
|      레지스터     |              8~16개의 범용 레지스터 사용 부동소수점 연산 제공              | 16~32개의 범용 레지스터 사용 부가적인 레지스터 사용 가능기본적인 연산 제공 |
|      설계목적     |               최소의 프로그램 길이 1개의 명령어로 최대의 동작              |            프로그램의 길이는 길어도 명령어 당 실행 시간의 최소화           |
|     명령어형식    | 다양한 길이와 형식 LOAD /STORE,레지스터와 메모리의 다양한 명령어 형식 제공 |                   고정길이의 명령어 제공 두가지 형식 제공                  |
|      명령어군     |          OS와 RUN TIME 유틸리티를 지원하는 데이터 형과 명령어 제공         |               LOAD/STORE 범용 레지스터 레지스터의 데이터 연산              |
|       인코딩      |                          1개의 명령어 = 1개의 문장                         |                  1개의 명령어 = 1개의 오퍼랜드나 1개 연산                  |
|     구현측면성    |               마이크로 프로그램 제어 방식의 프로 웨어로 구성               |             하드웨어 제어 방식의 프로세서와 소프트 세서로 구성             |
|      기타특징     |                              하드웨어가 강조됨                             |                             소프트웨어가 강조됨                            |
| 코드크기와 사이클 |                  작은 코드 크기, 단위시간동안 높은 사이클                  |                  단위시간동안 낮은 사이클수, 큰 코드 크기                  |
|     트렌지스터    |                축약명령어를 저장을 위해 트랜지스터가 사용됨.               |              메모리 레지스터에 보다 많은 트랜지스터가 사용됨.              |

https://chlalgud8505.tistory.com/8

22.11.18
## Q. HashMap과 HashTable의 차이를 설명해주세요.(자료구조)

A.  
- HashMap은 동기화(Synchronization)을 지원하지 않는 반면 다중 스레드 환경에서 HashTable은 동기화를 지원한다.
- 속도 측면에서 HashTable은 동기화 처리 비용 때문에 HashMap에 비해 더 느리다.
- HashMap은 저장된 요소들의 순회를 위해 Fail-Fast Iterator를 반환하는 반면 HashTable은 Enumeration을 반환한다.

https://odol87.tistory.com/3

22.11.19
## Q. 피보나치 수열을 구현할 때에 재귀, 동적 계획법, 반복을 이용하는 방식의 차이를 시간 복잡도와 연관지어 설명해주세요.(알고리즘)

A.  
재귀: 피보나치 수열을 재귀방식으로 구현하게 되면, f(n)은 f(n-2) + f(n-1)을 리턴하고, 이는 다시 f(n-4) + f(n-3)과 f(n-3) + f(n-2)을 더하는 것으로 리턴이 된다. 이렇게 f(0) = 0, f(1) = 1의 base step까지 재귀 호출을 하게 되는데, 이때 실행되는 횟수는 $2^n$회이므로, 시간 복잡도는 O( $2^n$ )이 된다.

동적 계획법: 피보나치 수열을 동적 계획법으로 구현하게 되면, f(0) = 0, f(1) = 1에서 시작하여 f(0) + f(1) = f(2)의 f(2)값을 저장하고, f(1) + f(2) = f(3)의 f(3)값을 저장하는 등의 순서로 f(n-2) + f(n-1) = f(n)까지 반복하게 된다. 이때 실행되는 횟수는 n-1회이므로, 시간 복잡도는 O(n)이 된다.

반복: 피보나치 수열을 for 반복문을 이용하여 구현하게 되면, 시간 복잡도는 동적 계획법과 마찬가지로 O(n)이지만 대신 각 스텝에서 피보나치 수를 저장하지 않기 때문에, 공간 효율이 더 낫다.

https://velog.io/@im_lily/%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%EC%88%98%EC%97%B4-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84

22.11.20
## Q. 심층 신경망(DNN)의 장단점에 대해 설명해주세요.

A.  
장점:
1. 연속형, 범주형 변수에 상관없이 모두 분석 가능하다.
2. 입력 변수들 간의 비선형 조합이 가능하다. 이는 다른 신경망에 비해 DNN이 가지는 가장 좋은 장점 중 하나이다.
3. 예측력이 다른 머신러닝 기법들에 비해 상대적으로 우수한 경우가 많다.
4. feature extraction이 자동으로 수행된다. 이것은 변수 선택의 번거로움을 줄여준다.
5. Data 양이 많아지면 성능이 계속 좋아진다.

단점:
1. 신경망이 복잡할 경우 작동하는 데 시간이 오래 걸린다. 때문에 GPU가 장착된 컴퓨터 및 고사양의 컴퓨터가 필요하다.
2. 분석 시 변수들을 일정한 순서나 방식으로 넣는 것이 아니기 때문에 결과가 일정하지 않다.
3. 가중치의 의미를 정확히 해석하기가 어렵기 때문에 결과 해석이 어렵다.

https://www.todaymart.com/631

22.11.21
## Q. 로깅을 이용한 데이터베이스의 회복에 대해서 간략히 설명해주세요.(데이터베이스)

A.  
1. **지연 갱신 회복 기법(Defferred Update)**  
트랜잭션이  부분 완료 상태에 이르기까지 발생한 모든 변경 내용을 로그 파일에만 저장하고, 데이터베이스에는 Commit이 발생할 때까지 저장을 지연하는 기법

2. **즉시 갱신 회복 기법(Immediate Update)**  
트랜잭션 수행 도중 데이터를 변경하면 변경 정보를 로그 파일에 저장하고, 트랜잭션이 부분 완료되기 전이라도 모든 변경 내용을 즉시 데이터베이스에 반영하는 기법

https://itwiki.kr/w/%EB%A1%9C%EA%B7%B8_%EA%B8%B0%EB%B0%98_%ED%9A%8C%EB%B3%B5_%EA%B8%B0%EB%B2%95  
https://bubble-dev.tistory.com/entry/DB-Recovery-%EB%A1%9C%EA%B9%85-%EB%B0%A9%EC%8B%9D

22.11.22
## Q. 프록시에 대해 설명해주세요.(네트워크)

A. **프록시(proxy)**  
데이터를 가져올 때 해당 사이트에서 바로 자신의 PC로 가져오는 것이 아니라 임시 저장소를 거쳐서 가져오는 것. 프록시를 설정하면 수 초의 빠른 속도를 느낄 수 있다. 프록시 서버에는 다수의 사용자들이 들르는 사이트에 대한 데이터가 저장되어 있어 경우에 따라 해당 사이트에 들르지 않고 바로 이 서버에 있는 데이터를 이용하기도 한다. 하지만 프록시 서버에 문제가 생겼거나 과부하가 걸렸을 경우 오히려 더 느려지는 경우도 있다. (사이트 → 프록시 서버 → PC)

[네이버 지식백과] 프록시  
https://terms.naver.com/entry.naver?docId=834076&cid=42344&categoryId=42344  
https://brownbears.tistory.com/191

22.11.23
## Q. 페이징(Paging)과 세그멘테이션(Segmentation)을 사용하는 이유와 차이점에 대해 설명해주세요.(운영체제)

A.  
다중 프로그래밍 시스템에서 다수의 프로세스를 수용하기 위해 주기억장치를 동적으로 분할하는 메모리 관리 작업을 위해 페이징과 세그멘테이션을 사용함.  

**페이징(Paging)**  
- 프로세스를 일정한 크기의 페이지로 분할해서 메모리에 적재하는 방식
- 하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애는 메모리 관리 방법  

**세그멘테이션(Segmentation)**  
- 가상 메모리를 서로 크기가 다른 논리적 단위로 분할한 것
- 프로세스를 물리적 단위인 페이지가 아닌 논리적 단위인 세그먼트로 분할해서 메모리에 적재하는 방식
- 세그먼트는 의미가 같지 않은 논리적 내용을 기준으로 프로그램을 분할하기 때문에 크기가 같지 않음  

**차이점**
- 페이징은 외부 단편화가 생기지 않는 대신 내부 단편화가 발생할 수 있고, 세그멘테이션은 반대로 내부 단편화가 생기지 않는 대신 외부 단편화가 발생할 수 있음

https://velog.io/@gang_shik/%ED%8E%98%EC%9D%B4%EC%A7%95Paging%EA%B3%BC-%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%85%8C%EC%9D%B4%EC%85%98Segmentation#%ED%8E%98%EC%9D%B4%EC%A7%80%EC%99%80-%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%85%8C%EC%9D%B4%EC%85%98

22.11.24
## Q. AVL 트리에 대해서 설명해주세요.(자료구조)

A.  
이진탐색트리는 한 쪽으로 노드가 쏠릴 경우 탐색 시간 복잡도가 O(N)이 되게 된다. 이런 단점을 극복할 수 있는 자료구조가 **AVL 트리**(Adelson-Velsky and Landis 이름의 앞글자를 따서)이다. 편향트리를 AVL트리로 재구성하면 O(logN)의 시간 복잡도를 갖게 된다. AVL트리는 다음과 같은 특징을 갖는다.  
1. 이진 탐색 트리의 속성을 가진다.
2. 왼쪽, 오른쪽 서브 트리의 높이 차이가 최대 1이다.
3. 높이 차이가 1보다 커지면 회전(Rotation)을 통해 균형을 맞춰 높이 차이를 줄인다.
4. 삽입, 검색, 삭제의 시간 복잡도가 O(logN)이다.

https://code-lab1.tistory.com/61?category=1213002

22.11.26
## Q. n개의 배열에서 k째로 큰 수를 찾는 알고리즘에 대해 설명해주세요.(알고리즘)

A.  
Quick Selection 알고리즘:  
1. Array의 element 중 random한 하나의 element를 pivot으로 정한다.
2. Array를 A1(Array의 element 중 pivot보다 작은 element들을 모은 Array)와 A2(pivot보다 큰 element들을 모은 Array)로 partitioning 한다.
3. A1의 배열 Size에 따라, 다음의 세 가지 경우로 나뉜다.
    - k번째 큰 element가 A2 배열 내에 있는 경우, Input Array를 A2로 정한 뒤 k번째 큰 element를 찾는 Subproblem의 값을 반환한다.
    - k가 A1의 Size + 1인 경우, pivot이 k번째 큰 element가 되므로 pivot을 반환한다.
    - k번째 큰 element가 A1 배열 내에 있는 경우, Input Array를 A1으로 정한 뒤 k-(A2 Size + 1)번째 큰 element를 찾는 Subproblem의 값을 반환한다.

https://2jinishappy.tistory.com/124  
https://gils-lab.tistory.com/94

22.11.27
## Q. 의사결정나무(Decision Tree)의 장단점에 대해 설명해주세요.(머신러닝)

A. **의사결정나무(Decision Tree)**  
한 번에 하나씩의 설명을 하면서, 예측 가능한 규칙들의 집합을 생성하는 알고리즘.  

장점:  
- 범주와 연속형 수치를 모두 예측할 수 있다.
- 구조가 단순하여 해석이 용이하고, 유용한 입력 변수의 파악, 예측 변수 간의 상호작용, 비선형성을 고려하여 수학적 가정이 불필요한 비모수적 모형이다.
- 시장조사, 광고조사, 의학연구, 품질관리 등 다양한 분야에서 활용되고 있다.
- 고객 타겟팅, 고객의 신용점수화, 캠페인에 대한 반응, 고객 행동 예측 등에 유용하다.

단점:
- 분류 기준값의 경계선 근방의 자료값에 대해서는 오차가 클 수 있다.
- 로지스틱 회귀와 같이 각 예측 변수의 효과를 파악하기 어렵다.
- 새로운 자료에 대한 예측이 불안정할 수 있다.
- 상위 노드로부터, 하위 노드로 트리구조를 형성하는 모든 단계마다 기준값의 선택이 중요하다.

https://schoolforkids.tistory.com/entry/decision-tree

22.11.28
## Q. 트랜잭션의 연산 중 ROLLBACK의 개념을 간략히 설명해주세요.(데이터베이스)

A.  
- 작업 중 문제가 발생되어서 트랜잭션의 처리 과정에서 발생한 발견사항을 취소하는 명령어
- ROLLBACK 역시 하나의 트랜잭션 과정을 종료하게 됨
- 트랜잭션으로 인한 하나의 묶음 처리가 시작되기 이전의 상태로 되돌림
- Transaction(INSERT, UPDATE, DELETE) 작업 내용을 취소함
- 이전 COMMIT한 곳까지만 복구함

https://itprogramming119.tistory.com/entry/Oracle-ROLLBACK%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%EA%B3%BC%EC%A0%95

22.11.29
## Q. 쿠키와 세션의 차이에 대해 설명해주세요.(네트워크)

A.  
- 쿠키와 세션은 비슷한 역할을 하며, 동작원리도 비슷함. 그 이유는 세션도 결국 쿠키를 사용하기 때문
- 가장 큰 차이점은 사용자의 정보가 저장되는 위치. 때문에 쿠키는 서버의 자원을 전혀 사용하지 않으며, 세션은 서버의 자원을 사용
- 보안 면에서 세션이 더 우수하며, 요청 속도는 쿠키가 더 빠름. 세션은 서버의 처리가 필요하기 때문
- 쿠키는 클라이언트 로컬에 저장되기 때문에 변질되거나 request에서 스니핑당할 우려가 있어 보안에 취약하지만 세션은 쿠키를 이용해서 sessioned 만 저장하고 그것으로 구분해서 서버에서 처리하기 때문에 비교적 보안성이 좋음
- 쿠키도 만료시간이 있지만 파일로 저장되기 때문에 브라우저를 종료해도 계속해서 정보가 남아있을 수 있음. 또한 만료기간을 넉넉하게 잡아두면 쿠키삭제를 할 때까지 유지될 수도 있음
- 세션도 만료시간을 정할 수 있지만 브라우저가 종료되면 만료시간에 상관없이 삭제됨. 예를 들어, 크롬에서 다른 탭을 사용해도 세션은 공유됨. 다른 브라우저를 사용하게 되면 다른 세션을 사용할 수 있음
- 쿠키에 정보가 있기 때문에 서버에 요청 시 속도가 빠르고 세션은 정보가 서버에 있기 때문에 처리가 요구도어 비교적 느린 속도를 가짐

https://interconnection.tistory.com/74

22.11.30
## Q. 가상 메모리(Virtual Memory)에 대해 설명해주세요.

A. main memory(RAM)의 크기가 작아서 모든 정보를 담기에 부족한 경우 하드디스크까지 main memory(RAM)를 확장해서 사용하는 것을 Virtual Memory 기법이라고 한다.  

https://d-cron.tistory.com/30

22.12.01
## Q. 트리 순회 방식인 전위 순회, 중위 순회, 후위 순회에 대해 설명해주세요.(자료구조)

A. **이진 트리의 순회 종류**  
- 이진 트리의 노드 전체를 한 번씩 방문하는 것을 순회(traversal)라고 함
- 노드 데이터를 처리하는 순서에 따라 전위 순회, 중위 순회, 후위 순회로 구분됨
- 전위 순회
  1. 현재 노드 데이터 처리
  2. 왼쪽 서브 트리로 이동
  3. 오른쪽 서브 트리로 이동
- 중위 순회
  1. 왼쪽 서브 트리로 이동
  2. 현재 노드 데이터 처리
  3. 오른쪽 서브 트리로 이동
- 후위 순회
  1. 왼쪽 서브 트리로 이동
  2. 오른쪽 서브 트리로 이동
  3. 현재 노드 데이터 처리

[성균관대 문제해결과알고리즘 수업자료]  
https://withhamit.tistory.com/282

22.12.02
## Q. 거품 정렬, 퀵 정렬, 힙 정렬, 합병 정렬에 대하여 각각의 최선, 평균, 최악의 시간 복잡도에 대해 설명해주세요.(알고리즘)

A.  
|           |     최선     |     평균     | 최악         |
|:---------:|:------------:|:------------:|--------------|
| 거품 정렬 |  $O(N^2)$  |  $O(N^2)$  | $O(N^2)$   |
|  퀵 정렬  | $O(NlogN)$ | $O(NlogN)$ | $O(N^2)$   |
|  힙 정렬  | $O(NlogN)$ | $O(NlogN)$ | $O(NlogN)$ |
| 합병 정렬 | $O(NlogN)$ | $O(NlogN)$ | $O(NlogN)$ |

https://yabmoons.tistory.com/250

22.12.03
## Q. generative model과 discriminative model의 차이에 대해 설명해주세요.(머신러닝)

A.  
**generative model**  
- 데이터 X가 생성되는 과정을 두 개의 확률모형, 즉 $P(Y)$, $P(X|Y)$으로 정의하고, 베이즈룰을 사용해 $P(Y|X)$를 간접적으로 도출하는 모델
- 레이블 정보가 있어도 되고(지도학습기반의 generative model, 선형판별분석이 대표적 사례), 없어도 구축할 수 있다(비지도학습 기반의 generative model, 가우시안 믹스처 모델, 토픽모델링이 대표적 사례).

**discriminative model**  
- 데이터 X가 주어졌을 때 레이블 Y가 나타날 조건부확률 $P(X|Y)$를 직접적으로 반환하는 모델
- 레이블 정보가 있어야 하기 때문에 지도학습(supervised learning) 범주에 속하며 X의 레이블을 잘 구분하는 결정경계(decision boundary)를 학습하는 것이 목표
- generative model에 비해 가정이 단순하고, 학습데이터 양이 충분하다면 좋은 성능을 내는 것으로 알려져있음
- 선형회귀, 로지스틱회귀가 대표적인 예시

**차이점**  
![image](https://user-images.githubusercontent.com/71001479/205445141-e7cb44b2-451b-4319-8636-67cbbe29c1e1.png)  
- generative model은 사후확률을 간접적으로, discriminative model은 직접적으로 도출함  
![image](https://user-images.githubusercontent.com/71001479/205445202-fee6b867-4e72-48bd-a5b4-9947d92b6c06.png)  
- generative model은 데이터 범주의 분포를, discriminative model은 결정경계를 학습함  

https://ratsgo.github.io/generative%20model/2017/12/17/compare/

22.12.04
## Q. 트랜잭션의 연산 중 COMMIT의 개념을 간략히 설명해주세요.(데이터베이스)

A. **COMMIT**  
저장되지 않은 모든 데이터를 데이터베이스에 저장하고 현재의 트랜잭션을 종료하라는 명령(데이터베이스에서 트랜잭션이란 논리적인 일의 단위를 말함)

http://itnovice1.blogspot.com/2019/01/commit.html

22.12.05
## Q. IPv4 고갈로 생겨난 서브넷팅이란 무엇인가요?(네트워크)

A.  
- IPv4 주소 체계는 클래스를 나누어 IP를 할당하는데, 클래스를 할당한 후 호스트를 일부만 할당하면 나머지 호스트가 낭비되는 비효율성을 해결하기 위해 네트워크 장치들의 수에 따라 효율적 사용이 가능한 서브넷(subnet)이 등장함
- 서브넷은 IP 주소에서 네트워크 영역을 부분적으로 나눈 부분 네트워크를 뜻하는데, 서브넷을 만들 때 사용되는 것이 서브넷 마스크(subnet mask)
- 서브넷 마스크를 이용하면 원본 네트워크를 여러 개의 네트워크로 분리할 수 있는데, 이러한 과정을 서브넷팅(subneting)이라고 함
- 세브넷팅은 IP 주소 낭비를 방지하기 위해 원본 네트워크를 여러 개의 서브넷으로 분리하는 과정을 뜻하며, 서브넷 마스크의 bit 수를 증가시켜 할당할 수 있는 네트워크를 증가시키고 호스트 수를 감소시킴

https://code-lab1.tistory.com/34

22.12.06
## Q. 메모리 단편화(Memory Fragmentation)에 대해 설명해주세요.(운영체제)

A.  
**단편화**  
프로세스에 대한 메모리 할당과 해방을 반복함으로써 메모리의 분할부가 다수 생성되는 것. 사용할 수 있는 메모리가 프로세스가 요구하는 크기보다 작기 때문에 어떤 요구도 만족할 수 없고, 사용하지 않은 상태로 남아있는 상태.

**내부 단편화**  
프로세스에 필요한 공간보다 메모리가 더 많이 할당되었을 때, 프로세스 내부에서 발생되는 단편화.

**외부 단편화**  
메모리가 할당과 해제를 반복하면서 작은 공간의 메모리 영역이 생기게 되는데, 그 공간이 어떤 프로세스가 필요로 하는 크기보다 작은 경우 발생되는 단편화. 전체적으로 남는 메모리는 프로세스가 필요로 하는 공간보다 크지만, 각각의 분할부는 충족하지 못하는 상황.

[네이버 지식백과] 단편화 https://terms.naver.com/entry.naver?docId=823914&cid=42344&categoryId=42344  
https://kosaf04pyh.tistory.com/40

22.12.07
## Q. BFS(Breadth-First Search)와 DFS(Depth-First Search)에 대해 설명해주세요.(자료구조)

A. BFS(너비 우선 탐색)과 DFS(깊이 우선 탐색) 모두 그래프를 탐색하는 방법이다.

**DFS**  
- 루트 노드(혹은 다른 임의의 노드)에서 시작해서 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방식
- 현재 정점에서 갈 수 있는 점들까지 들어가면서 탐색
- 모든 노드를 방문하고자 하는 경우 이 방법을 선택함
- 스택 또는 재귀함수로 구현
- BFS보다 간단함
- BFS보다 검색 속도가 느림


**BFS**  
- 루트 노드(혹은 다른 임의의 노드)에서 시작해서 인접한 노드를 먼저 탐색하는 방법으로, 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져있는 정점을 나중에 방문하는 순회 방법
- 현재 정점에 연결된 가까운 점들부터 탐색
- 두 노드 사이의 최단 경로를 찾고 싶을 때 이 방법을 선택함
- 큐를 이용해서 구현
- DFS보다 복잡함
- DFS보다 검색 속도가 빠름

https://velog.io/@lucky-korma/DFS-BFS%EC%9D%98-%EC%84%A4%EB%AA%85-%EC%B0%A8%EC%9D%B4%EC%A0%90

22.12.08
## Q. 외판원 순회 문제(Travelling Salesman Problem)에 대해 설명하고 이를 해결하기 위한 알고리즘을 제시해주세요.(알고리즘)

A.  
- 임의의 한 도시에서 출발하여 다른 모든 도시를 1번씩만 방문하고 출발했던 도시로 돌아오는 여행 경로의 거리를 최소화하는 문제임
- 다양한 알고리즘으로 최적 해를 찾을 수 있으나 모두 지수 시간이 소요됨
- 도시 수가 많아지면 오랜 소요 시간으로 최적 해를 찾기 어려움
- TSP와 유사한 특성을 가진 최소 신장 트리를 통해 해결할 수 있음
- 알고리즘:
  1. 입력 그래프에서 MST T를 찾는다
  2. T의 시작점에서 트리의 간선을 따라 모든 점을 방문하고 다시 시작점으로 방문 순서를 찾는다
  3. 2에서 찾은 방문 순서에서 중복된 점들을 제거하여 TSP 경로를 만든다. 단, 마지막의 시작점은 제거하지 않는다

[성균관대 문제해결과알고리즘 수업자료]  
https://loosie.tistory.com/272

22.12.09
## Q. training set, validation set, test set의 차이에 대해 설명해주세요.(머신러닝)

A.  
**Training set**: 학습 과정에서 사용되는 예시 데이터 집합

**Validation set**: training set을 통해 학습을 한 여러 모델의 성능을 측정하기 위한 데이터 집합

**Test set**: validation set을 통해 결정된 모델의 성능을 측정하기 위한 데이터 집합

https://modern-manual.tistory.com/19  
https://davincilabs.ai/blog/?q=YToxOntzOjEyOiJrZXl3b3JkX3R5cGUiO3M6MzoiYWxsIjt9&bmode=view&idx=10640969&t=board

22.12.10
## Q. 데이터베이스 함수 종속 중 완전 함수 종속, 부분 함수 종속, 이행적 함수 종속에 대해서 설명해주세요.(데이터베이스)

A.  
**함수 종속성**  
- DB에서 속성들 간 종속 관계를 의미하며, 불필요한 데이터 중복을 줄이고 데이터 베이스를 더욱 논리적으로 만드는 정규화를 위해 필요한 개념
- 어떤 테이블 R에 존재하는 필드들의 부분 집합을 각각 X와 Y라고 할 때, X의 한 값이 Y에 속한 값에만 매핑될 경우는 Y는 X에 함수 종속적이라고 하며 X -> Y로 표기
- 이때 X를 결정자, Y를 종속자라고 부름

**완전 함수 종속(Full Functional Dependency)**  
- 기본키가 종속자이며 기본키가 여러 속성으로 구성되어 있을 경우 기본키를 구성하는 모든 속성이 포함된 부분 집합 또한 종속자일 경우

**부분 함수 종속(Partial Functional Dependency)**  
- 릴레이션에서 종속자가 기본키가 아닌 다른 속성에 종속되거나, 기본키를 구성하는 여러 속성들의 부분집합 중 일부분에만 종속되어 있는 경우

**이행적 종속(Transitive Dependency)**  
- X, Y, Z라는 3가지 부분집합을 가진 릴레이션에서 {X -> Y}이고 {Y -> Z}일 때 {Y -> Z}가 아니라면 암스트롱의 공리에 의해 {X -> Z}가 되는데 이 경우 X는 Z의 이행적 종속이라고 함

https://been2.tistory.com/40

22.12.11
## Q. 패킷교환방식과 회선교환방식의 차이에 대해 설명해주세요.(네트워크)

A.  
패킷교환방식  
- 전송하려는 데이터를 패킷이라는 단위로 나눠 네트워크망으로 뿌려주게 된다.
- 패킷에는 해당 데이터가 어떤 데이터의 몇 번째 데이터인지 정보와 최종 목적지에 대한 정보가 들어가있다.
- 위의 정보를 라우터가 보고 패킷을 최적경로를 향해 전달하게 된다.
- 이때 최적경로는 거리 뿐 아니라 망의 혼잡도(대역폭 사용률), 연결상태, 기타설정 등에 따라 달라질 수 있다.
- 특정한 데이터가 여러 개의 패킷으로 분해되어 전송되면, 패킷듣은 라우터에 의해 서로 다른 경로로 전송될 수 있고, 최종적으로 목적지에 모든 패킷이 전달되면 패킷의 순서를 통해 다시 원래의 데이터로 합지는 방식이다.

회선교환방식  
- 회선 독점을 통한 통신방식으로, 통신 회선을 설정하여 데이터를 교환하는 방식이다..
- 데이터 전송을 위한 전용선을 할당하고 해당 선로로 모든 데이터를 전송한다.
- 송신자의 모든 데이터는 동일한 경로로 전송된다.

https://youngq.tistory.com/72

22.12.12
## Q. 멀티 프로세스(Multi Process)와 멀티 쓰레드(Multi Thread)의 차이에 대해 설명해주세요.(운영체제)

A.  
**멀티 프로세스**  
- 두 개 이상 다수의 프로세서(CPU)가 협력적으로 하나 이상의 작업(Task)을 동시에 처리하는 것(병렬처리)
- 각 프로세스 간 메모리 구분이 필요하거나 독립된 주소 공간을 가져야 할 경우 사용

**멀티 쓰레드**  
- 하나의 프로세스에 여러 스레드로 자원을 공유하며 작업을 나누어 수행하는 것  

**차이점**  
- 멀티 스레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고 Context Switching이 빠른 장점이 있지만, 동기화 문제와 하나의 스레드 장애로 전체 스레드가 종료될 위험을 갖고 있음
- 멀티 프로세서는 하나의 프로세스가 죽더라도 다른 프로세스에 영향을 주지 않아 안정성이 높지만, 멀티 스레드보다 많은 메모리공간과 CPU 시간을 차지하는 단점이 있음
- 두 방법은 동시에 여러 작업을 수행하는 점에서 동일하지만, 각각의 장단이 있으므로 적용하는 시스템에 따라 적합한 동작 방식을 선택하고 적용해야 함

https://wooody92.github.io/os/%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9C/

22.12.13
## Q. 단일연결리스트와 이중연결리스트의 차이점에 대해 설명해주세요.(자료구조)

A.  
**단일연결리스트**  
- head 노드와 tail 노드를 제외한 각 노드는 데이터와 다음 노드의 주소를 가지고 있다.

**이중연결리스트**  
- head 노드와 tail 노드를 제외한 각 노드는 데이터와 이전 노드의 주소, 다음 노드의 주소를 가지고 있다.  

https://pstudio411.tistory.com/entry/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-Linked-List-Hash-Table

22.12.14
## Q. A* 알고리즘에 대해 설명해주세요.(알고리즘)

A.  
A*(A star) 알고리즘: 시작점과 목표점이 주어졌을 때 그 사이의 최단 경로를 찾아주는 길찾기 알고리즘의 하나. 주어진 탐색영역을 그리드로 나눠 2차원 배열로 단순화한 뒤, 시작점의 인접 사각형부터 시작하여 각 사각형에 경로 채점을 통해 최단 경로에 포함되는 사각형을 찾고 도착점에 도달하면 거꾸로 거슬러 올라가 경로를 저장한다.  

https://itmining.tistory.com/66

22.12.15
## Q. 가지치기(Pruning)에 대해 설명해주세요.(머신러닝)

A.  
- 의사결정나무 학습 알고리즘에서 과적합에 대응하기 위한 주요 수단
- 의사결정나무 학습에서 최대한 정확한 훈련 샘플의 분류를 위해 노드에 대한 분할과정이 지속적으로 반복되는데, 때로 과도한 반복은 가지 수를 지나치게 많이 만들어버림
- 이때 발생할 수 있는 문제는 훈련 샘플을 '너무 잘 학습하여 훈련 세트 자체의 어떤 특징들을 모든 데이터가 가지고 있는 일반적인 특성으로 착각하게 만드는' 과적합이며, 따라서 자발적으로 가지를 잘라 과적합 위험을 방지할 수 있도록 해야 함
- 가지치기: 의사결정나무에서 과적합을 방지하기 위해 적절한 수준에서 Terminal Node를 결합해주는 것

https://velog.io/@jhbale11/%EB%8B%A8%EB%8B%A8%ED%95%9C-%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D-4%EC%9E%A5-%EC%9D%98%EC%82%AC%EA%B2%B0%EC%A0%95%EB%82%98%EB%AC%B4

22.12.16
## Q. 데이터베이스에서 savepoint와 truncate에 대해 설명해주세요.(데이터베이스)

A.  
**DB 트랜잭션**  
- 데이터 처리의 한 단위
- DB는 데이터를 저장, 수정, 삭제하는 작업을 바로 물리적인 하드디스크에 저장된 데이터에 적용하지 않음(메모리단에서 적용됨)
- 이는 개발자가 실수로 잘못된 명령문을 입력했을 때 다시 원래 상태로 되돌리기 위한 안전 장치
- 개발자가 commit을 하기 전까지 입력한 명령문은 메모리에서만 동작하다가 커밋이 발생하면 그때 하드디스크에 반영
- 데이터에 대한 작업을 하기 위해 입력하는 명령문들의 시작부터 커밋까지가 하나의 트랜잭션

**ROLLBACK**  
- 데이터의 저장, 삭제, 수정 등의 작업을 하고 난 후 원래의 상태로 되돌리는 작업
- 커밋 이후에는 롤백을 해도 커밋 전으로 돌아갈 수 없음

**COMMIT**  
- 하나의 트랜잭션을 물리적인 데이터베이스에 적용하는 작업
- 커밋을 하면 롤백을 해도 되돌릴 수 없음

**SAVEPOINT**  
- savepoint를 지정하면 rollback 시 해당 지정위치로 복원이 가능
- savepoint 명령어로 지점을 지정하고 rollback 명령어로 복원

**TRUNCATE**  
- 지정된 테이블의 모든 데이터를 지움
- 커밋이 자동으로 되므로 rollback이 불가능
- delete문은 DB에 바로 반영하지 않고 메모리에 적용 후 커밋이 되어야 적용이 되므로 rollback이 가능
- 반면에 truncate는 수행하는 순간 바로 커밋을 날려서 DB에 반영하므로 rollback이 불가능

https://ws-pace.tistory.com/154

22.12.17
## Q. DNS 서버 구성방식 중 하나인 DNS Round Robin에 대해 설명해주세요.(네트워크)

A.  
Domain에 대한 IP 요청 쿼리 시 round robin 방식, 즉 프로세스들 사이에 우선순위를 두지 않고 순서에 따라 시간단위로 IP를 반환한다.

https://velog.io/@eu_nzi/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-DNS-round-robin%EC%9D%98-%EB%B0%A9%EC%8B%9D

22.12.18
## Q. RAM과 ROM의 차이에 대해 설명해주세요.(운영체제)

A.  
**RAM**  
- Random Access Memory의 약어
- 휘발성 메모리(Volatile Memory)로, 전원이 차단되면 데이터가 사라짐
- CPU에 비해 하드디스크는 너무 느리기 때문에, 하드디스크보다 빠른 메모리(RAM)를 CPU와 하드디스크 사이에 위치
- 자주 쓰는 데이터를 RAM에 위치시켜 CPU에서 고속으로 처리 가능

**ROM**  
- Read Only Memory의 약어
- 비휘발성 메모리(Non-Volatile Memory)로, 전원이 차단되어도 데이터가 사라지지 않음
- BIOS(컴퓨터를 켰을 때 처음으로 시작되는 프로그램) 소프트웨어가 설치되어 있음

https://information-factory.tistory.com/270

22.12.19
## Q. Array의 특징과 장단점을 시간복잡도와 연관지어 설명해주세요.(자료구조)

A.  
**Array(배열)**  
- 연속된 메모리 공간에 순차적으로 저장된 데이터 모음으로, 선형 자료구조  
- 배열을 구성하는 각각의 값을 요소(element)라고 하며, 배열에서 위치를 가리키는 숫자는 인덱스(index)라고 함  

**배열의 시간 복잡도**  
| Operation | average case | worst case |
|-----------|--------------|------------|
| read      | O(1)         | O(1)       |
| insert    | O(n)         | O(n)       |
| delete    | O(n)         | O(n)       |
| search    | O(n)         | O(n)       |  

**장점**  
- 인덱스를 이용한 접근이 가능하기 때문에 모든 요소에 빠르게(O(1)) 접근할 수 있다

**단점**  
- 메모리가 순차적으로 이어져 있어야 하기 때문에, 중간에 특정 요소를 삽입 및 삭제하는 경우 해당 요소로부터 위에 있는 모든 요소들을 이동시켜줘야 하므로 삽입 및 삭제에 시간이 많이 걸림(O(n))

https://yoongrammer.tistory.com/43

22.12.20
## Q. 비트마스크로 집합을 구현할 때에, 모든 부분 집합을 순회하는 방식을 비트 마스크 연산자와 연관지어 설명해주세요.(알고리즘)  

A.  
부분 집합 순회를 위해 필요한 비트마스크 연산은 AND 연산(&)과 Shift(<<, >>) 연산이다.  
AND 연산은 두 정수 변수를 한 비트씩 비교하며 해당 비트가 둘 모두 켜져있으면(1이면) 비트를 켠다(1로 표시).  
Shift 연산은 어떤 정수의 비트들을 왼쪽 또는 오른쪽으로 원하는 만큼 움직이고, 빈 자리는 0으로 채우는 연산이다.  
먼저 정수 1을 집합 원소의 개수(n) 만큼 Shift 연산하여(2의 n승을 곱하여) 부분집합의 개수를 만들어 루프(i)시킨다.  
그 다음으로 집합 원소의 개수만큼 루프(j)시킨다.  
그리고 i와 1<<j의 AND 연산을 하여, i의 j번째 비트가 1이면 j번째 원소를 포함하게 하면 된다.  

https://rebro.kr/63  
https://j-ungry.tistory.com/137

22.12.21  
## Q. 앙상블(Ensemble)에 대해 설명해주세요.(머신러닝)  

A.  
- 앙상블 학습(Ensemble Learning)은 여러 개의 분류기를 생성하고, 그 예측을 결합함으로써 보다 정확한 예측을 도출하는 기법을 말함
- 강력한 하나의 모델을 사용하는 대신 보다 약한 모델 여러 개를 조합하여 더 정확한 예측에 도움을 주는 방식
- 여러 개의 분류기가 투표를 통해 최종 예측 결과를 결정하는 보팅(Voting) 방식, 데이터 샘플링(Bootstrap)을 통해 모델을 학습시키고 결과를 집계(Aggregating)하는 배깅(Bootstrap AGGregatING, Bagging) 방식, 여러 개의 분류기가 순차적으로 학습을 수행하며 이전 분류기가 예측이 틀린 데이터에 대해서 올바르게 예측할 수 있도록 다음 분류기에게 가중치(weight)를 부여하면서 학습과 예측을 진행하는 부스팅(Boosting) 방식이 있음

http://www.dinnopartners.com/__trashed-4/

22.12.22  
## Q. 데이터베이스에서 트리거와 프로시저의 차이점을 설명해주세요.(데이터베이스)  

A.  
**트리거(Trigger)**  
- 데이터베이스 시스템에서 데이터의 입력, 갱신, 삭제 등의 이벤트(Event)가 발생할 때마다 자동적으로 수행되는 절차형 SQL을 의미
- 트리거(trigger)는 사전적으로 '방아쇠'를 의미하며, 방아쇠를 당기면 자동으로 총알이 나가듯이 트리거는 테이블에 이벤트가 발생하면 자동으로 실행됨
- DCL은 사용할 수 없고, DDL, DML은 사용할 수 있음

**프로시저(Procedure)**  
- 특정 기능을 수행하는 일종의 트랜잭션 언어로, 호출을 통해 실행되어 미리 저장해놓은 SQL작업을 수행함  
- 처리결과를 반환하지 않거나 한 개 이상의 값을 반환함
- 실행환경과 Stored Program 사이에 값을 전달하기 위해 IN, OUT, IN OUT 등의 파라미터를 사용함

https://hijjang2.tistory.com/392

22.12.23  
## Q. 자동 재전송 방식인 ARQ의 종류와 각 방식에 대해 설명해주세요.(네트워크)  

A.  
**ARQ**
- Automatic Repeat Request의 약자로, 자동 반복 요청을 의미. 에러가 발생한 경우 재전송을 요구하는 방식  

**Stop-and-Wait ARQ**  
- 수신측으로붜 ACK을 받을 때까지 대기하다가 전송하는 방법
- 반이중 방식으로 다른 ARQ 방식보다 전송 효율이 낮음
- 송신측은 프레임을 보냄과 동시에 타이머를 작동시킴, 수신측에서 보낸 ACK를 받으면 타이머가 멈춤
- 송신측은 전송한 프레임의 사본을 보관하고 있다가 타이머가 만료되면 해당 프레임을 다시 보냄 
- ACK이 오지 않은 경우 프레임이 손실, 중복, 순서 바뀜이 일어난 것으로 판단
- 수신자 쪽에서의 과정이 단순함

**Go-back-N ARQ**  
- 오류가 난 지점부터 전송한 지점까지 모두 재전송하는 기법
- 타이머가 만료되면 ACK가 오지 않은 프레임(sliding window의 첫 프레임)부터 재전송함
- ex) 6번 프레임을 보냈는데 3번 프레임의 타이머가 만료된 경우, 송신자는 뒤로 돌아가서 3, 4, 5, 6번 프레임을 다시 보냄

**Selective Repeat ARQ**  
- 오류가 난 부분만 재전송하는 기법
- NAK를 사용하여 개선할 수 있음
- NAK를 쓰게 되면 타이머가 만료되기 전에 해당 프레임을 재전송해야 한다는 것을 알 수 있으므로 빠른 재전송이 가능함
- 수신자 쪽에서의 과정이 복잡함

**Adaptive ARQ**  
- 전송 효율을 최대한 높이기 위해 데이터 프레임의 길이를 동적으로 변경하여 전송함
- 수신측이 송신측에게 수신한 데이터 프레임을 감지하고 오류 발생률을 판단하여 송신측에 오류 발생률을 통보하면 송신측은 통신회선의 오류 발생률이 낮으면 긴 프레임임을, 높으면 짧은 프레임을 전송함

https://www.uname.in/211

22.12.24  
## Q. 운영체제란 무엇인가요? 운영체제가 필요한 이유는 무엇이고 하는 역할은 무엇인가요?(운영체제)

A.  
**운영체제(OS, Operating System)**  
- 컴퓨터 시스템과 사용자 사이에서 중개자 역할을 하는 시스템 소프트웨어
- 사용자가 컴퓨터를 사용하는 데에 있어 대부분의 작업을 운영체제가 처리해줌
- 하드웨어와 사용자 사이의 인터페이스를 제공하고, 한정적인 시스템 자원을 보다 효율적으로 사용할 수 있도록 도와줌

**운영체제가 필요한 이유**
- 사용자의 요청에 대하여 빠르고 정확하게 시스템 자원을 제공하고 많은 양의 데이터를 처리해주기 위해
- 사용자 측면: 사용자가 편리하게 원하는 동작을 수행할 수 있도록 하기 위해
- 시스템 측면: 어떠한 동작을 최대한 효율적으로 무리없이 구동하기 위해
    - 처리능력: 같은 시간동안 처리할 수 있는 작업량
    - 응답시간: 사용자의 요청에 대한 결과를 산출하기까지 소요되는 시간
    - 신뢰성: 시스템이 산출한 결과의 정확성
    - 사용 가능성: 사용자의 요구에 시스템 자원을 지원 여부

**운영체제의 역할**
- 프로세스 관리
    - 프로세스의 생성, 제거, 중지, 재시작, 동기화
    - 프로세스간 통신
    - 교착상태 방지 기법 등을 제공
- 기억장치 관리
    - 주기억장치 이용 프로세스 파악
    - 주기억장치에 프로세스를 적재 및 회수 
- 입출력장치 관리
    - 입출력장치의 상태 파악
    - 입출력장치 스케줄링
- 정보 관리
    - 파일 생성 및 제거
    - 파일 & 디렉토리 관리

https://g0pher.tistory.com/343

22.12.25
## Q. 인접행렬과 인접리스트의 장단점에 대해 설명해주세요.(자료구조)  

A.  
**인접행렬**  
- Vertex * Vertex 크기의 행렬을 만들어서, 어느 두 개의 Vertex가 Edge로 연결되어 있다면 1을, 그렇지 않다면 0을 넣어 그래프를 표현하는 방식
- 장점: 구현이 간편하고, Vertex끼리 연결되어 있는지 확인하고 싶으면 graph[i][j]만 확인하면 되기 때문에 탐색(접근)이 빠르다
- 단점: 메모리가 많이 들고(N<sup>2</sup>), 노드에 비해 간선이 너무 적으면 비효율적이다

**인접리스트**  
- 각 노드(Vertex)에 대한 간선(Edge) 연결 정보를, Vertex 순서대로 자신이 연결된 Vertex 번호를 원소로 갖는 리스트로 표현하고, 이를 다시 리스트에 담아 그래프를 표현하는 방식
- 장점: 특정 노드에 연결된 노드(Vertex)를 찾기가 쉽고, 간선의 개수만큼만 메모리가 생성되기 때문에 메모리 측면에서 효율적이다
- 단점: 정점(Vertex) 간의 연결 관계를 알고 싶을 때 탐색이 느리고, 간선이 많으면 비효율적이다

https://dailymapins.tistory.com/29

22.12.26  
## Q. 비트마스크로 집합을 구현할 때, 원소의 포함 여부 확인 방식을 비트마스크 연산자와 연관지어 설명해주세요.(알고리즘)  

A.  
if(A & (1 << k))로 원소의 포함 여부를 확인할 수 있다. 여기서 A는 집합, k는 포함 여부를 확인하고 싶은 원소의 순서이다.  
1 << k는 1을 k만큼 shift 연산하는 것으로, n번째 원소의 비트를 나타낸다.  
&은 양쪽 모두 1이면 1, 둘 중 하나라도 0이면 0을 표시하는 연산이다.  
따라서 if(A & (1 << k))를 사용하여, A집합에 k번째 원소가 포함되어있다면 1(True)이, 포함되어있지 않다면 0(False)이 표시될 것이다.

https://rebro.kr/63

22.12.27  
## Q. 머신러닝과 데이터마이닝의 차이에 대해 설명해주세요.(머신러닝)  

A.  
**데이터마이닝(Data Mining)**  
- 다양한 관점에서 데이터를 분석해 의미를 도출(데이터의 특징을 알아내는 것이 중점)  
- 보유한 데이터를 다양한 관점에서 분석하고, 그 결과를 유용한 정보로 조합하는 일
- 방대한 데이터 속에 숨어있던 패턴과 상관성을 통계적 수법들로 식별하여 가치를 부여
- 숫자가 아닌 데이터도 처리한다는 점에서 통계처리와 구분
- 기법에는 일번적으로 연관(association), 회귀(regression) 및 분류(classification)라는 세 가지 유형이 있음

**머신러닝(Machine Learning)**  
- 데이터마이닝이나 기타 학습 알고리즘을 사용하여 지식을 추출하고 이를 경험기반으로 삼아 비슷한 상황의 미래 사건의 결과를 예측(현재 데이터를 가지고 학습한 뒤, 미래를 예측하는 것에 중점)  
- 인공지능의 한 분야
- 데이터의 패턴을 발견하는 핵심 알고리즘이 동일하지만, 머신러닝은 자체 학습 알고리즘을 사용하며 시간이 경과함에 따라 경험을 축적하면서 작업 성능이 향상됨
- 데이터를 모델링하는 알고리즘은 여러가지가 있지만, 크게 지도학습(Supervised Learning), 비지도학습(Unsupervised Learning), 강화학습(Reinforcemenet Learning)으로 분류됨

https://dalsacoo-log.tistory.com/entry/difference-in-terms-of-ai

22.12.28
## Q. Inner JOIN, Outer JOIN의 차이점에 대해서 설명해주세요.(데이터베이스)  

A.  
**Inner JOIN**(내부 조인)  
- 키 값이 있는 테이블의 컬럼 값을 비교 후 조건에 맞는 값을 가져오는 것. 간단히 말하면 서로 연관된 내용만 검색하는 조인 방법

**Outer JOIN**(외부 조인)  
- 조인하는 여러 테이블에서 한 쪽에는 데이터가 있고 한 쪽에는 데이터가 없는 경우, 데이터가 있는 쪽 테이블의 내용을 전부 출력하는 방법. 즉, 조인 조건에 만족하지 않아도 해당 행을 출력하고 싶을 때 사용할 수 있음  

https://clairdelunes.tistory.com/22

22.12.29
## Q. 전송계층의 프로토콜인 TCP와 UDP의 특징을 설명해주세요.(네트워크)  

A.  
**TCP**(Transmission Control Protocol)  
- 전송을 제어하는 프로토콜(규약)
- 인터넷상에서 데이터를 메시지 형태로 보내기 위해 IP와 함께 사용하는 프로토콜
- IP가 데이터의 배달을 처리한다면 TCP는 패킷을 추적 및 관리
- 연결 지향 방식
- 3-way handshaking 과정을 통해 연결을 설정하고 4-way handshaking을 통해 해제
- 흐름 제어 및 혼잡 제어
- 높은 신뢰성을 보장
- UDP보다 속도가 느림
- 전이중(Full-Duplex), 점대점(Point to Point) 방식

**UDP**(User Datagram Protocol)  
- 사용자 데이터그램 프로토콜(규약)
- 데이터를 데이터그램 단위로 처리하는 프로토콜
- TCP는 연결형 프로토콜이지만 UDP는 비연결형 프로토콜
- 연결을 위해 할당되는 논리적인 경로가 없기 때문에 각각의 패킷은 다른 경로로 전송되고, 이때 각각의 패킷과 데이터를 서로 다른 경로로 독립적으로 처리하는 프로토콜
- 비연결형 서비스로 데이터그램 방식을 제공
- 정보를 주고 받을 때 정보를 보내거나 받는다는 신호절차를 거치지 않음
- UDP헤더의 CheckSum 필드를 통해 최소한의 오류만 검출함
- 신뢰성이 낮음
- TCP보다 속도가 빠름

https://mangkyu.tistory.com/15

22.12.30  
## Q. 컴파일러와 인터프리터의 차이가 무엇인가요?(운영체제)  

A.  
**컴파일러**  
- 전체 소스코드를 보고 명령어를 수집하고 재구성함
- 컴파일링을 하는 동안 걸리는 시간은 다소 길지만 컴파일이 완료되면 실행속도는 빠름
- 고레벨 언어를 바로 기계어로 변환함
- 젠처 소스코드 변환 후 에러를 보고함

**인터프리터**  
- 소스코드의 각 행을 연속적으로 분석하며 실행함
- 인터프리팅 속도는 빠르지만 실행속도는 느림
- 고레벨 언어를 중간 코드로 변환하고 이를 각 행마다 실행함
- 각 행마다 실행하는 도중 에러가 보고되면 이후 작성된 코드를 보지 않아 보안 관점에서 도움이 됨

**장단점**  
|                 |                          컴파일러                         |                       인터프리터                       |
|:---------------:|:---------------------------------------------------------:|:------------------------------------------------------:|
|   개발 편의성   |    코드를 수정하고 실행하려면 컴파일을 다시 해야 한다.    |          코드를 수정하고 즉시 실행할 수 있다.          |
|    실행 속도    |                          빠르다.                          |                         느리다.                        |
|       보안      |             프로그램의 코드가 유출되지 않는다.            |            프로그램의 코드가 유출될 수 있다.           |
|    파일 용량    | 프로그램의 실행 파일 전체를 전송해야 하므로, 용량이 크다. | 프로그램의 코드만 전송하면 실행이 되므로, 용량이 작다. |
| 프로그래밍 언어 |           C, C++처럼 비교적 저수준에 가까운 언어          |      Python, Ruby처럼 비교적 고수준에 가까운 언어      |

https://velog.io/@jaeyunn_15/OS-Compiler-vs-Interpreter

22.12.31
## Q. 컨테이너 어댑터의 종류와 각각의 특징에 대해 설명해주세요.(자료구조)  

A.  
**스택**(stack)  
- vector 클래스의 인터페이스를 제한하여, 전형적인 스택 메모리 구조의 인터페이스를 제공함
- stack 헤더 파일에 정의되어 있음
- empty(), size(), top(), push(), pop() 등의 멤버 함수를 제공함
- 요소에 대한 임의 접근을 허용하지 않을 뿐만 아니라, 스택을 순회하는 반복자도 허용하지 않음

**큐**(queue)  
- deque 클래스의 인터페이스를 제한하여, 전형적인 큐 메모리 구조의 인터페이스를 제공함
- queue 헤더 파일에 정의되어 있음
- empty(), size(), front(), back(), push(), pop() 등의 멤버 함수를 제공함

**우선순위 큐**(priority_queue)  
- 큐의 맨 앞의 요소로 가장 먼저 저장된 요소가 아닌, 가장 큰 값을 지닌 요소가 위치하게 됨
- 큐가 deque 클래스를 기반으로 하는 것과는 달리, vector 클래스를 기반으로 함
- queue 헤더 파일에 정의되어 있음
- 큐 컨테이너와 같은 멤버 함수를 제공함

http://www.tcpschool.com/cpp/cpp_container_adapter

23.01.01
## Q. 비트마스크로 집합을 구현할 때에, 최소 원소를 찾는 방식을 비트마스크 연산자와 연관지어 설명해주세요.(알고리즘)  

A.  
**구현**
- A & (-A)  

**비트마스크 연산자**
- AND 연산(&)과 NOT 연산(~)을 통해 집합의 최소 원소를 찾을 수 있다  
- AND 연산은 비교하는 두 변수의 각 비트 자리가 둘 다 켜져 있는 경우(1인 경우) 해당 비트에 1을, 둘 중 하나라도 꺼져있는 경우 해당 비트에 0을 반환하는 연산이다
- NOT 연산은 정수 하나를 입력받아 켜져 있는 비트는 끄고 꺼져 있는 비트는 켠 결과를 반환하는 연산이다

**설명**  
- 집합 A에 포함된 가장 작은 원소(index가 가장 작은 원소), 즉 켜져있는 bit 중에서 가장 오른쪽에 있는 bit를 찾는 방법이다
- 컴퓨터는 2의 보수를 이용하여 음수를 표현하기 때문에 -A는 (~A + 1)을 이용한다
- A에서 가장 오른쪽에 켜진 bit의 인덱스를 k라고 한다면, k보다 오른쪽에 있는 모든 bit는 0이다
- 따라서 NOT 연산을 적용한 ~A의 k번째 bit는 0이고, k보다 오른쪽의 모든 bit는 1이다
- 여기에 1을 더하면 k는 1이 되고, k보다 오른쪽의 모든 bit는 0이 되고, k보다 왼쪽의 bit는 A에서 1이라면 0, A에서 0이라면 1이 된다
- 따라서 A와 (-A)를 AND 연산하게 되면 가장 k번째 bit만 켜진 상태가 되므로 최소 원소를 찾을 수 있다

https://rebro.kr/63

23.01.02  
## Q. 차원의 저주와 이를 해결하는 방법에 대해 설명해주세요.(머신러닝)  

A.  
**차원의 저주**  
- 차원이 증가하면서 학습데이터 수가 차원 숩다 적어져서 성능이 저하되는 현상
- 차원이 증가할수록 변수가 증가하고, 개별 차원 내에서 학습할 데이터 수가 적어짐
- 변수가 증가한다고 반드시 차원의 저주가 발생하는 것은 아니며, 관측치보다 변수 수가 많아지는 경우에 차원의 저주 문제가 발생함

**해결 방법**  
- 이론적으로는 훈련 샘플의 밀도가 충분히 높아질 때까지 데이터를 모아서 훈련 세트의 크기를 키우는 방법이 있음
- 그러나 일정 밀도에 도달하기 위해 필요한 훈련 샘플 수는 차원의 수가 커짐에 따라 기하급수적으로 늘어남
- 따라서 현실적으로는 PCA와 같은 차원축소 기법을 이용해서 해결함
- 특성 수를 크게 줄여 차원축소를 하면 훈련 속도가 빨라지고 시각화하기에도 좋음
- 다만 일부 정보가 유실되기 때문에 성능도 조금 나빠질 수 있으므로, 무작정 차원축소를 하기보다는 원본 데이터로 훈련해서 시간이 오래 걸리는지 확인하고 차원축소 여부를 결정할 필요가 있음

https://for-my-wealthy-life.tistory.com/40

23.01.03  
## Q. 트랜잭션의 각 격리 수준에 대해서 설명하고, 각 수준에서 일어날 수 있는 문제에 대해 설명해주세요.(데이터베이스)  

A.  
**트랜잭션 격리 수준(isolation level)**  
- 동시에 여러 트랜잭션이 처리될 때, 트랜잭션끼리 얼마나 서로 고립되어 있는지를 나타내는 것
- 특정 트랜잭션이 다른 트랜잭션에서 변경한 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것
- 크게 READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE의 4개로 나뉘고, 순서대로 트랜잭션 간 고립 정도가 높아지며 성능이 떨어지는 것이 일반적

**READ UNCOMMITTED**  
- 어떤 트랜잭션의 변경내용이 COMMIT이나 ROLLBACK과 상관없이 다른 트랜잭션에서 보임
- COMMIT 하지 않은 변경 내용이 다른 트랜잭션에서 조회되는(더티 리드, Dirty Read) 데이터 정합성 문제가 생길 수 있음

**READ COMMITTED**  
- 어떤 트랜잭션의 변경 내용이 COMMIT 되어야만 다른 트랜잭션에서 조회할 수 있음  
- 다른 트랜잭션에서, COMMIT 하기 전에 조회된 내용과 COMMIT 한 후의 조회된 내용이 달라지므로, 하나의 트랜잭션에서 똑같은 SELECT를 수행했을 경우 항상 같은 결과를 반환해야 한다는 REPEATABLE READ 정합성에 어긋나는 문제(REPEATABLE READ 부정합 문제)가 생길 수 있음

**REPEATABLE READ**  
- 트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회할 수 있음
- 자신의 트랜잭션보다 낮은 트랜잭션 번호에서 변경되고 COMMIT된 내용만 보임
- 한 트랜잭션이 실행되던 중 다음 트랜잭션에서 UPDATE를 하게 되면, 기존 트랜잭션에서 그 이후 실행하는 UPDATE가 실행되지 않는 UPDATE 부정합 문제가 생길 수 있음
- 한 트랜잭션 내에서 같은 쿼리를 두 번 실행했는데, 첫 번째 쿼리에서 없던 유령(Phantom) 레코드가 두 번째 쿼리에서 나타나는 Phantom READ 문제가 생길 수 있음

**SERIALIZABLE**  
- 가장 단순하고 가장 엄격한 격리수준
- 읽기 작업에도 공유 잠금을 설정하여, 동시에 다른 트랜잭션에서 이 레코드를 변경하지 못하게 됨
- 동시처리 능력이 다른 격리수준보다 떨어지고, 성능저하가 발생하는 문제가 생길 수 있음

https://joont92.github.io/db/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B2%A9%EB%A6%AC-%EC%88%98%EC%A4%80-isolation-level/

23.01.04  
## Q. TCP의 대표적인 3가지 제어에 대해 설명해주세요.(네트워크)  

A.  
**TCP의 제어 기능**
- 흐름 제어: 전송되는 데이터의 양을 조절
- 오류 제어: 데이터가 유실되거나 잘못된 데이터가 수신되었을 경우 대처
- 혼잡 제어: 네트워크 혼잡에 대처

**흐름 제어**
- 송신 측과 수신 측의 데이터 처리 속도는 서로 다를 수 있음
- 송신 측의 속도가 빠를 때 수신 측 버퍼가 넘치는 오버플로우 문제가 발생함
- 이러한 문제를 줄이기 위해 윈도우 크기로 송신 측의 데이터 전송량을 조절함
- 상대방에게 데이터를 보낸 후 잘 받았다는 응답이 올 때까지 기다리는 stop and wait 방식과, 송신 측이 수신 측에서 받은 윈도우 크기를 참고해서 데이터의 흐름을 제어하는 sliding window 방식이 있음

**오류 제어**
- TCP는 통신 중에 오류가 발생하면 해당 데이터를 재전송하는 재전송 기반 오류 제어(ARQ, Automatic Repeat reQuest)를 사용함
- 재전송은 비효율적이므로 적을수록 좋기에, 오류를 알 수 있는 효율적인 방법이 필요함
- ACK(긍정 응답)을 받고 나서 다음 데이터를 보내는 Stop and Wait 방식, 연속으로 데이터를 보내다가 오류가 발생한 지점부터 재전송하는 Go Back N 방식, 오류가 발생한 데이터만 재전송하는 Selective Repeat 방식 등이 있음

**혼잡 제어**
- 네트워크 내에 패킷의 수가 과도하게 증거하는 현상을 혼잡이라고 함
- 혼잡 제어는 혼잡 현상을 방지하고 제거하기 위한 기능임
- AIMD(Additive Increase / Multiplicative Decrease)
    - 처음에 패킷을 하나씩 보내고 문제가 발생하지 않으면 윈도우 크기를 1씩 증가시킴
    - 패킷 전송에 실패하거나 일정 시간을 넘으면 패킷 전송 속도를 절반으로 줄임
- Slow Start(느린 시작)
    - AIMD와 같이 패킷을 하나씩 보내고 문제가 발생하지 않으면 각 ACK 패킷마다 윈도우 크기를 1씩 늘려줌, 즉 한 주기가 지나면 윈도우 크기는 2배가 됨
    - AIMD와 달리 전송 속도를 지수 함수 꼴로 증가시켜서 윈도우 크기를 더 빠르게 증가시킴
    - 혼잡이 감지되면 윈도우 크기를 1로 줄임
- Fast Retransmit(빠른 재전송)
    - TCP는 지금까지 받은 데이터 중 연속되는 패킷의 마지막 순번 이후를 ACK 패킷에 실어서 보냄
    - timeout이 발생하기 전이라도 문제 되는 패킷을 재전송할 수 있으며, 혼잡한 상황이라고 판단되면 윈도우 크기를 줄임
- Fast Recovery(빠른 회복)
    - 혼잡한 상태가 되면 윈도우 크기를 1이 아니라 반으로 줄이고, 선형 증가시킴
    - 혼잡 상황을 한 번 겪은 이후로는 AIMD 방식으로 동작함

https://benlee73.tistory.com/186

23.01.05
## Q. context switching에 대해 설명해주세요.(운영체제)  

A.  
**Context Switching**
- CPU가 한 개의 Task(Process/Thread)를 실행하고 있는 상태에서 Interrupt 요청에 의해 다른 Task로 실행이 전환되는 과정에서 기존의 Task 상태 및 Register 값들에 대한 정보(Context)를 저장하고 새로운 Task의 Context 정보로 교체하는 작업
- Context란, CPU가 다루는 Task(Process/Thread)에 대한 정보로 대부분의 정보는 Register에 저장되며 PCB(Process Control Block)으로 관리됨
- Process와 Thread를 처리하는 Context Switching은 조금 다른데, PCB는 OS에 의해 스케줄링되는 Process Control Box이고, Thread의 경우 Process 내의 TCB(Task Control Box)라는 내부 구조를 통해 관리됨
- Context Switching 진행 시 CPU는 Cache를 초기화하고 Memory Mapping을 초기화하는 작업을 거치는 등 아무 Task도 수행하지 못하므로 잦은 Context Switching은 성능 저하를 가져옴

https://jins-dev.tistory.com/entry/%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%8A%A4%EC%9C%84%EC%B9%98Context-Switching-%EC%97%90-%EB%8C%80%ED%95%9C-%EC%A0%95%EB%A6%AC

23.01.07  
## Q. BFS(Breadth-First Search)와 DFS(Depth-First Search)에 대해 설명해주세요.(자료구조)  

**그래프의 탐색**  
- 그래프: 정점(node)과 그 정점을 연결하는 간선(edge)으로 이루어진 자료구조  
- 그래프 탐색: 하나의 정점으로부터 시작하여 차례대로 모든 정점들을 한 번씩 방문하는 것  

**BFS(Breadth-First Search, 너비 우선 탐색)**  
- 최대한 넓게 이동한 다음, 더이상 옆으로 갈 수 없을 때 아래로 이동  
- 루트 노드(혹은 다른 임의의 노드)에서 시작해서 인접한 노드를 먼저 탐색하는 방법
- 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져있는 정점을 나중에 방문하는 순회 방법
- 주로 두 노드 사이의 최단 경로를 찾고 싶을 때 이 방법을 선택함

**DFS(Depth-First Search, 깊이 우선 탐색)**  
- 최대한 깊이 내려간 뒤, 더이상 깊이 갈 수 없을 때 옆으로 이동
- 루트 노드(혹은 다른 임의의 노드)에서 시작해서 다음 분기(brach)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방식
- 모든 노드를 방문하고자 하는 경우에 이 방법을 선택함
 
**BFS와 DFS 비교**  
|            BFS(너비우선탐색)            |                 DFS(깊이우선탐색)                 |
|:---------------------------------------:|:-------------------------------------------------:|
| 현재 정점에 연결된 가까운 점들부터 탐색 | 현재 정점에서 갈 수 있는 점들까지 들어가면서 탐색 |
|            큐를 이용해서 구현           |             스택 또는 재귀함수로 구현             |

https://devuna.tistory.com/32

23.01.08
## Q. 비트마스크의 개념과 장점에 대해 설명해주세요.(알고리즘)  

A. **비트마스크(BitMask)**  
- 이진수를 사용하는 컴퓨터의 연산 방식을 이용하여, 정수의 이진수 표현을 자료 구조로 쓰는 기법
- 이진수는 0 또는 1을 이용하므로 하나의 비트(bit)가 표현할 수 있는 경우는 두 가지임
- 1을 "켜져 있다", 0을 "꺼져 있다"고 함

**비트마스크의 장점**  
- 연산의 수행 시간이 $O(1)$로 매우 빠름
- 다양한 집합 연산들을 반복문, 조건문에 비해 훨씬 짧고 간결하게 코드를 작성할 수 있음
- 매우 많은 경우의수를 비트로 표현할 수 있기 때문에 메모리 사용량이 훨씬 적고 효율적임

https://rebro.kr/63

23.01.09
## Q. 1종 오류와 2종 오류에 대해 예시를 들어 설명해주세요.(머신러닝)

A.  
**사건과 귀무가설**  
통계학에서는 아무일도 일어나지 않았음을 가정하는 귀무가설(Null Hypothesis)을 세운 뒤, 귀무가설을 채택하거나 기각함으로써 어떤 사건(Alternative Hypothesis)이 일어났는지를 검정함

**1종 오류(type I error)**  
- 귀무가설이 참인데 잘못 판단해 기각해버리는 오류
- 예) 아파트에 불이 나지 않았는데(아무일도 일어나지 않았다는 귀무가설이 참), 화재 경보가 울림(귀무가설을 기각함)

**2종 오류(type II error)**  
- 귀무가설이 거짓인데 잘못 판단해 기각하지 않는 오류
- 예) 아파트에 불이 났는데(아무일도 일어나지 않았다는 귀무가설이 거짓), 화재 경보가 울리지 않음(귀무가설을 기각하지 않음)

https://angeloyeo.github.io/2021/01/26/types_of_errors.html#disqus_thread

23.01.10
## Q. 데이터베이스의 반정규화의 정의와 그 종류에 대해서 간략하게 설명해주세요.(데이터베이스)

A.  
**반정규화(De-Normalization)**  
- 데이터베이스의 성능 향상을 위하여, 데이터 중복을 허용하고 조인을 줄이는 방법
- 조희(SELECT) 속도를 향상시키지만, 데이터 모델의 유언성은 낮아짐
 
**반정규화의 종류**  
- 테이블 통합: 두 개의 테이블이 조인되어 있는 경우 하나의 테이블로 합쳐 사용하는 방법
- 테이블 분할: 테이블을 수직 또는 수평으로 분할하는 방법
- 중복 테이블 추가: 여러 테이블에서 데이터를 추출해서 사용해야 하거나 다른 서버에 저장된 테이블을 이용해야 하는 경우 테이블을 추가하는 방법
- 중복 속성 추가: 조인해서 데이터를 처리할 때 데이터를 조회하는 경로를 단축하기 위해 자주 사용하는 속성을 추가하는 방법

https://velog.io/@yewon-july/De-Normalization  
https://lipcoder.tistory.com/337

23.01.11
## Q. DNS와 DHCP를 설명해주세요.(네트워크)  

A.  
**DNS(Domain Name System)**  
- 도메인 이름을 IP 주소로 매핑하는 시스템
- 인터넷상의 호스트 이름과 고유한 숫자 주소(논리적 주소)를 매핑하는 디렉토리 검색 서비스를 제공하는 매커니즘

**DHCP(Dynamic Host Configuration Protocol)**  
- 정적 또는 동적으로 네트워크의 호스트에 IP를 할당하는 프로토콜
- 호스트별 구성 매개 변수를 DHCP 서버에서 호스트로 전송하는 역할의 프로토콜과, 호스트 간에 네트워크 주소를 할당하는 역할의 매커니즘으로 구성되어 있음

**DNS와 DHCP의 차이점**  
- DNS는 호스트의 이름 또는 이름으로 주소를 확인하고 재귀적으로 확인하는 데 사용되는 반면 DHCP는 네트워크의 호스트에 동적 또는 정적으로 주소를 할당하는 데 사용됨
- DHCP는 포트 번호 53을 사용하는 반면 DHCP는 67 또는 68을 사용할 수 있음
- DNS 서버는 클라이언트를 통해 쿼르를 수락하고 결과와 함께 클라이언트에 응답하는 반면 DHCP 서버는 임대 시간 동안 클라이언트 시스템에 임시 주소를 할당한 다음 요구 사항에 따라 임대를 연장함
- DNS는 모든 도메인 이름을 한 곳에서 저장하지 않고 하위 도메인으로 분할한 다음 특정 정보를 특정 서버에 저장하는 특정 계층 구조를 따르므로 분권화되어있는 반면 DHCP 서버는 IP 주소 풀에서 클라이언트의 IP 주소를 구성하고 모든 작업을 중앙에서 처리하므로 DHCP 서버가 클라이언트에 직접 연결되어있지 않으면 라우터를 사용하여 DHCP 브로드 캐스트를 수신하고 릴레이함

https://ko.gadget-info.com/difference-between-dns

23.01.12  
## Q. 동기(Synchronous)와 비동기(Asynchronous), 블로킹(Blocking)과 논-블로킹(Non-blocking)에 대해 설명해주세요.(운영체제)

A.  
- I/O 작업은 user space에서 직접 수행할 수 없기 때문에 user process가 kernel에 I/O 작업을 '요청'하고 '응답'을 받는 구조
- 응답을 어떤 순서로 받는지(synchronous/asynchronous), 어떤 타이밍에 받는지(blocking/non-blocking)에 따라 여러 모델로 분류됨

**동기 작업(Synchronous)**  
- 작업이 한 번에 하나씩 수행되며 진행 중인 작업이 끝나기 전까지는 해당 작업 외의 다른 작업을 수행하지 못함
- 모든 I/O 요청-응답 작업이 일련의 순서를 따르므로 작업의 순서가 보장됨
- 작업 완료를 user space에서 판단하고 다음 작업을 언제 요청할지 결정함
- 일련의 Pipeline을 준수하는 구조에서 효율적임

**비동기 작업(Asynchronous)**  
- 한 번에 하나 이상의 작업이 수행될 수 있으므로 현재 작업을 진행 중이더라도 다른 작업을 수행할 수 있음
- 작업에 대한 결과를 바로 원하지 않음
- kernel에 I/O 작업을 요청해두고 다른 작업 처리가 가능하나, 작업의 순서는 보장되지 않음
- 작업 완료를 kernel space에서 통보해줌
- 각 작업들이 독립적이거나, 작업 별 지연이 큰 경우 효율적임

**블로킹(Blocking)**  
- 동기 작업 중에 I/O를 받아 오기 전까지 프로그램을 멈추어 비동기 수행을 할 수 있게 하는 것
- Blocking 시간에 다른 작업을 할 수 있게 됨
- Thread가 Blocking 된다는 것은 CPU가 점유되어 실행되지 못함을 의미함

**논-블로킹(Non-Blocking)**  
- Wait 하지 않고 작업이 그냥 수행됨
- 자신이 호출되었을 때 즉 System call을 받았을 때 제어권을 바로 자신을 호출한 쪽으로 넘겨 다른 작업을 할 수 있도록 하는 것을 의미
- Thread가 Waiting하지 않으므로 CPU 제어는 그대로임

https://luv-n-interest.tistory.com/1121

23.01.13
## Q. Array의 특징과 장단점을 시간복잡도와 연관지어 설명해주세요.(자료구조)

A.  
**Array(배열)**
- 데이터 간 순서 관계를 나타내는 선형 자료구조  
- 연속된 메모리 공간에 순차적으로 저장된 데이터 모음
- 배열을 구성하는 각각의 값을 요소(element), 배열에서 위치를 가리키는 숫자를 인덱스(index)라고 함

**특징**  
- 배열의 각 요소에 접근하는 시간은 $O(1)$으로 속도가 빠름
  - 기본위치(배열이 시작하는 지점) + 오프셋(요소크기 * 인덱스) 연산으로 모든 요소에 빠른 접근 가능
- 연속된 메모리에 단일 블록화하여 데이터를 저장함
  - 낭비되는 공간이 거의 없는 장점이 있지만 큰 배열의 경우 필요 메모리 할당이 불가능할 수 있음

**장점**  
- 모든 요소에 빠른 접근이 가능함( $O(1)$ )
- 기록 밀도가 1이므로 공간 낭비가 적음

**단점**  
- element를 삽입 및 삭제하는 경우 그 뒤의 모든 요소를 이동해야 하므로 시간이 오래 걸림( $O(n)$ )
- 특정 요소를 탐색하기 위해서도 시간이 오래 걸림( $O(n)$ )

https://yoongrammer.tistory.com/43

23.01.14
## Q. 최소 공통 조상 알고리즘의 동작 방식에 대해 설명해주세요.(알고리즘)

A.  
**최소 공통 조상 알고리즘(LCA, Lowest Common Ancestor)**  
두 노드의 공통된 조상 중에서 가장 가까운 조상을 찾는 알고리즘
1. 모든 노드에 대한 깊이를 계산함
2. 최소 공통 조상을 찾을 두 노드를 확인함
3. 먼저 두 노드의 깊이가 동일하도록 거슬러 올라감
4. 부모가 같아질 때까지 반복적으로 두 노드의 부모 방향으로 거슬러 올라감
5. 모든 LCA(a, b) 연산에 대해 3~4번의 과정을 반복함

https://velog.io/@shiningcastle/%EC%B5%9C%EC%86%8C-%EA%B3%B5%ED%86%B5-%EC%A1%B0%EC%83%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98

23.01.15
## Q. 서포트 벡터 머신(SVM)에 대해 설명해주세요.(머신러닝)

A.  
**서포트 벡터 머신(SVM, Support Vector Machine)**  
- 주어진 데이터가 어느 카테고리에 속할지 판단하는 이진 선형 분류 모델
- 선과 가장 가까운 포인트인 서포트 벡터(Support Vector)와 구분선의 거리를 의미하는 Margin을 최대화하게끔 구분선을 결정함
- 동시에 아웃라이어(outlier)의 영향을 받지 않는 robustness도 최대화함

https://bkshin.tistory.com/entry/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D-2%EC%84%9C%ED%8F%AC%ED%8A%B8-%EB%B2%A1%ED%84%B0-%EB%A8%B8%EC%8B%A0-SVM

23.01.16  
## Q. 대표적인 SQL종류 3가지에 대해서 설명하고, 종류별 명령어를 아는 만큼 나열해주세요.(데이터베이스)

A.  
DML(Data Manipulation Language)  
- 테이블의 데이터를 조작하는 명령어
- INSERT: 데이터베이스 객체에 데이터를 삽입
- DELETE: 데이터베이스 객체에서 데이터를 삭제
- UPDATE: 데이터베이스 객체 안의 데이터를 수정
- SELECT: 데이터베이스 객체 안의 데이터를 조회

DDL(Data Definition Language)
- 데이터베이스, 테이블의 스키마를 정의, 수정, 삭제하는 명령어
- CREATE: 데이터베이스 객체를 생성
- DROP: 데이터베이스 객체를 삭제
- ALTER: 기존에 존재하는 데이터베이스 객체를 다시 정의

DCL(Data Control Language)
- 데이터베이스, 테이블의 접근권한이나 CRUD 권한을 정의하는 명령어
- GRANT: 데이터베이스 객체에 권한을 부여
- REVOKE: 이미 부여된 데이터베이스 객체 권한을 취소

https://leejinseop.tistory.com/6


23.01.17
## Q. 브라우저에 접속하여 주소창에 특정 URL을 입력하면 어떤 일이 일어날까요?(네트워크)  

A.  
1. 브라우저에서는, 입력된 URL 값의 의미를 조사하여 의미에 따라 HTTP Request 메시지를 만들어 웹 서버로 전송한다.
2. 프로토콜 스택에서는 브라우저로부터 메시지를 받아 패킷 속에 저장 후 수신처 주소 등의 제어정보를 덧붙여 패킷을 LAN 어댑터에 넘긴다.
3. LAN 어댑터는 다음 Hop의 MAC주소를 붙인 프레임을 전기신호로 변환하여 LAN 케이블에 송출한다.
4. 프레임 신호가 스위칭 허브, 인터넷 접속용 라우터, 프로바이더(통신사) 등을 경유하여 인터넷으로 들어가게 된다.
5. 패킷은 액세스 회선에 의해 통신사용 라우터까지 운반되어 인터넷의 핵심부로 들어가고, 고속 라우터들 사이로 패킷이 목적지를 향해 흘러간다.
6. 패킷이 웹 서버측의 LAN에 도착하면, 방화벽이 검사를 하고, 캐시서버가 패킷이 웹 서버까지 가야 하는지 판단한다.
7. 패킷이 물리적인 웹 서버에 도착하면 프로토콜 스택이 패킷을 추출하여 메시지를 복원하고 애플리케이션에 넘기고, 요청 메시지에 따른 데이터를 응답 메시지에 넣어 클라이언트로 회송한다.
8. 왔던 방식대로 응답 메시지가 클라이언트에게 전달된다.

https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Network#%EC%9B%B9-%ED%86%B5%EC%8B%A0%EC%9D%98-%ED%81%B0-%ED%9D%90%EB%A6%84

23.01.18
## Q. 커널(kernel)의 종류에 대해 설명해주세요.(운영체제)  

A.  
**단일형 커널(Monolithic Kernel)**  
- 커널의 다양한 서비스 및 높은 수준의 하드웨어 추상화를 하나의 덩어리로 묶어 놓은 구조

**마이크로 커널(Micro Kernel)**  
- 하드웨어 추상화에 대한 간결한 작은 집합을 제공하고 더 많은 기능은 서버라고 불리는 응용 소프트웨어를 통해 제공됨

**혼합형 커널(Hybrid Kernel)**  
- 본질적으로는 마이크로 커널을 따르고 있으나, 비 본질적인 기능이더라도 사용자 레벨에서 수행될 때 성능상 느린 코드들을 커널 레벨에서 수행하도록 수정한 것

**엑소 커널(Exo Kernel)**  
- 낮은 수준의 하드웨어 접근을 위한 최소한의 추상화를 제공함

https://ljhblog.tistory.com/37

23.01.19
## Q. List, Set, Map의 차이점에 대해 설명해주세요.(자료구조)  

A.  
**List**  
- 데이터를 순서대로 저장하는 선형자료구조  
- 순서가 있고, 중복을 허용
- 길이가 가변적
- 원하는 데이터가 뒤쪽에 있을 때 탐색에 시간이 오래 걸림
- 즉, 시간복잡도가 $O(n)$임

**Set**  
- 순서가 없고 중복을 허용하지 않는, 말 그대로 집합
- 탐색 속도가 빠름, 시간복잡도 $O(1)$

**Map**  
- 키와 데이터를 같이 저장(key-value 쌍)  
- key와 value로 나눠서 데이터를 관리하며, 순서가 없고 키에 대해서 중복이 없음  
- 탐색 속도가 key의 탐색 속도에 의해 결정됨  

https://milkoon1.tistory.com/44

23.01.20
## Q. 최장 증가 수열 알고리즘의 동작 방식에 대해 설명해주세요.(알고리즘)  

A.  
**최장 증가 부분 수열(LIS, Longest Increasing Subsequence) 알고리즘**  
- 원소가 n개인 배열의 일부 원소를 골라내서 만든 부분 수열 중, 각 원소가 이전 원소보다 증가하면서 그 길이가 최대인 부분 수열을 최장 증가 부분 수열이라고 함
- 어떤 배열이 주어졌을 때, DP(Dynamic Programming)을 사용하여 최장 증가 부분 수열을 구할 수 있음
- 배열의 맨앞부터 인덱스를 한 칸씩 늘려가면서, 해당 인덱스를 그 전까지의 부분 수열의 마지막 값과 비교하여 부분 수열의 길이를 업데이트하는 방법( $O(n^2)$ )
- 이진 탐색을 사용하여 인덱스의 값이 들어갈 수 있는 부분 수열의 길이를 업데이트하는 방법( $O(nlog(n)$ )

https://seohyun0120.tistory.com/entry/%EA%B0%80%EC%9E%A5-%EA%B8%B4-%EC%A6%9D%EA%B0%80%ED%95%98%EB%8A%94-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4LIS-%EC%99%84%EC%A0%84-%EC%A0%95%EB%B3%B5-%EB%B0%B1%EC%A4%80-%ED%8C%8C%EC%9D%B4%EC%8D%AC

23.01.21
## Q. KNN과 K-means 알고리즘의 차이에 대해 설명해주세요.(머신러닝)  

A.  
**KNN(K-Nearest Neighbor)**  
- 분류 알고리즘(지도학습 - labeled data)
- K개의 최근접 이웃을 참조하여 자신의 클래스를 결정함  
- 보통 K를 홀수로 지정함  

**K-means**  
- 비지도학습 중 하나로, 데이터를 K개의 클러스터로 군집화하는 알고리즘(unlabeled data)
1. K를 정한다(k는 클러스터 개수)
2. K개의 초기 중심을 임의로 설정한다.
3. 각 데이터 포인트 ~ K개의 중심 거리를 계산하여 가장 가까운 중심점이 속한 클러스터로 이동한다.
4. 2, 3 단계를 반복하고 더이상 클러스터에 변화가 없으면 종료한다.

https://m.blog.naver.com/songsrr12/221664837491

23.01.22
## Q. 데이터베이스의 무결성 제약조건의 정의와 필요성에 대해 설명해주세요.(데이터베이스)  

A.  
데이터 무결성  
- 데이터베이스에 저장된 데이터의 일관성과 정확성을 지키는 것

데이터베이스의 무결성 제약조건  
- 데이터의 일관성과 정확성을 위해 지켜야 하는 규칙  

무결성 제약조건의 필요성  
- 스키마를 작성할 때 일관성 조건을 한 번만 명시하면 데이터베이스가 갱신될 때마다 DBMS가 자동으로 일관성 조건을 감시하므로 어플리케이션들은 일관성 조건을 일일히 검사할 필요가 없음
- 데이터를 실생활의 의미에 맞게 사용할 수 있음
- 응용 프로그램에서 직접 조건을 유지하는 경우보다 에러가 발생할 가능성이 더 낮음

무결성 제약조건의 종류  
- 도메인 무결성 제약조건(도메인 제약): 릴레이션 내의 튜플들이 각 속성의 도메인에 지정된 값만을 가져야 한다는 조건. 속성에 들어갈 수 있는 데이터 타입을 지정할 수 있고, 기본값을 지정할 수 있음. 저장되는 값들의 범위를 지정할 수 있으며 NULL 구문을 통해 속성 값으로 NULL을 허용/비허용 할 수 있음  
- 개체 무결성 제약조건(기본키 제약): 릴레이션은 기본키를 지정하고 그에 따른 무결성 원칙을 지켜야 한다는 조건. 기본키는 NULL값을 가져서는 안 되며 릴레이션 내에 오직 하나의 값만 존재해야 함
- 참조 무결성 제약조건(외래키 제약): 테이블 간의 참조 관계를 선언하는 조건. 외래키의 값은 NULL이거나 참조 릴레이션의 기본키 값과 동일해야 함.

https://velog.io/@zooneon/DB-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%AC%B4%EA%B2%B0%EC%84%B1-%EC%A0%9C%EC%95%BD%EC%A1%B0%EA%B1%B4

23.01.23
## Q. cors(Cross-Origin Resource Sharing)란 무엇일까요?(네트워크)  

A.  
브라우저에서는 보안적인 이유로 cross-origin HTTP 요청들을 제한하기에, cross-origin 요청을 하려면 서버의 동의가 필요함. 만약 서버가 동의한다면 브라우저에서는 요청을 허락하고, 동의하지 않는다면 브라우저에서 거절함  
이러한 허락을 구하고 거절하는 메커니즘은 HTTP-header를 이용해서 가능한데, 이를 CORS(Cross-Origin Resource Sharing)이라고 부름  

https://hannut91.github.io/blogs/infra/cors

23.01.24
## Q. 멀티 스레딩(Multi-threading)의 장점과 단점은 무엇인가요?(운영체제)

A.  
**멀티 스레딩(Multi-threading)**  
- 하나의 프로세스를 다수의 실행 단위로 구분하여 자원을 공유하고 자원의 생성과 관리의 중복성을 최소화하여 수행 능력을 향상시키는 것
- 하나의 프로그램에서 동시에 여러 개의 일을 수행할 수 있도록 해줌(사실 분산처리를 통해 동시에 실행되는 것처럼 보이는 것)  

**장점**  
1. 응답성: 프로그램의 일부분(스레드)이 중단되거나 긴 작업을 수행하더라도 프로그램의 수행이 계속되어 사용자에 대한 응답성이 증가한다.
2. 경제성: 프로세스 내 자원들과 메모리를 공유하기 때문에 메모리 공간과 시스템 자원 소모가 줄어든다. 스레드 간 통신이 필요한 경우에도 쉽게 데이터를 주고 받을 수 있으며, 프로세스의 context switching과 달리 스레드 간의 context switching은 캐시 메모리를 비울 필요가 없기 때문에 더 빠르다.
3. 멀티프로세서 활용: 다중 CPU 구조에서는 각각의 스레드가 다른 프로세서에서 병렬로 수행될 수 있으므로 벙렬성이 증가한다.

**단점**  
- 임계영역(Critical Section). 둘 이상의 스레드가 동시에 실행하면 문제를 일으키는 코드 블록. 공유하는 자원에 동시에 접근하는 경우, 프로세스와는 달리 스레드는 데이터와 힙 영역을 공유하기 때문에 어떤 스레드가 다른 스레드에서 사용 중인 변수나 자료구조에 접근하여 엉뚱한 값을 읽어오거나 수정할 수 있다. 따라서 동기화가 필요.
- 동기화를 통해 스레드의 작업 처리 순서와 공유 자원에 대한 접근을 컨트롤할 수 있다. 그러나 불필요한 부분까지 동기화하는 경우, 과도한 lock으로 인해 병목 현상을 발생시켜 성능이 저하될 가능성이 높기 때문에 주의해야 한다. 동기화 방법에는 뮤텍스와 세마포어가 있다.
- context switching, 동기화 등의 이유로 싱글 코어 멀티 스레딩은 스레드 생성 시간이 오히려 오버헤드로 작용해 단일 스레드보다 느리다.

https://eun-jeong.tistory.com/20

23.01.25  
# Q. Stack과 Queue의 차이점에 대해 설명해주세요.(자료구조)

A.  
Stack과 Queue 모두 데이터 간 순서 관계가 중요한 선형 추상 자료형이다.  
Stack은 접시를 쌓아놓을 때와 같이, 먼저 들어간 데이터가 가장 마지막으로 나오는 LIFO(Last In, First Out) 성질이 있다.  
Queue는 버스 줄을 설 때와 같이, 먼저 들어간 데이터가 먼저 나오는 FIFO(First In, First Out) 성질이 있다.  

https://velog.io/@humblechoi/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-Stack-Queue

23.01.26
# Q. 소수 판별 알고리즘인 에라토스테네스의 체에 대해 설명해주세요.(알고리즘)  

A.  
1. 소수를 판별하고 싶은 범위(n)를 설정한다.  
2. 소수도 합성수도 아닌 1을 지우고, 가장 작은 소수인 2부터 시작하여 2를 제외한 2의 배수인 4, 6, 8... 등을 n까지 범위 안에서 모두 지운다.
3. 남아있는 수 중, 2의 다음 숫자인 3이 2의 다음 소수이므로 3 자신을 제외한 3의 배수 9, 15, 21 등을 n까지 범위 안에서 모두 지운다(6, 12, 18 등은 2의 배수를 지울 때 이미 지워졌다).
4. 마찬가지 방법으로, x의 배수를 n의 범위 내에서 모두 지운 다음 남아있는 수 중 x 다음 숫자 자신을 제외한 그 배수를 지우는 과정을 반복한다.
5. n까지 범위 안에서 모두 이루어졌다면, 남아있는 숫자들이 n 이내의 소수가 된다.

https://blog.naver.com/PostView.naver?blogId=ndb796&logNo=221233595886&redirect=Dlog&widgetTypeCall=true&directAccess=false

23.01.27
## Q. 커널 트릭에 대해 설명해주세요.(머신러닝)  

A.  
input space가 있을 때 샘플을 선형 모델로 분류할 수 없는 경우, 비선형 모델을 만드는 대신 선형 모델로 해결할 수 있는 feature space를 만드는 방법(feature map)이 있다.  
그러나 feature map을 찾는 것은 매우 어렵고, 합수로 feature space를 만드는 연산량과 내적 연산량이 너무 많다는 문제점이 있다.  
커널(kernel)은 이러한 문제점을 해결하기 위해 고안된 것으로, 커널이 일정 조건(Mercer's Theorem)을 만족하면 문제를 해결하기 위한 커널 함수가 존재하게 된다.  
이때 이 함수들을 이용한 linear technique를 Kernel Trick(커널 트릭)이라고 한다.

https://sonsnotation.blogspot.com/2020/11/11-1-kernel.html

23.01.28
## Q. 데이터베이스 정규화와 그 종류에 대해서 설명해주세요.(데이터베이스)  

A.  
**데이터베이스 정규화(Normalization)**  
- 정규화: 관계형 데이터베이스의 설계에서 중복을 최소화하게 데이터를 구조화하는 프로세스
- 목표: 관련이 없는 함수 종속성은 별개의 릴레이션으로 표현하는 것
- 장점: 이상 현상의 발생 가능성을 줄임
- 단점: 연산 시간이 증가함

**정규형**
- 정규화된 결과
- 기본 정규형, 고급 정규형으로 나뉨
- 기본 정규형: 제1정규형, 제2정규형, 제3정규형, BCNF(보이스/코드 정규형)
- 고급 정규형: 제4정규형, 제5정규형

**제1정규형**
- 릴레이션에 속한 모든 속성의 도메인이 더이상 분해되지 않는 원자값으로만 구성된 정규형

**제2정규형**
- 릴레이션이 제1정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속되는 정규형

**제3정규형**
- 릴레이션이 제2정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속이 되지 않는 정규형

**BCNF**
- 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키인 정규형

**제4정규형**
- 릴레이션이 BCNF를 만족하면서, 함수 종속이 아닌 다치 종속을 제거한 정규형

**제5정규형**
- 릴레이션이 제4정규형을 만족하면서 후보키를 통하지 않는 조인 종속을 제거한 정규형

https://hongcoding.tistory.com/147

23.01.29
## Q. http의 문제점이 무엇이라고 생각하시나요?(네트워크)  

A.  
- HTTP는 평문 통신이기 때문에 도청이 가능하다.
- 통신 상대를 확인하지 않기 때문에 위장이 가능하다.
- 완전성을 증명할 수 없기 때문에 변조가 가능하다.

https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Network#http%EC%9D%98-get%EA%B3%BC-post-%EB%B9%84%EA%B5%90

23.01.30
## Q. 페이지 교체 알고리즘에 대해 아는대로 설명해주세요.(운영체제)  

A.  
- 가상 메모리는 요구 페이지 기버을 통해 필요한 페이지만 메모리에 적재하고 사용하지 않는 부분은 그대로 둠
- 하지만 필요한 페이지만 올려도 메모리는 결국 가득 차게 되고, 올라와있던 페이지가 사용이 다 된 후에도 자리만 차지하고 있을 수 있음
- 따라서 메모리가 가득 차면, 추가로 페이지를 가져오기 위해서 안 쓰는 페이지는 out하고, 해당 공간에 현재 필요한 페이지를 in 시켜야 함
- 여기서 어떤 페이지를 out 시켜야 할지 정해야 함(이때 out 되는 페이지를 victim page라고 부름).
- 기왕이면 수정이 되지 않는 페이지를 선택해야 좋음(만약 수정되면 메인 메모리에서 내보낼 때, 하드디스크에서 또 수정을 진행해야 하므로 시간이 오래 걸림)
- FIFO 알고리즘: 메모리에 가장 먼저 올라온 페이지를 out시키는 방법
- OPT 알고리즘: 앞으로 가장 사용하지 않을 페이지를 out시키는 방법
- LRU 알고리즘: 최근에 사용하지 않은 페이지를 out시키는 방법
- 교체 방식: 메모리 상의 모든 프로세스 페이지에 대해 교체하는 Global 방식, 메모리 상의 프로세스 페이지에서만 교체하는 Local 방식

https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/Page%20Replacement%20Algorithm.md

23.01.31
## Q. Array와 ArrayList의 차이점에 대해 설명해주세요.(자료구조)  

A.  
Array: 고정 길이이므로, 정해진 길이의 배열을 모두 채우면, 새로운 데이터를 추가하고 싶을 경우 새로운 배열을 만들어주어야 함  
ArrayList: 가변 길이이므로, 정해진 길이의 배열을 모두 채우면, 추가로 공간을 만들어 저장할 수 있음

https://velog.io/@humblechoi/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-Array-vs-ArrayList

23.02.01
## Q. 포드-폴커슨(Ford-Fuljerson) 알고리즘에 대해 설명해주세요.(알고리즘)  

A.  
- 각 간선이 '용량' 개념을 갖는 그래프에서 두 정점 사이에 얼마나 많은 '흐름' 또는 '유량'을 보낼 수 있는지 계산하는 **네트워크 유량(network flow)** 문제를 해결하기 위한 알고리즘  
- 유량 네트워크의 모든 간선의 유량을 0으로 두고 시작
- 출발점인 소스에서 도착점인 싱크로 유량을 더 보낼 수 있는 경로를 찾아 유량을 보내기를 반복함

https://loosie.tistory.com/633

23.02.02  
## Q. 의사결정나무(Decision Tree)의 프로세스에 대해 설명해주세요.(머신러닝)  

A.  
**의사결정나무(Decision Tree)**
- 분류(Classification)와 회귀(Regression) 모두 가능한 지도 학습 모델 중 하나  
- 스무고개 하듯이 예/아니오 질문을 이어가며 학습함  
- 특정 기준(질문)에 따라 데이터를 구분하는 모델을 결정 트리 모델이라고 함
- 데이터를 가장 잘 구분할 수 있는 질문을 기준으로 나눔
- 나뉜 각 범주에서 또 다시 데이터를 가장 잘 구분할 수 있는 질문을 기준으로 나눔
- 이를 지나치게 많이 하면 오버피팅이 됨
- 오버피팅을 막기 위한 전략으로 가지치기(Pruning)가 있음  
- 가자치기는 최대 깊이나 터미널 노드의 최대 개수, 혹은 한 노드가 분할하기 위한 최소 데이터 수를 제한함

https://bkshin.tistory.com/entry/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D-4-%EA%B2%B0%EC%A0%95-%ED%8A%B8%EB%A6%ACDecision-Tree

23.02.03
## Q. 트랜잭션에서의 데드락이란 무엇이고 그 해결방법을 설명해주세요.(데이터베이스)  

A.  
**트랜잭션 데드락(Deak Lock, 교착상태)**  
- 두 개 이상의 트랜잭션이 특정 자원(테이블 또는 행)의 Lock을 획득한 채 다른 트랜잭션이 소유하고 있는 잠금을 요구하면 아무리 기다려도 상황이 바뀌지 않는 상황

**해결 방법**
- 데드락을 감지하면 한 쪽 트랜잭션을 풀어버린다.
- 트랜잭션 A의 마지막 UPDATE 내용에 오류가 발생되고 COMMIT을 먼저 하도록 유도한다.
- 트랜잭션 B는 아직 WAITING 상태로 남아있고, 트랜잭션 A의 COMMIT을 기다리게 된다.

https://velog.io/@yrkim/Database-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-deadlock

23.02.04
## Q. 왜 TCP연결 시에는 3way handshake고 해제 시에는 4way handshake일까요?(네트워크)  

A.  
**3 way handshake - 연결 성립**  
TCP는 정확한 전송을 보장해야 하므로 통신하기에 앞서 논리적인 접속을 성립하기 위해 3 way handshake 과정을 진행함  
1. 클라이언트가 서버에게 SYN 패킷을 보냄(sequence: x)
2. 서버가 SYN(x)을 받고, 클라이언트로 받았다는 신호인 ACK와 SYN 패킷을 보냄(sequence: y, ACK: x + 1)
3. 클라이언트는 서버의 응답은 ACK(x + 1)와 SYN(y) 패킷을 받고, ACK(y + 1)를 서버로 보냄

이렇게 3번의 통신의 완료로 연결이 성립되기에 3 way handshake이다.

**4 way handshake - 연결 해제**  
연결 성립 후, 모든 통신이 끝났다면 해제해야 함
1. 클라이언트는 서버에게 연결을 종료한다는 FIN 플래그를 보냄
2. 서버는 FIN을 받고, 확인했다는 ACK를 클라이언트에게 보냄(이때 모든 데이터를 보내기 위해 CLOSE_WAIT 상태가 됨)
3. 데이터를 모두 보냈다면, 연결이 종료되었다는 FIN 플래그를 클라이언트에게 보냄
4. 클라이언트는 FIN을 받고, 확인했다는 ACK를 서버에게 보냄(아직 서버로부터 받지 못한 데이터가 있을 수 있으므로 TIME_WAIT을 통해 기다림
    - 서버는 ACK를 받은 이후 소켓을 닫음(CLOSED)
    - TIME_WAIT 시간이 끝나면 클라이언트도 닫음(CLOSED)

이렇게 4번의 통신의 완료로 연결이 해제되기에 4 way handshake이다.

https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Network/TCP%203%20way%20handshake%20%26%204%20way%20handshake.md

23.02.05
## Q. 세마포어(Semaphore)와 뮤텍스(Mutex)의 차이점에 대해 설명해주세요.(운영체제)  

A.  
**세마포어(Semaphore)**  
- 멀티프로그래밍 환경에서 공유 자원에 대한 접근을 제한하는 방법
- 공유된 자원에 여러 프로세스가 동시에 접근하면 문제가 발생할 수 있기에, 공유된 자원의 데이터는 한 번에 하나의 프로세스만 접근할 수 있도록 제한을 두기 위함
- 여러 프로세스가 데이터를 공유하며 수행될 때, 각 프로세스에서 공유 데이터를 접근하는 프로그램 코드 부분인 임계 구역을 이용하여 제한

**뮤텍스(Mutex)**  
- 임계 구역을 가진 스레드들의 실행시간이 서로 겹치지 않고 각각 단독으로 실행되게 하는 기술
- 상호 배제(**Mut**ual **Ex**clusion)의 약자
- 해당 접근을 조율하기 위해 lock과 unlock을 사용함
- 상태가 0, 1로 이진 세마포어로 부르기도 함

https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/Semaphore%20%26%20Mutex.md

23.02.06
## Q. 그래프와 트리의 차이점에 대해 설명해주세요.(자료구조)

A.  
**트리**  
- 계층적 관계를 나타내는 자료구조
- root 노드부터 leaf 노드까지 상하 관계, 순서가 있다
- 사이클을 허용하지 않는다

**그래프**  
- 연결 관계를 나타내는 자료구조
- 모든 노드는 동등한 위치이고 순서나 상하 관계가 없다
- 사이클이 생길 수 있다

https://bigsong.tistory.com/33

23.02.07  
## Q. Minimum Cut에 대해 설명하고 Maximum Flow와 동일한 이유에 대해 설명해주세요.(알고리즘)  

A.  
노드들이 서로 연결돼있는 그래프를 2개의 서로 다른 집합으로 나누는 것을 Cut이라고 한다.  
Minimum Cut은 최소 비용으로 Cut하는 것을 의미한다.  
그래프에 가중치가 없다면 간선의 개수를 가장 적게 자르는 것이,  
가중치가 있다면 간선의 가중치의 합을 가장 적게 자르는 것이 Minimum Cut이다.  

네트워크 플로우에서 Maximum Flow는 최대 유량 문제이다.  
즉, 네트워크 그래프에서 유량을 최대화하는 방법이다.  
이때, 그래프에서 Minimum Cut을 하는 것이 네트워크 유량을 최대화하는 것과 같다.  

https://www.crocus.co.kr/755

23.02.08
## Q. 편향(Bias)과 분산(Variance)에 대해 tradeoff와 연관지어 설명해주세요.(머신러닝)  

A.  
**편향(Bias)**  
- 예측값들과 정답이 대체로 멀리 떨어져 있으면 결과의 편향(bias)이 높다고 말함

**분산(Variance)**  
- 예측값들이 자기들끼리 대체로 멀리 흩어져 있으면 결과의 분산(Variance)이 높다고 말함

**Bias-variance tradeoff**  
- bias를 높임으로 variance를 낮출 수 있고, 반대의 경우도 가능하다
- 즉, bias와 variance는 한 가지를 선택하면 한 가지를 다소 포기해야 한다

https://opentutorials.org/module/3653/22071  
https://en.wikipedia.org/wiki/Bias%E2%80%93variance_tradeoff

23.02.09
## Q. 데이터베이스의 이상현상의 종류와 각각의 정의를 설명해주세요.(데이터베이스)

**이상**
- 릴레이션에서 일부 속성들의 종속이나 데이터의 중복으로 인해 데이터 조작시 불일치가 발생하는 것
- 테이블을 설계할 때 잘못 설계하여 데이터를 삭제, 수정, 삽입할 때 논리적으로 오류가 생기는 것
- 이를 제거하는 과정이 정규화

1. 삽입 이상: 자료를 삽입할 때 의도하지 않은 자료까지 삽입해야만 자료를 테이블에 추가가 가능한 이상
2. 갱신 이상: 중복된 데이터 중 일부만 수정되어 데이터 모순이 일어나는 이상
3. 삭제 이상: 어떤 정보를 삭제하면, 유용한 다른 정보까지 삭제되어버리는 이상

https://kosaf04pyh.tistory.com/294

23.02.10
## Q. 로드 밸런싱과 로드 밸런서에 대해 연관지어 설명해주세요.(네트워크)  

A.  
**로드 밸런싱(Load Balancing)**  
- 둘 이상의 CPU 또는 저장장치와 같은 컴퓨터 자원들에게 작업을 나누는 것
- 여러 서버에 균등하게 트래픽을 분산시켜주는 것
- 분산식 웹 서비스로, 여러 서버에 부하(Load)를 나누어주는 역할
- 로드 밸런서(Load Balancer)를 클라이언트와 서버 사이에 두고, 부하가 일어나지 않도록 여러 서버에 분산시켜주는 방식

https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Network/%EB%A1%9C%EB%93%9C%20%EB%B0%B8%EB%9F%B0%EC%8B%B1(Load%20Balancing).md

23.02.11
## Q. HTTP 응답 상태 코드 종류를 설명해주세요.(네트워크)

A.  
**202 Accepted**
- 요청을 수신하였지만 그에 응하여 행동할 수 없습니다. 이 응답은 요청 처리에 대한 결과를 이후에 HTTP로 비동기 응답을 보내는 것에 대해서 명확하게 명시하지 않습니다. 이것은 다른 프로세스에서 처리 또는 서버가 요청을 다루고 있거나 배치 프로세스를 하고 있는 경우를 위해 만들어졌습니다.

**301 Moved Permanently**
- 이 응답 코드는 요청한 리소스의 URI가 변경되었음을 의미합니다. 새로운 URI가 응답에서 아마도 주어질 수 있습니다.

**404 Not Found**
- HTTP 404 Not Found 클라이언트 오류 응답 코드는 서버가 요청받은 리소스를 찾을 수 없다는 것을 의미합니다. 404 페이지를 띄우는 링크는 대체로 브로큰 링크(broken link) 또는 데드 링크(dead link)라고 부르며, link rot 대상일 수도 있습니다.

**500 Internal Server Error**
- 하이퍼텍스트 전송 프로토콜 (HTTP) 500 Internal Server Error 서버 에러 응답 코드는 요청을 처리하는 과정에서 서버가 예상하지 못한 상황에 놓였다는 것을 나타냅니다.
- 이 에러 응답은 "서버 에러를 총칭하는"(catch-all) 구체적이지 않은 응답입니다. 종종, 서버 관리자들은 미래에 같은 에러를 발생하는 것을 방지하기 위해 500 상태 코드 같은 에러 응답들에 더 많은 자세한 내용을 남겨 둡니다.

https://developer.mozilla.org/ko/docs/Web/HTTP/Status/202

## Q. Code, Data, Stack, Heap에 대해 설명해주세요.(운영체제)

A.  
프로세스가 차지하고 있는 메모리 영역은 Code, Data, Heap, Stack의 영역으로 나누어져 있고, 이들을 각각 Segment라고 부름

정적 세그먼트  
1. **Code**
- 메모리 맵의 제일 아래 text 부분
- 작성한 코드가 들어가는 부분(기계어도 포함)
- read only 영역이라 쓰기 작업이 들어오면 access violation이 발생
- 프로세스가 종료될 때까지 계속 유지됨  

2. **Data**  
- 전역변수(global), 정적변수(static), 배열(array), 구조체(structure) 등이 저장됨  

동적 세그먼트  

3. **Heap**  
- 프로그래머가 동적으로 사용하는 영역
- malloc, free, new, delete에 의하여 할당 또는 반환되는 영역  

4. **Stack**  
- 지역변수, 매개변수, 복귀 번지 등이 저장되어있는 프로그램이 자동으로 사용하는 임시 메모리
- 함수 호출 시 생성되고, 종료 시 반환됨
- LIFO 정책 사용함
- 다른 세그먼트들은 하위 영역으로부터 할당되지만 Stack 세그먼트는 상위 영역부터 할당됨

https://adevspoon.com/?code=-MCclhOrqxWhGB9ImkuH8FuEbOMTPZw3uGmhU1TA6mVgB32ex20ZL-T5ggUjwXBdGCemKQopyNgAAAGGQJaOxA

23.02.12
## Q. O(n)의 시간복잡도로 힙을 구성하는 방법에 대해 설명해주세요.(자료구조)  

A.  
**Sift Down Operation**  
- 주어진 노드의 child nodes 중 key가 큰 값(or 작은 값)과 비교연산을 수행해 property를 만족하거나, 그렇지 않으면 leaf에 도달할 때까지 swap하는 과정
1. data set에 주어졌을 때, 앞에서부터 순차적으로 완전이진트리를 만든다
2. leaf 노드를 제외한 노드들을 자식 노드들과 비교연산을 수행하여 swap을 한다
3. 힙 속성을 만족할 때까지 2를 반복한다

https://leeminju531.tistory.com/33

23.02.13  
## Q. Segmented Least Squares에 대해 설명하고 이를 해결하는 알고리즘을 제시하세요.(알고리즘)

A.  
- 데이터를 근사하는 모형을 찾는 과정에서 데이터 분포가 하나의 직선으로 표현하기 어려운 경우, 선형 모형 여러 개를 결합하여 데이터를 표현할 수 있는데, 이처럼 복잡한 형태를 쪼개어 직선 여러 개로 표현하는 기법
1. 주어진 모든 점을 (x_n, y_n)으로 표시하고, x 순서대로 정렬한 뒤, 부분집합에 대한 근사오차와 분할에 대한 패널티 값을 더한 합을 전제 오차로 계산한다
2. 동적 프로그래밍(DP)를 활용하여, 분할하는 각 구간에 대해서 전체 오차를 계산하여 가장 작은 값(최소 오차)을 구한다

https://bab2min.tistory.com/629

23.02.14
## Q. MLE와 MAP의 차이에 대해 설명해주세요.(머신러닝)

A.  
Bayes's Rule  
### $p(θ|x) = \frac{p(\theta) f(x|\theta)}{p(x)}$   

Posterior, Prior, Likelihood
- Posterior: $p(\theta|x)$, 즉 위 수식의 좌변. 관측치 $x$가 주어졌을 때 $\theta$를 가지는 확률. 관측치가 주여진(변수가 존재하는) 확률모형
- Prior: $p(\theta)$, $\theta$로 구성된 확률모형. 관측치 $x$를 통해 특정하고자 하는 함수
- Likelihood: $p(x|\theta)$, parms이 주어졌을 때 $x$ 관측치를 얻을 확률모형  

MLE(Maximum Likelihood Estimation)
- Likelihood를 Maximize시켜 추정치를 얻는 방법

MAP(Maximum A Posteriori)
- Posteriori를 Maximize시켜 추정치를 얻는 방법

https://niceguy1575.medium.com/mle%EC%99%80-map%EC%9D%98-%EC%B0%A8%EC%9D%B4-7d2cc0bee9c

23.02.15  
## Q. 데이터베이스의 트랜잭션에 대해서 설명해주세요.(데이터베이스)

A.  
**트랜잭션(Transaction)**  
- 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미

**특징**  
- 데이터베이스 시스템에서 병행 제어 및 회복 작업 시 처리되는 작업의 논리적 단위
- 사용자가 시스템에 대한 서비스 요구 시 시스템에 응답하기 위한 상태 변환 과정의 작업 단위
- 하나의 트랜잭션은 Commit되거나 Rollback 됨

**성질**  
- Atomicity(원자성)
- Consistency(일관성)
- Isolation(독립성, 격리성)
- Durability(영속성, 지속성)

**연산**
- Commit
- Rollback

**상태**
- 활동(Active)
- 실패(Failed)
- 철회(Aborted)
- 부분 완료(Partially Committed)
- 완료(Committed)

https://coding-factory.tistory.com/226

23.02.16
## Q. 사설IP와 공공IP를 차이점을 중심으로 설명해주세요.(네트워크)  

A.  
공공 IP(Public IP)
- 인터넷 사용자의 로컬 네트워크를 식별하기 위해 ISP(인터넷 서비스 공급자)가 제공하는 IP주소

사설 IP(Private IP)
- 일반 가정이나 회사 내 등에 할당된 네트워크의 IP 주소

차이점  
|           |      공인 IP (Public IP)      |     사설 IP (Private IP)    |
|:---------:|:-----------------------------:|:---------------------------:|
| 할당 주체 |   ISP(인터넷 서비스 공급자)   |        라우터(공유기)       |
| 할당 대상 | 개인 또는 회사의 서버(라우터) |    개인 또는 회사의 기기    |
|   고유성  |   인터넷 상에서 유일한 주소   | 하나의 네트워크 안에서 유일 |
| 공개 여부 |       내/외부 접근 가능       |       외부 접근 불가능      |

https://velog.io/@hidaehyunlee/%EA%B3%B5%EC%9D%B8Public-%EC%82%AC%EC%84%A4Private-IP%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90

23.02.17
## Q. 데드락이 무엇인지 설명하고 데드락의 4가지 조건에 대해 각각 설명해주세요.(운영체제)

A.  
데드락(DeadLock, 교착 상태)  
- 두 개 이상의 프로세스나 스레드가 서로 자원을 얻지 못해서 다음 처리를 하지 못하는 상태
- 무한히 다음 자원을 기다리게 되는 상태
- 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생함

발생 조건
- 데드락은 다음 4가지 조건을 모두 만족해야 발생
1. 상호 배제(Mutual Exclusion)
    - 자원은 한 번에 한 프로세스만 사용할 수 있음
2. 점유 대기(Hold and Wait)
    - 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재햐아 함
3. 비선점(No Preemption)
    - 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음
4. 순환 대기(Circuit Wait)
    - 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 함

https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/DeadLock.md

23.02.18
## Q. 해시 함수의 특징과 좋은 해시 함수의 조건에 대해 예시와 함께 설명해주세요.(자료구조)

A.  
해시 함수의 특징
1. 어떤 입력값에도 항상 고정된 길이의 해시값을 출력(동일한 값이 입력되면 언제나 동일한 출력값을 보장)
2. 눈사태 효과: 입력값의 아주 일부만 변경되어도 전혀 다른 결괏값을 출력
3. 비가역적: 출력된 결괏값을 토대로 입력값을 유추할 수 없음

좋은 해시 함수의 조건
1. 해시 충돌(서로 다른 입력값에 대해 같은 결괏값이 나오는 경우)이 적어야 함
2. 해시 함숫값이 해시 테이블의 주소 영역 내에서 고르게 분포되어야 함
3. 계산이 빨라야 함

https://j3sung.tistory.com/759

23.02.19
## Q. 이분 매칭(Bipartite Matching)문제를 포드-폴커슨(Ford-Fulkerson) 알고리즘을 통해 해결하는 방식을 제안해주세요.(알고리즘)

A.  
그래프에 Sink와 Target을 정한 후, sink에서 지원자A로 가는 edge weight = 무한, 직업에서 Target으로의 edge weight은 1로 설정하고 더이상 target으로 가는 residual graph가 없을 때까지 dfs또는 bfs로 탐색하면 된다.

https://adevspoon.com/?code=RJ-ZeDk_KCvV37KV7UsFJvgqAgDgP63oAPWu6IQBAYwJyngbxW1akaR1q0lRhV9NvUejVAo9cxcAAAGGZ4_g1w

23.02.20
## Q. 엔트로피(Entropy)와 크로스 엔트로피(Corss-Entropy)에 대해 설명해주세요.(머신러닝)  

A.  
**엔트로피(Entropy)**  
- 불확실성의 척도. 엔트로피가 높을수록 정보가 많고, 확률이 낮다는 것을ㅇ ㅢ미
- 어떤 데이터가 나올지 예측하기 어려운 정도

**크로스 엔트로피(Corss-Entropy)**  
- 실제 분포 q에 대하여 알지 못하는 상태에서, 모델링을 통하여 구한 분포인 p를 통하여 q를 예측하는 것
- 실제값과 예측값의 차이를 줄이기 위한 엔트로피

https://melonicedlatte.com/machinelearning/2019/12/20/204900.html

23.02.21
## Q. 데이터베이스의 인덱스를 사용할 때의 장점과 단점을 설명해주세요.(데이터베이스)

A.  
**장점**
- 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있음
- 전반적인 시스템의 부하를 줄일 수 있음

**단점**
- 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요함
- 인덱스를 관리하기 위해 추가 작업이 필요함
- 인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생할 수 있음

https://mangkyu.tistory.com/96

23.02.22
## Q. REST API에 대해 설명해주세요.(네트워크)

A.  
**REST API(Represnatational State Trnasfer API)**

**구성**  
- 자원(Resource) - URI
- 행위(Verb) - HTTP METHOD
- 표현(Representations)

**특징**  
- Uniform(유니폼 인터페이스)
- Stateless(무상태성)
- Cacheable(캐시 가능)
- Self-descriptiveness(자체 표현 구조)
- Client - Server 구조
- 계층형 구조

https://meetup.nhncloud.com/posts/92

23.02.23
## Q. 프로세스와 스레드의 차이점에 대해 설명해주세요.(운영체제)  

A.  
프로세스  
- 운영체제로부터 자원을 할당받은 작업의 단위

스레드  
- 프로세스가 할당받은 자원을 이용하는 실행 흐름의 단위

https://velog.io/@raejoonee/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4

23.02.24
## Q. 블룸 필터(Bloom filter)에 대해 설명해주세요.(자료구조)

A.  
- 원소가 집합에 속하는지 여부를 검사하는 데 사용하는 확률적 자료구조
- set, bitmap, hash 함수 등을 이용하여 Encoding과 Decoding 과정을 거쳐 어떤 원소가 집합에 포함되는지 판별할 수 있음

https://jeongchul.tistory.com/605

23.02.25
## Q. 배낭 문제(knapsack Problem)에 대해 설명하고 이를 해결하는 알고리즘을 제시하세요.(알고리즘)

A.  
**배낭 문제**
- 일정 무게를 담을 수 있는 배낭에, 각각 고유의 무게와 가격을 가지고 있는 여러 물건들을 담을 때, 가격을 극대화하여 얼마까지 담을 수 있는지 구하는 문제
- 이차원배열을 통해, 각 아이템을 배낭에 넣었을 경우 담긴 가격의 합을 그 전 아이템까지의 합과 비교해가며 최대값을 찾는 DP의 메모이제이션 기법으로 해결할 수 있다

https://propercoding.tistory.com/50

23.02.26
## Q. K-fold Cross Validation에 대해 설명해주세요.(머신러닝)

A.  
**K-fold Cross Validation**
- K개의 fold를 만들어서 진행하는 교차검증
- 총 데이터 개수가 적은 데이터 셋에 대하여 정확도를 향상시킬 수 있음
- 기존에 Training/Validation/Test 세 개의 집단으로 분류하는 것보다, Training과 Test로만 분류할 때 학습 데이터 셋이 더 많기 때문
- 데이터 수가 적은데 검증과 테스트에 데이터를 더 뺏기면 underfitting 등 성능이 미달되는 모델이 학습됨

23.02.27
## Q. 주장(assertion)에 대해서 설명해주세요.(데이터베이스)

A.
**주장**
- 제약조건을 위반하는 연산이 수행되지 않도록 주장의 조건이 그 조건을 위배할 가능성이 있는 각 이벤트문들마다 검사됨
- 데이터베이스가 항상 만족하기를 바라는 조건을 직접적으로 표현한 것으로, 보통 두 개 이상의 테이블에 영향을 미치는 제약조건을 명시하기 위해 사용됨

https://libertegrace.tistory.com/entry/Database-%EB%AC%B4%EA%B2%B0%EC%84%B1-%EC%A0%9C%EC%95%BD%EC%A1%B0%EA%B1%B4

23.02.28
## Q. http 상태코드(status code)의 의미를 설명해주세요.(네트워크)

A.  
**HTTP 상태 코드(Status Code)**
- 클라이언트가 보낸 HTTP 요청에 대한 서버의 응답 코드로, 상태 코드에 따라 요청의 성공/실패 여부를 판단함  

**분류**  
- 1xx(Informational): 조건부 응답
- 2xx(Successful): 성공
- 3xx(Redirection): 리다이렉션 완료
- 4xx(Client Error): 요청 오류
- 5xx(Server Error): 서버 오류

https://developer.mozilla.org/ko/docs/Web/HTTP/Status  
https://velog.io/@sangyeon217/http-status-code

23.03.01  
## Q. 디스크 캐시와 메모리(램) 캐시의 차이점에 대해 설명해주세요.(운영체제)

A.  
**디스크 캐시**  
- 하드디스크에 접근하는 시간을 개선하기 위해 RAM에 저장하는 기법
- 하드디스크에 접근하는 것보다 RAM에 접근하는 것이 더 빠르기 때문

**캐시 메모리**  
- 램에 접근하지 않고 더 빠른 시간으로 접근할 수 있는 CPU 칩 안에 있는 작지만 빠른 메모리(L1, L2, L3)

23.03.02
## Q. 해시 충돌을 해결하는 방법에 대해 설명해주세요.(자료구조)

A.  
1. 체이닝
- 버킷 내에 연결리스트를 할당하여 버킷에 데이터를 삽입
- 해시 충돌이 발생하면 연결리스트로 데이터들을 연결

2. 개방 주소법
- 해시 충돌이 발생하면 다른 버킷에 데이터를 삽입

3. 리사이징
- 배열의 크기(버킷의 개수)를 늘려 해시 충돌을 방지

https://j3sung.tistory.com/759

23.03.03
## Q. 허프만 코딩(Huffman Coding)에 대해 이진 탐색 트리와 함께 설명해주세요.(알고리즘)

A.  
**허프만 코딩(Huffman Coding)**  
- 입력 파일의 문자 빈도 수를 가지고 최소힙을 이용하여 파일을 압축하는 과정  
- 압축할 파일을 스캔하여 각 문자의 빈도 수를 계산한 뒤, 빈도 수를 우선순위로하여 이진 트리를 만들어 압축

https://velog.io/@junhok82/%ED%97%88%ED%94%84%EB%A7%8C-%EC%BD%94%EB%94%A9Huffman-coding#%ED%97%88%ED%94%84%EB%A7%8C-%EC%BD%94%EB%94%A9%EC%9D%B4%EB%9E%80

23.03.04
## Q. Accuracy, Recall, Precision의 차이에 대해 설명해주세요.(머신러닝)

A.  
Accuracy, Recall, Precision은 머신 러닝과 데이터 분석에서 사용되는 성능 지표입니다. 각각의 지표는 모델이 얼마나 정확하게 예측하고 있는지를 측정하는 데 사용됩니다.

- Accuracy (정확도): 모델이 예측한 값 중에서 실제 값과 일치하는 비율입니다. 즉, 모델이 정확하게 예측한 샘플 수를 전체 샘플 수로 나눈 것입니다. 정확도는 전체적인 모델의 성능을 나타내며, 데이터셋이 클래스 간 균형이 있을 때 유용합니다.

- Recall (재현율): 실제 양성 샘플 중에서 모델이 양성이라고 정확하게 예측한 비율입니다. 즉, 모델이 실제 양성인 샘플을 얼마나 잘 찾아내는지를 나타냅니다. Recall은 거짓 음성(FN)을 최소화하는 데 중점을 둡니다. 예를 들어, 암 진단에서 암 환자를 정확하게 예측하는 것이 중요한 경우 Recall을 사용합니다.

- Precision (정밀도): 모델이 양성이라고 예측한 샘플 중에서 실제 양성인 비율입니다. 즉, 모델이 양성으로 예측한 샘플 중에서 실제 양성인 샘플의 비율을 나타냅니다. Precision은 거짓 양성(FP)을 최소화하는 데 중점을 둡니다. 예를 들어, 스팸 필터링에서 실제로 스팸이 아닌 이메일을 스팸으로 분류하는 것을 방지하는 데 Precision을 사용합니다.

이 세 가지 성능 지표는 서로 보완적이므로, 문제에 따라 적절한 지표를 선택해야 합니다. 예를 들어, 암 진단에서는 Recall이 중요하지만, 스팸 필터링에서는 Precision이 더 중요할 수 있습니다.

[출처] ChatGPT

23.03.05
## Q. RDB과 nosql의 차이점을 설명해주세요.(데이터베이스)

A.  
RDB(Realational DataBase)
- 관계형 데이터베이스. 관계형 데이터 모델을 기초로 두고 모든 데이터를 2차원 테이블 형태로 표현하는 데이터베이스
- 테이블 간 관계를 맺고 모여있는 집합체로, foreign key를 이용해 join을 할 수 있다
- 정해진 스키마에 따라 데이터를 저장해야 하므로 명확한 데이터 구조를 보장함

NoSQL(Not Only SQL(Structured Query Language))
- RDB 형태의 관계형 데이터베이스가 아닌, 다른 형태의 데이터 저장 기술
- 테이블 간 관계를 저장하지 않으며, 테이블 간 join이 불가능함
- 스키마가 없기 때문에 유연하며 자유로운 데이터 구조를 가질 수 있음

https://khj93.tistory.com/entry/Database-RDBMS%EC%99%80-NOSQL-%EC%B0%A8%EC%9D%B4%EC%A0%90#:~:text=NoSQL%EC%9D%B4%EB%9E%80(Not%20Only%20SQL,%EA%B4%80%EA%B3%84%EB%A5%BC%20%EC%A0%95%EC%9D%98%ED%95%98%EC%A7%80%20%EC%95%8A%EC%8A%B5%EB%8B%88%EB%8B%A4.

23.03.06
## Q. CDN에 대해서 설명해주세요.(네트워크)

A.  
**CDN(콘텐츠 전송 네트워크)**  
- 지리적으로 분산된 여러 개의 서버
- 웹 페이지, 이미지, 비디오 등의 콘텐츠를 사용자의 물리적 위치와 가까운 프록시 서버에 캐싱하여 전송함으로써 전송 속도를 높임

https://www.akamai.com/ko/our-thinking/cdn/what-is-a-cdn

23.03.07
## Q. 메모리와 스토리지의 차이점은 무엇인가요?(운영체제)

A.  
**메모리**  
- 컴퓨터에서 단기적으로 데이터에 엑세스 할 수 있게 해주는 구성품
- 문서 편집, 응용 프로그램 로딩, 인터넷 검색 등 작업 수행할 때 단기 메모리에 저장된 데이터에 엑세스함
- 책상과 서류 캐비닛 중 책상과 같이 즉시 사용할 필요가 있는 용품은 책상 위에 두고 쉽게 엑세스할 수 있지만, 크기가 제한되어 많은 용품을 올려둘 수 없음

**스토리지**  
- 컴퓨터에서 장기적으로 데이터를 저장하고 엑세스 할 수 있게 해주는 구성품
- 무기한으로 어플리케이션, 운영 시스템 및 파일을 저장
- 책상과 서류 캐비닛 중 서류 캐비닛과 같이 즉각적인 엑세스가 불필요한 항목이 저장되어 있으며 크기가 크기 때문에 많은 것을 저장할 수 있음

**차이점**  
- 메모리의 데이터는 컴퓨터가 꺼지면 모두 지워지는 반면 스토리지의 데이터는 컴퓨터가 꺼지는 횟수에 관계없이 손상되지 않은 채로 유지됨

https://www.kingston.com/kr/blog/pc-performance/difference-between-memory-storage

23.03.08
## Q. B-Tree에 대해 설명해주세요.(자료구조)

A.  
**B-Tree**
- 이진트리에서 발전되어 모든 리프노드들이 같은 레벨을 가질 수 있도록 자동으로 밸런스를 맞추는 트리
- 정렬된 순서를 보장하고, 멀티레벨 인덱싱을 통한 빠른 검색을 할 수 있음
- M차 B트리는 노드 당 최대 M개의 자식을 가질 수 있음
- 각 노드는 key와, 자식 노드들을 가리키는 포인트를 가짐
- key들은 노드 안에서 항상 정렬된 값을 가지며, 이진탐색트리처럼 왼쪽 자식들은 key보다 작은 값을, 오른쪽 자식들은 key보다 큰 값을 가짐

https://velog.io/@emplam27/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-B-Tree

23.03.09
## Q. 이분 매칭(Bipartite Matching)에 대해 설명해주세요.(알고리즘)

A.  
**그래프의 매칭**
- 어떤 집합에서 특정한 관계에 따른 두 원소 쌍을 최대한 많이 만들려고 한다
- 이때 각 원소를 노드(정점)로 하는 그래프를 만든 뒤, 쌍을 만들고자 하는 노드들을 엣지(간선)로 연결한다
- 서로 짝을 이룬 노드들을 연결한 엣지들을 모아보면, 이들은 끝점(엣지에 연결된 노드)을 공유하지 않은 엣지의 집합이 된다
- 이런 엣지의 집합을 그래프의 매칭(matching)이라고 부른다

**이분 그래프**
- 노드(정점)를 두 그룹으로 나눠서 모든 엣지(간선)가 서로 다른 그룹의 노드들을 연결하도록 하는 그래프를 이분 그래프라고 함

**이분 매칭**
- 이분 그래프에서 최대 매칭을 찾는 문제

https://loosie.tistory.com/643

23.03.10
## Q. Probability와 Likelihood의 차이에 대해 설명해주세요.(머신러닝)

A.  
**Probability(확률)**
- 주어진 확률분포에서 관측값 혹은 관측 구간이 어느 정도의 확률로 존재하는지 나타내는 값
- 확률분포를 고정하고 그때의 관측 X에 대한 확률을 구한다

**Likelihood(가능도)**
- 어떤 값이 관측되었을 때, 이것이 어떤 확률 분포에서 왔을지에 대한 확률
- 관측값을 고정하고 그때의 확률분포에 대한 확률을 구한다

https://jjangjjong.tistory.com/41

23.03.11
## Q. 트랜잭션의 각 격리 수준에 대해서 설명하고, 각 수준에서 일어날 수 있는 문제에 대해 설명해주세요.(데이터베이스)

A.  
[23.01.03 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98-%EA%B0%81-%EA%B2%A9%EB%A6%AC-%EC%88%98%EC%A4%80%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%84%A4%EB%AA%85%ED%95%98%EA%B3%A0-%EA%B0%81-%EC%88%98%EC%A4%80%EC%97%90%EC%84%9C-%EC%9D%BC%EC%96%B4%EB%82%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EB%AC%B8%EC%A0%9C%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4)

23.03.12
## Q. IaaS, PaaS, SaaS에 대해서 설명해주세요.(네트워크)  

A.  
IaaS(Infrastructure as a Service)
- 서비스형 인프라. 비즈니스 운영에 필요한 스토리지, 네트워킹 및 컴퓨팅 리소스를 제공함

PaaS(Platform as a Service)
- 서비스형 플랫폼. 애플리케이션 및 서비스를 구축할 수 있는 플랫폼을 제공함

SaaS(Software as a Service)
- 서비스형 소프트웨어. 특정 앱 또는 웹 포털을 통해 액세스하는 서비스로, 클라이언트 조직의 최종 사용자에게 제공되는 완전한 소프트웨어 솔루션

https://www.freshworks.com/ko/freshdesk/kblogs/iaas-paas-saas/

23.03.13
## Q. 임계 영역(critical section)에 대해 설명해주세요.(운영체제)

A.  
교착 상태(Dead Lock)
- 둘 이상의 프로세스가 다른 프로세스가 점유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황

공유 자원(Shared Resource)
- 시스템 안에서 각 프로세스, 스레드가 함께 접근할 수 있는 자원이나 변수 등을 의미함
- 이 공유 자원을 두 개 이상의 프로세스가 동시에 읽거나 쓰는 상황을 경쟁 상태(race condition)라고 함
- 동시에 접근을 시도할 때 접근의 타이밍이나 순서 등이 결괏값에 영향을 줄 수 있는 상태

임계 영역(Critical Section)
- 한 순간에는 반드시 프로세스 하나만 진입해야 하는데, 프로그램에서 임계 자원을 이용하는 부분으로 공유 자원의 독점을 보장하는 코드 영역을 의미
- 임계 구역은 지정된 시간이 지난 후 종료됨

https://velog.io/@lovi0714/%EC%9E%84%EA%B3%84-%EC%98%81%EC%97%AD-Critical-Section

23.03.14
## Q. Hash Table에 대해 설명해주세요.(자료구조)  

A.  
해시 함수  
- 입력값을 원하는 범위의 자연수로 바꿔주는 함수

해시 테이블(Hash Table)
- 해시 함수와 배열을 같이 사용하는 자료구조
- key를 바로 인덱스로 하지 않고, 해시 함수에 넣어 return된 값을 인덱스로 사용

https://github.com/jaehyun-dev/Today-I-Learned/blob/main/Data%20Structure/1%20Basic%20Data%20Structures/5%20Hash%20Table/Note.md#03-%ED%95%B4%EC%8B%9C-%ED%85%8C%EC%9D%B4%EB%B8%94-%EA%B0%9C%EB%85%90  
https://ablue-1.tistory.com/68

23.03.15
## Q. Interval Partitioning 문제에 대해 설명하고 이를 해결하기 위한 알고리즘을 제시해주세요.(알고리즘)

A.  
Interval Partitioning
- 각각 정해진 시간 동안 공간을 점유하는 여러 interval을 한 공간에 대해 서로 겹치지 않게 분배하려고 할 때 준비해야 하는 최소한의 공간을 구하는 문제
- 예) n개의 강의에 대해서 모든 수업을 시간과 강의실이 겹치지 않도록 최소한의 강의실을 배정하려면 몇 개의 강의실이 있어야 하는가?

Greedy Algorithm
- 각 interval i에는 시작하는 시각 s_i와 끝나는 시각 f_i가 있다.
- 모든 interval을 s에 대해 정렬한다
- 1번 interval부터 마지막 interval까지, 준비된 공간 중 하나에 들어가면 순차적으로 할당하고, 그렇지 않다면 새로운 공간을 준비한다

https://velog.io/@claude_ssim/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Greedy-Algorithm-Interval-Partitioning

23.03.16
## Q. Cost Function, Loss Function, Object Function에 대해 설명하고 각각의 종류에 대해 설명해주세요.(머신러닝)

A.  
Cost Function, Loss Function, Object Function은 머신 러닝 모델 학습에서 사용되는 함수  
각각의 함수는 모델이 예측하는 값과 실제 값 사이의 차이를 계산하는 데 사용됨

Cost Function (비용 함수)
- 모델의 매개변수를 조정하여 예측 값과 실제 값 사이의 차이를 최소화하는 데 사용되는 함수
- 모델이 예측한 값과 실제 값의 차이를 계산하여 평균화함
- 비용 함수는 전체 데이터셋에 대해 계산되므로, 비용 함수를 최소화하는 것은 모델이 더 정확한 예측을 하도록 학습하는 것을 의미함
- 종류:
    - 평균 제곱 오차 (Mean Squared Error, MSE)
    - 평균 절대 오차 (Mean Absolute Error, MAE)
    - 평균 제곱근 오차 (Root Mean Squared Error, RMSE)

Loss Function (손실 함수)
- 모델이 한 샘플에 대해 예측한 값과 실제 값 사이의 차이를 계산하는 함수
- 모델의 예측이 얼마나 잘못되었는지를 측정함
- 일반적으로 모델의 학습 과정에서 각 샘플마다 손실 함수의 값이 계산되고, 이 값은 비용 함수를 계산하는 데 사용됨
- 종류
    - 이진 교차 엔트로피 (Binary Cross-Entropy)
    - 다중 클래스 교차 엔트로피 (Categorical Cross-Entropy)
    - 로그 손실 (Log Loss)

Objective Function (목적 함수)
- 비용 함수와 손실 함수를 모두 포함하는 함수
- 모델의 매개변수를 조정하여 예측 값과 실제 값 사이의 차이를 최소화하는 데 사용됨
- 일반적으로 모델의 학습 과정에서 목적 함수를 최소화하는 것이 목표
- 종류:
    - 평균 제곱 오차 (Mean Squared Error, MSE)
    - 교차 엔트로피 (Cross-Entropy)
    - 로그 우도 (Log Likelihood)

[출처]
ChatGPT

https://velog.io/@regista/%EB%B9%84%EC%9A%A9%ED%95%A8%EC%88%98Cost-Function-%EC%86%90%EC%8B%A4%ED%95%A8%EC%88%98Loss-function-%EB%AA%A9%EC%A0%81%ED%95%A8%EC%88%98Objective-Function-Ai-tech

23.03.17
## Q. Read Committed와 Repeatable Read 수준의 차이를 설명해주세요.(데이터베이스)

A.  
Read Committed와 Repeatable Read는 모두 데이터베이스에서 사용되는 트랜잭션 격리 수준 중 일부

Read Committed (RC)
- 다른 트랜잭션에서 변경한 데이터를 볼 수 없는 격리 수준
- 다른 트랜잭션이 커밋하기 전까지는 변경 내용이 적용되지 않음
- Dirty Read 문제는 발생하지 않지만, Non-Repeatable Read와 Phantom Read 문제가 발생할 수 있음

Repeatable Read (RR)
- 동일한 쿼리를 실행할 때 결과가 항상 일관된 격리 수준
- 한 번 읽은 데이터를 다시 읽을 때, 항상 같은 값을 반환함
- 다른 트랜잭션에서 새로운 데이터를 추가하는 것은 허용하지만, 기존 데이터를 수정하거나 삭제하는 것은 허용하지 않음
- Dirty Read와 Non-Repeatable Read 문제가 발생하지 않지만, Phantom Read 문제가 발생할 수 있습니다.

Read Committed와 Repeatable Read는 데이터의 일관성과 동시성 처리에 관련된 문제를 해결하기 위해 사용됨  
두 격리 수준은 각각 Dirty Read, Non-Repeatable Read, Phantom Read 문제를 다르게 해결하고 있으며, 애플리케이션에 따라 적합한 격리 수준을 선택해야 함

[출처] ChatGPT

https://tillog.netlify.app/posts/transaction

23.03.18
## Q. 클라우드 컴퓨팅이란 무엇이고 어떤 장점이 있을까요?(네트워크)

A.  
클라우드 컴퓨팅(Cloud Computing)
- 인터넷을 통해 서비스를 제공하는 컴퓨팅 기술
- 인터넷을 통해 서버, 스토리지, 데이터베이스, 네트워크 등의 IT 인프라와 애플리케이션을 사용자에게 제공하는 기술

장점
- 유연성과 확장성
    - 사용자가 필요한 만큼의 IT 리소스를 쉽게 확장하거나 축소할 수 있도록 제공하므로 비즈니스의 요구에 맞게 유연하게 대처할 수 있음
- 경제성
    - 클라우드 컴퓨팅은 기업이 자체적으로 IT 인프라를 구축하는 것보다 비용이 저렴하므로 기업은 자본비용을 줄이고 운영비용을 절감할 수 있음
- 높은 가용성과 신뢰성
    - 클라우드 서비스 제공 업체는 대부분 다양한 지리적 위치와 다중 데이터 센터를 보유하고 있으므로 장애나 문제가 발생했을 때에도 데이터와 서비스에 대한 가용성과 신뢰성을 높일 수 있음
- 높은 보안성
    - 클라우드 서비스 제공 업체는 보안 위험에 대응하기 위한 다양한 보안 기술과 방어 체계를 보유하고 있으므로 기업은 자체적으로 보안을 유지하며 운영하는 것보다 높은 수준의 보안성을 제공받을 수 있음
- 쉬운 관리
    - 클라우드 서비스 제공 업체는 IT 인프라의 관리와 유지보수를 대신 수행하므로 기업은 인프라 운영에 집중하지 않고 비즈니스에 집중할 수 있음

[출처] ChatGPT

https://aws.amazon.com/ko/what-is-cloud-computing/

23.03.19
## Q. 커널 수준의 스레드와 사용자 수준의 스레드의 차이점에 대해 설명해주세요.(운영체제)

A.  
- 스케줄링
    - 커널: 스케줄링을 운영체제 커널에서 처리하므로 스레드 간의 우선순위, 스케줄링 알고리즘 등을 이용해 효율적인 스케줄링을 수행할 수 있음
    - 사용자: 스케줄링을 스레드 라이브러리에서 처리하기 때문에, 운영체제의 스케줄링과는 독립적으로 작동함

- 동기화
    - 커널: 커널 수준의 동기화 메커니즘을 사용하여 스레드 간의 동기화 문제를 해결할 수 있음
    - 사용자: 사용자 수준의 동기화 메커니즘만 사용할 수 있기 떄문에 공유자원에 대한 접근 시 동기화 문제를 처리하기 어려울 수 있음

- 오버헤드
    - 커널: 운영체제 커널에 의존하므로, 커널과 사용자 간의 모드 전환이 발생하므로 컨텍스트 전환 오버헤드가 발생할 수 있음
    - 사용자: 라이브러리에서 관리하므로, 스레드 간의 컨텍스트 전환 오버헤드가 적음

- 확장성
    - 커널: 운영체제 커널에서 처리하기 때문에, 커널이 지원하는 만큼 많은 수의 스레드를 생성할 수 있음
    - 사용자: 스레드 라이브러리에서 처리하기 때문에, 스레드의 개수가 제한될 수 있음

[출처] ChatGPT

https://helloinyong.tistory.com/m/293

23.03.20
## Q. B+Tree에 대해 설명해주세요.(자료구조)

A.  
B+Tree
- 데이터베이스에서 매우 널리 사용되는 트리 구조 자료구조 중 하나
- Balanced Tree의 일종으로, 노드의 수가 적어지거나 늘어나는 것을 최소한으로 유지하면서 효율적인 데이터 검색과 삽입, 삭제를 가능하게 함

특징
1. 노드의 구성
    - B+Tree는 내부 노드와 리프 노드로 구성됨
    - 리프 노드는 데이터를 저장하는 역할을 하고, 내부 노드는 리프 노드를 연결하고, 데이터 검색에 필요한 키 값을 저장함
    - 리프 노드는 각각의 키 값에 대한 데이터를 저장하며, 정렬된 순서로 이어져 있음
2. 균형 잡힌 트리 구조
    - B+Tree는 균형 잡힌 트리 구조로, 모든 리프 노드가 같은 레벨에 위치함
    - 이를 통해 데이터 검색에 필요한 시간을 최소화함
3. 효율적인 검색
    - B+Tree는 내부 노드에 저장된 키 값들을 이용하여 검색 범위를 좁힐 수 있어서 매우 빠른 검색 속도를 제공함
4. 효율적인 삽입과 삭제
    - B+Tree는 노드의 수를 최소한으로 유지하면서 효율적인 데이터 삽입과 삭제를 가능하게 함
5. 다중 버전 동시성 제어(MVCC) 지원
    - B+Tree는 다중 버전 동시성 제어(MVCC)를 지원하여 여러 사용자가 동시에 데이터를 읽거나 쓸 수 있도록 함

- B+Tree는 대용량 데이터베이스의 인덱싱에 매우 적합한 자료구조
- B+Tree는 자동으로 균형이 맞춰지므로, 데이터 삽입과 삭제가 빈번하게 일어나는 상황에서도 매우 빠른 검색 속도를 유지할 수 있음
- 또한, 다중 버전 동시성 제어(MVCC)를 지원하여 여러 사용자가 동시에 데이터를 읽거나 쓸 수 있도록 하기 때문에 데이터베이스의 병목 현상을 최소화할 수 있음

[출처] ChatGPT

https://velog.io/@emplam27/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-B-Plus-Tree

23.03.21
## Q. 최근접 접쌍 찾기 알고리즘(Closest Pair of Points)의 동작 방식을 시간복잡도와 함께 설명해주세요.(알고리즘)

A.  
최근접 접쌍 찾기 알고리즘(Closest Pair of Points)
- 평면 상의 점들 중에서 가장 가까운 두 점의 쌍을 찾는 알고리즘

알고리즘의 동작 방식
1. 입력으로 주어진 점들을 x좌표를 기준으로 정렬
2. 정렬된 점들을 반으로 나누어 왼쪽과 오른쪽으로 분할
3. 분할된 영역에 점이 3개 이하가 될 때까지 각 영역을 재귀적으로 왼쪽과 오른쪽으로 분할
4. 분할된 영역에 속한 점들 중에서 가장 가까운 두 점의 쌍과 오른쪽 부분에 속한 점들 중에서 가장 가까운 두 점의 쌍을 각각 재귀적으로 찾기
5. 왼쪽 부분과 오른쪽 부분에서 찾은 가장 가까운 두 점의 쌍 중에서 더 가까운 쌍을 선택
6. 더 가까운 쌍을 기준으로 중심선을 그리고, 중심선을 넘어가지 않는 점들 중에서 가장 가까운 두 점의 쌍을 찾기. 이때, 이전에 찾은 가장 가까운 쌍보다 더 가까운 쌍이 있는지 확인
7. 최종적으로 찾은 가장 가까운 두 점의 쌍을 반환

시간복잡도
- O(nlogn)

[출처] ChatGPT

https://bblackscene21.tistory.com/11

23.03.22
## Q. L1, L2 정규화에 대해 설명해주세요.(머신러닝)

A.  
딥러닝 모델 과적합을 막는 방법에는 세 가지가 있음
- batch normalization(배치 정규화)
- weigt regularization(정규화)
- dropout(학습 당시 랜덤으로 절반의 뉴런만 사용하기)

이중 weight regularization에 해당하는 것이 L1, L2 정규화

학습을 진행할 때, 학습 데이터에 따라 특정 weight의 값이 커지게 될 수 있음  
그러면 과적합이 일어날 가능성이 아주 높은데, 이를 방지하기 위해 L1, L2 정규화를 사용함  

L1 정규화  
![image](https://user-images.githubusercontent.com/71001479/226781170-fa5c0ca5-1c18-422c-9dc5-12afbb57bf20.png)

cost function에 가중치의 절댓값을 더하여 중요한 가중치만 남김

L2 정규화  
![image](https://user-images.githubusercontent.com/71001479/226781434-6c5c061a-0ff5-4236-aced-c70ecd869ae3.png)

cost function에 제곱한 가중치 값을 더하여 cost와 가중치가 줄어드는 방식으로 학습하여 특정 가중치가 비이상적으로 커지는 상황을 방지함

https://huidea.tistory.com/154

23.03.23

## Q. Dirty Read 현상과 이 현상이 발생하는 레벨에 대해서 설명해주세요.(데이터베이스)

A.  
Dirty Read  
- 다른 트랜잭션이 아직 Commit 되지 않은 데이터를 읽어들이고, Rollback 후의 값을 다시 읽어 최종 결괏값이 달라지는 현상
- 4가지 격리 수준 중 첫 번째 단계인 Read Uncommitted 레벨에서 발생함

http://blog.skby.net/dirty-read/

23.03.24
## Q. 캐시 교체 알고리즘에 대해 설명해주세요.(네트워크)

A.  
캐시  
- 데이터나 값을 미리 복사해놓는 임시 장소
- 자주 쓰는 데이터를 캐시에 복사해두면, 빠른 속도로 접근이 가능하다
- 용량 크기에 제한이 있기 때문에, 새로운 캐시를 넣기 위해서는 기존의 데이터를 삭제해야 함

케시 교체 알고리즘
- 새로운 캐시를 저장하기 위해 어떤 데이터 파일을 캐시에서 삭제할지 결정하는 알고리즘

종류
- FIFO(First In First Out): 가장 먼저 들어간 캐시를 교체
- LFU(Least Frequently Used): 사용 횟수가 가장 적은 캐시를 교체
- LRU(Least Recently Used): 가장 오랫동안 사용되지 않은 캐시를 교체

https://gengmi.tistory.com/entry/Cache-%EC%BA%90%EC%8B%9C-%EB%8F%99%EC%9E%91%EA%B3%BC-%EC%BA%90%EC%8B%9C-%EA%B5%90%EC%B2%B4-%EC%A0%95%EC%B1%85

23.03.25
## Q. 메모리 단편화를 해결하는 방법에 대해 설명해주세요.(운영체제)

A.  
1. 압축: 여러곳에 분산되어 있는 단편화된 메모리 공간을 합쳐 사용할 수 있는 하나의 큰 공간을 만드는 방법(디스크 조각모음)
2. 통합: 단편화가 발생된 공간에서 인접해있는 다른 단편화 공간들을 하나로 합쳐 큰 공간을 만드는 방법
3. 페이징: 프로그램을 페이지 단위로 나누고, 실제 메모리 공간을 프레임 단위로 나눠, 페이지의 논리적 주소를 프레임의 물리적 주소에 매핑하는 방법
4. 세그멘테이션: 가상 메모리를 서로 크기가 다른 논리적 단위인 세그먼트로 분할해서 메모리를 할당하여 실제 메모리 주소로 변환하는 방법

https://kosaf04pyh.tistory.com/40

23.03.26
## Q. 이진 탐색 트리(Binary Search Tree)에 대해 설명해주세요.(자료구조)

A.  
이진 탐색 트리(Binary Search Tree)  
- 이진 트리이면서, 왼쪽의 모든 노드는 부모 노드보다 작아야 하고, 오른쪽의 모든 노드는 부모 노드보다 큰 속성을 만족하는 트리
- 이진 탐색과 링크드리스트의 장점을 결합하여 효율적인 탐색과 입력 및 삭제가 가능함  
- 중위 순회를 하면 값을 정렬된 순서로 읽을 수 있음

https://ratsgo.github.io/data%20structure&algorithm/2017/10/22/bst/

23.03.27
## Q. Minimizing Lateness 문제에 대해 설명하고 이를 해결하기 위한 알고리즘을 제시하세요.(알고리즘)

A.  
여러 태스크에 대해 소요 시간과 마감 기한이 주어졌을 때, 태스크를 마친 시간이 마감 기한을 얼만큼 넘겼는지를 나타내는 lateness를 최소화하도록 스케줄링 하는 문제  
greedy algorithm으로 해결하며, 마감이 가장 가까운 태스크부터 처리하도록 스케줄링(EDD rule, Earliest Due Date ruel)하면 lateness를 최소화할 수 있음

https://hyunw.kim/blog/2018/09/18/Algorithm_Analysis09_GreedyAlgorithm3.html

23.03.28
## Q. SGD 알고리즘과 모멘텀(Momentum)에 대해 설명해주세요.(머신러닝)

A.  
SGD(Stochastic Gradient Descent, 확률적 경사 하강법) 알고리즘  
- 데이터 전체가 아닌 분할된 일부분만을 보고 업데이트를 하는 것

모멘텀(Momemtum)  
- 데이터를 분할 하여 경사 하강법을 사용하면 전역 최솟값(Global Minima)에 도달하지 못하고 지역 최솟값(Local Minima)에 빠지게 되는데, 이를 해결하기 위한 방법
- 기존에 업데이트에 사용했던 기울기의 일정 퍼센테이지를 남겨서 현재의 기울기와 더하여 업데이트에 사용하는 방식

https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=2011topcit&logNo=220563609607

23.03.29
## Q. FORCE와 ¬FORCE 정책의 차이점과 REDO복구가 무조건적으로 필요한 정책은 둘 중 어느 것인지 설명해주세요.(데이터베이스)

A.  
FORCE 정책: 수정했던 모든 페이지를 트랜잭션 커밋 시점에 디스크에 반영하는 정책
¬FORCE(not FORCE) 정책: 수정했던 페이지를 트랜잭션 커밋 시점에 디스크에 반영하지 않는 정책

FORCE 정책을 따르면 트랜잭션이 커밋되면 수정되었던 페이지들이 이미 디스크 상의 데이터베이스에 반영되었으므로 REDO 복구가 필요 없게 됨  
반면에 ¬FORCE 정책을 따른다면 커밋한 트랜잭션의 내용이 디스크 상의 데이터베이스 상에 반영되어 있지 않을 수 있기 때문에 반드시 REDO 복구가 필요하게 됨

https://d2.naver.com/helloworld/407507

23.03.30
## Q. 고정IP와 유동IP에 대해서 설명해주세요.(네트워크)

A.  
[22.09.14 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-%EA%B3%A0%EC%A0%95ip%EC%99%80-%EC%9C%A0%EB%8F%99ip%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)

23.03.31
## Q. 페이징이란 무엇인가요?(운영체제)

A.  
[22.11.02 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-%ED%8E%98%EC%9D%B4%EC%A7%95%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C)

23.04.01
## Q. Red-Black Tree에 대해 설명해주세요.(자료구조)  

A.  
[22.10.23 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-red-black-tree%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0)

23.04.02
## Q. Interval Scheduling 문제에 대해 설명하고 이를 해결하기 위한 알고리즘을 제시해주세요.(알고리즘)  

A.  
**Interval Scheduling**  
- 어떤 일 j가 s_j에서 시작해서 f_j에서 끝난다고 할 때, 다른 일들과 수행 시간이 겹치지 않으면서 주어진 일들을 최대한 많이 할 수 있는 조합을 찾는 스케줄링 문제
- greedy algorithm으로 해결하며, 주어진 일들 중 가장 일찍 끝나는 일부터 수행한다

https://velog.io/@claude_ssim/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Greedy-Algorithm-Interval-Scheduling

23.04.03
## Q. Local Minima 문제에 대해 설명하고 이를 해결하기 위한 방안을 설명해주세요.(머신러닝)

A.  
Local Minima 문제
- loss를 최소화 하기 위해 경사를 따라 내려가던 중 원하는 목표(global minimum, 전역 최솟값)가 아닌 곳(local minimum, 지역 최솟값)에서 loss값이 제일 작다고 판별하게 되는 문제
- Momentum, Adagrad, Adam 등을 통해 해결할 수 있음  

https://variety82p.tistory.com/entry/Local-Minima-%EB%AC%B8%EC%A0%9C%EC%97%90%EB%8F%84-%EB%B6%88%EA%B5%AC%ED%95%98%EA%B3%A0-%EB%94%A5%EB%9F%AC%EB%8B%9D%EC%9D%B4-%EC%9E%98-%EB%90%98%EB%8A%94-%EC%9D%B4%EC%9C%A0%EB%8A%94

23.04.04
## Q. 트랜잭션 격리수준(isolation level)이 필요한 이유에 대해서 설명해주세요.(데이터베이스)

A.  
- 설계한 애플리케이션에서 사용하는 DBMS, 사용하는 트랜잭션, 설계한 테이블 등 다앙한 상황에 맞춰 필요에 따라 선택하기 위해  
- 효율적인 트랜잭션 처리를 위해
- 격리수준이 높을수록 데이터의 일관성은 높아지지만, 동시성 처리에 대한 부담도 늘어나게 됨
- 트랜잭션에서 필요한 데이터 일관성의 정도에 따라 요구되는 격리수준이 달라짐
- 적절한 격리수준을 선택하기 위해 시스템의 요구사항과 데이터 일관성을 고려해야 함

https://namuhuchutong.tistory.com/3

23.04.06
## Q. DHCP란 무엇인가요?

A.  
DHCP(Dynamic Host Configuration Protocol)
- 호스트의 IP주소와 각종 TCP/IP 프로토콜의 기본 설정을 클라이언트에게 자동적으로 제공해주는 프로토콜
- 네크워크에 사용되는 IP주소를 DHCP서버가 중압집중식으로 관리하는 클라이언트/서버 모델을 사용하게 됨
- 네트워크 안의 컴퓨터에 자동으로 네입 서버 주소, IP주소, 게이트웨이 주소를 할당해주는 것을 의미하고, 해당 클라이언트에게 일정 기간 임대를 하는 동적 주소 할당 프로토콜

https://jwprogramming.tistory.com/35

23.04.07
## Q. Race Condition 해결을 위한 충족조건 3가지를 설명해주세요.(운영체제)

A.  
1. Mutual Exclusion(상호 배제)
    - 어떤 프로세스가 임계 영역을 수행 중이면 다른 모든 프로세스들은 그 임계 영역에 들어가지 못하게 막는 것

2. Progress(진행)
    - 임계 영역에 들어간 프로세스가 있지 않은 상태에서 임계 영역에 들어가려는 프로세스가 있으면 들어가게 해주어야 함. 즉, 임계영역에 있는 프로그레스 외에는 다른 프로세스가 임계 영역에 진입하는 것을 방해하면 안 됨

3. Bound Waiting(한정 대기)
    - 기아(starvation) 상태를 방지하기 위해 프로세스가 임계 영역에 들어가려고 요청한 후부터 다른 프로세스들이 임계 영역에 들어가는 횟수에 한계가 있어야 함. 임계 영역에 한 번 들어갔다 나온 프로세스는 다음에 들어갈 때 제한을 둠

https://zangzangs.tistory.com/115

23.04.08
## Q. 큐에 비해 원형큐가 가지는 장단점을 설명해주세요.(자료구조)

A.  
장점:  
- 선형큐는 큐의 맨 앞부분이 비어있어도 뒤가 가득차면 새로운 요소를 추가할 수 없는 반면 원형큐는 큐가 가득차더라도 맨 앞부분이 비어있으면 새로운 요소를 추가할 수 있어 메모리 공간의 이용률이 높음
- 큐가 가득차있을 때, 새로운 요소를 추가하려고 하면 큐가 가득차있는지 판단할 필요가 없음
- 구현이 쉽고 간단함

단점:  
- 큐의 길이를 정확하게 파악하지 않으면, 새로윤 요소를 저장할 수 없는 경우가 발생할 수 있음
- 큐의 요소를 모두 사용하고 나서, 전체 큐를 사용하지 않는 경우, 일부분의 메모리 공간이 낭비됨

[출처] ChatGPT  
https://reakwon.tistory.com/30

23.04.09
## Q. 다익스트라 알고리즘(Dijkstra's Algorithm)에 대해 설명해주세요.(알고리즘)

A.  
[22.11.04 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98dijkstras-algorithm%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)

23.04.10
## Q. Optimizer의 종류에 대해 설명해주세요.(머신러닝)

A.  
Gradient Descent(GD, 경사하강법)
- 경사를 따라 내려가면서 업데이트 시킨다.

Stochastic Gradient Secent(SGD, 확률적 경사하강법)
- full-batch가 아닌 mini batch로 학습을 진행하는 것

Momentum
- SGD에 momentum 개념 추가한 것

AdaGrad
- 학습을 통해 크게 변동이 있었던 가중치에 대해서는 학습률을 감소시키고 학습을 통해 아직 가중치의 변동이 별로 없었던 가중치는 학습률을 증가시켜서 학습이 되게끔 함

RMSProp
- AdaGrad는 간단한 convex function에서 잘 동작하지만, 복잡한 다차원 곡면 function에서는 global minimum에 도달하기 전에 학습률이 0에 수렴할 수 있는 문제를 보완함
- 가중치 기울기를 단순 누적시키는 게 아니라 최신 기울기들이 더 반영되도록 함
- hyper parameter p를 추가하여 h가 무한히 커지지 않게 함

Adam
- momentumr과 RMSProp을 융합한 방법

https://ganghee-lee.tistory.com/24

23.04.11
## Q. Phantom Read 현상과 이 현상이 발생하는 레벨에 대해서 설명해주세요.(데이터베이스)

A.  
Phantom Read  
- 한 트랜잭션 내 같은 쿼리를 두 번 수행 시, 없었던 레코드가 두 번째 쿼리에서 발생하는 현상
- A 트랜잭션에서 Read, B 트랜잭션에서 Write, A 트랜잭션에서 Read를 순차적으로 수행했을 때 A 트랜잭션의 첫 번째와 두 번째 Read 결과가 달라짐
- Repeatable Read 이하 레벨에서 Phantom Read가 발생할 수 있음
- Repeatable Read는 한 트랜잭션이 읽은 데이터를 다른 트랜잭션이 수정하지 못하도록 하지만, 새로운 레코드를 추가하거나 삭제하는 경우는 제약이 적용되지 않기 때문에 Phantom Read가 발생할 수 있음
- Read Committed, Read Uncommitted 레벨은 Repeatable Read 레벨보다 덜 엄격한 격리 수준이기 때문에 마찬가지로 Phantom Read가 발생할 수 있음

[출처] ChatGPT  
http://blog.skby.net/phantom-read/

23.04.12
## Q. 데이터 구조인 JSON과 XML의 차이점에 대해 설명해주세요.(네트워크)

A.  
JSON(JavaSript Object Notation)  
- XML의 대안으로서 좀 더 쉽게 데이터를 교환하고 저장하기 위하여 만들어진 텍스트 기반의 데이터 교환 표준
- 자바스크립트를 기반으로 만들어져 JS에 대한 기초 지식이 있으면 배우기 수월함
- 텍스트 기반이므로 어떠한 프로그래밍 언어에서도 JSON 데이터를 읽고 사용할 수 있음(프로그래밍 언어와 운영체제에 독립적)
- 객체 표기법을 따름
- 사람과 기계가 모두 읽기 편하도록 고안됨

XML(eXtensible Markup Language)
- 데이터를 저장하고 전달할 목적과 저장되는 데이터의 구조를 기술하기 위해 만들어진 언어
- 수많은 응용 분야에서 데이터를 저장하고 전달하는 중요한 역할을 맡고 있음
- HTML, 자바스크립트 등의 기초 지식이 필요함
- 다른 목적의 마크업 언어를 만드는 데 사용되는 다목적 마크업 언어
- 다른 시스템끼리 다양한 종류의 데이터를 손쉽게 교환할 수 있도록 해줌
- 새로운 태그를 만들어 추가해도 계속해서 동작하므로, 확장성이 좋음
- 데이터를 보여주지 않고, 데이터를 전달하고 저장하는 것만을 목적으로 함
- 텍스트 데이터 형식의 언어로 모든 XML 문서는 유니코드 문자로만 이루어짐

JSON과 XML의 차이점
- JSON은 종료 태그를 사용하지 않음
- JSON 구문이 XML 구문보다 짧음
- JSON 데이터가 XML 데이터보다 더 빨리 읽고 쓸 수 있음
- XML은 배열을 사용할 수 없지만 JSON은 사용할 수 있음
- XML은 XML 파서로 파싱되며, JSON은 자바스크립트 표준 함수인 eval()함수로 파싱됨

https://velog.io/@cil05265/XML%EA%B3%BC-JSON%EC%9D%98-%ED%8A%B9%EC%A7%95-%EA%B3%B5%ED%86%B5%EC%A0%90-%EC%B0%A8%EC%9D%B4%EC%A0%90

23.04.13
## Q. 선점 스케줄링의 종류에 대해 설명해주세요.(운영체제)

A.  
1. SRT(Shortest Remaining Time) 스케줄링
    - 짧은 시간 순서대로 프로세스를 수행함. 남은 처리 시간이 더 짧은 프로세스가 Ready 큐에 들어오면 그 프로세스가 바로 선점됨.
2. 라운드로빈(Round-Robin) 스케줄링
    - 각 프로세스가 같은 크기의 CPU 시간을 할당 받고 선입선출 방식으로 실행됨. 할당된 시간이 너무 크면 선입선출과 다를 바가 없어지고, 너무 작으면 오버헤드가 커지게 됨
3. 다단계 큐(Multi-level Queue) 스케줄링
    - Ready 큐를 여러 개 사용하는 기법. 각각의 큐는 자신의 스케줄링 알고리즘을 수행하며, 큐와 큐 사이에도 우선순위를 부여함
4. 다단계 피드백 큐 스케줄링:
    - 다단계 큐와 비슷하나 프로세스들이 큐를 이동할 수 있음

https://www.uname.in/252

23.04.14
## Q. 모바일 기기용 주소록에 BST와 HashTable중 어떤 자료구조를 사용하는 것이 좋은가요? 이유와 함께 설명해주세요.(자료구조)

A.  
[22.10.20 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-%EB%AA%A8%EB%B0%94%EC%9D%BC-%EA%B8%B0%EA%B8%B0%EC%9A%A9-%EC%A3%BC%EC%86%8C%EB%A1%9D%EC%97%90-bst%EC%99%80-hashtable-%EC%A4%91-%EC%96%B4%EB%96%A4-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B4-%EC%A2%8B%EC%9D%80%EA%B0%80%EC%9A%94-%EC%9D%B4%EC%9C%A0%EC%99%80-%ED%95%A8%EA%BB%98-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0)

23.04.15
## Q. Stable Matching 문제를 해결하는 Gale-Shapley 알고리즘에 대해 설명해주세요.(알고리즘)

A.  
Stable Mathing 문제
- N명의 남자와 N명의 여자가 각각 이성 선호도를 나타내는 리스트를 갖고 있을 때, 이 리스트를 활용하여 stable한 matching이 이뤄질 수 있도록 하는 문제
- 불안정한 커플의 조건은, 남자 m의 선호도 리스트에서 현재 아내보다 다른 여자 w가 더 우위에 있고, 동시에 여자 w의 선호도 리스트에서 현재 남편보다 m이 더 우위에 있는 것

Gale-Shapley 알고리즘  
- 임의의 미혼 남자를 한 명 뽑는다
- 뽑은 남자는 자신의 선호도 리스트에서 지금까지 프로포즈하지 않은 여자 중 가장 선호도가 높은 여자에게 프로포즈한다
- 프로포즈를 받은 여자는 약혼자가 없다면 프로포즈를 승낙하여 약혼한다
- 만약 약혼자가 있다면 두 남성 중 더 선호하는 사람과 약혼한다(현재 약혼자보다 프로포즈 받은 남자를 더 선호하면 파혼 후 약혼)
- 여자의 원래 약혼자는 다시 미혼이 남자가 된다
- 미혼 남자가 모두 약혼했다면 모두 동시에 결혼시키고 알고리즘을 종료한다
- 미혼 남자 모두 한 번씩 알고리즘에 참여하므로 O(N)만큼의 시간이 걸리고, 남자의 선호도 리스트 탐색에 O(N)이 걸리고, 여자의 선호도 리스트 탐색에 O(1)이 걸려 총 O(N^2)이 걸린다

https://cubistkang.tistory.com/62

23.04.16
## Q. Overfitting이 발생하는 이유와 해결방법에 대해 설명해주세요.(머신러닝)

A.  
Overfitting  
- 학습 데이터(Training Set)에 대해 과하게 학습된 상황
- 학습 데이터 이외의 데이터에 대해선 모델이 잘 동작하지 못함
- 학습 데이터가 부족하거나, 데이터의 특성에 비해 모델이 너무 복잡한 경우 발생함

발생 이유  
- Model Capacity
    - 모델이 더 복잡한 형상을 나타낼 수 있는 정도
    - Model Capacity를 늘리려면 layer를 더 deep하게 쌓거나 layer당 hidden unit 개수를 늘리면 됨
    - 하지만 Model Capacity를 무한정 늘리면 Overfitting이 발생함

해결방법  
- Model Capacity 낮추기: 모델이 학습 데이터에 비해 과하게 복잡하지 않도록, hidden layer 크기를 줄이거나 layer 개수를 줄이는 등 모델을 간단하게 만듦
- Dropout: 학습을 할 때 일부 뉴런을 끄고 학습함
- L1/L2 정규화(L1/L2 Regularization)
- 학습 데이터 늘리기(Data Augmentation)

https://22-22.tistory.com/35

23.04.17
## Q. Non-Repeatable Read 현상과 이 현상이 발생하는 레벨에 대해서 설명해주세요.(데이터베이스)

A.  
Non-Repeatable Read  
- 한 트랜잭션 내에서 같은 쿼리를 두 번 수행했는데 그 사이에 수정 또는 삭제가 일어나 두 쿼리의 결괏값이 다르게 나타나는 것
- Phantom Read와의 차이점은 데이터가 늘어나는 것(행의 개수 변화)이 아닌 데이터 값만 변경되는 것
- Read Uncommitted, Read Committed에서 발생함

https://bae9086.tistory.com/109

23.04.18
## XSS 공격에 대해서 설명해주세요.(네트워크)

A.  
XSS(Cross Site Scripting)  
- 게시판이나 웹 메일 등에 JavaScript와 같은 스크립트 코드를 삽입해 개발자가 고려하지 않은 기능이 작동하게 하는 치명적일 수 있는 공격
- 대부분의 웹 해킹 공격 기법과는 다르게 클라이언트, 즉 사용자를 대상으로 한 공격
- 공격을 위한 스크립트를 포함한 URL 또는 게시글 URL을 사용자에게 노출하여 서버에 전송하게 하여 공격함
- 사용자의 쿠키 정보, 세션 ID 또는 시스템 관리자 권한을 획득하거나, 악성코드 다운로드, 거짓 페이지 노출 등의 피해를 입힐 수 있음
- PHP의 eregi 함수를 활용한 script 문자 필터링, htmlentities 함수를 활용한 entity 변환 등으로 방지

https://4rgos.tistory.com/1

23.04.19
## 비선점 스케줄링의 종류에 대해 설명해주세요.(운영체제)

A.  
1. HRN(Highest Response ratio Next) 스케줄링: 긴 작업과 짧은 작업 간의 지나친 불평등을 어느 정도 보완한 기법. 수행시간의 길이와 대기 시간을 모두 고려해 우선순위를 정함
2. SJF(Shortest Job First) 스케줄링: 큐 안에 있는 프로세스 중 수행시간이 짧은 것을 먼저 수행. 평균 대기 시간을 감소시킴
3. 우선순위(Priority) 스케줄링: 프로세스에게 우선순위를 정적, 혹은 동적으로 부여하여 우선순위가 높은 순서대로 처리함. 동적으로 부여할 경우, 구현이 복잡하고 오버헤드가 많다는 단점이 있으나, 시스템의 응답속도를 증가시킴
4. 기한부(Deadline) 스케줄링: 작업을 명시된 시간이나 기한 내에 완료하도록 계획
5. FIFO 스케줄링: 프로세스들은 Ready 큐에 도착한 순서대로 CPU를 할당 받음. 작업 완료 시간을 예측하기 매우 용이함. 하지만 덜 중요한 작업이 중요한 작업을 기다리게 할 수도 있음

https://www.uname.in/252

23.04.20
## Q. AVL 트리에 대해서 설명해주세요.(자료구조)

A.  
[22.11.24 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-avl-%ED%8A%B8%EB%A6%AC%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0)

23.04.21
## Q. 동적 계획법(Dynamic Programming)을 Memoization 개념을 이용하여 설명해주세요.(알고리즘)

A.  
- 재귀적 알고리즘에서 같은 연산이 중복되는 결점을 보완하기 위해 고안된 알고리즘  
- 처음 진행되는 연산은 기록해두고, 이미 진행했던 연산은 기록된 값을 가져옴
- Memoization: 동일한 문제를 반복해야 하는 경우, 한 번 계산된 결과를 저장해두었다가 활용하는 방식으로 중복 계산을 줄이는 방법

https://velog.io/@chelsea/1-%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95Dynamic-Programming-DP

23.04.23
## Q. Underfitting이 발생하는 이유와 해결방법에 대해 설명해주세요.(머신러닝)

A.  
Underfitting(과소적합)  
- 이미 있는 Train set도 학습을 하지 못한 상태  
- 원인:  
    - 학습 반복 횟수가 너무 적음
    - 데이터의 특성에 비해 모델이 너무 간단함
    - 데이터 양이 너무 적음
- 해결방법:  
    - 학습 반복 횟수를 늘림
    - 보다 복잡하고 정교한 모델링
    - 데이터 양을 늘림

https://22-22.tistory.com/35

23.04.24
## Q. Read Uncommitted를 lock과 같이 설명해주세요.(데이터베이스)

A.  
- 데이터베이스 트랜잭션은 독립적인 수행이 필요하기 때문에, locking을 통해 트랜잭션이 DB를 다루는 동안 다른 트랜잭션이 관여하지 못하도록 막을 필요가 있음  
- locking을 너무 완벽하게 하면 성능이 떨어지고, 느슨하게 하면 잘못된 결과가 나올 수 있기 때문에 필요에 따라 그에 맞는 격리 수준을 설정해야 함
- 격리 수준(Isolation Level)에는 4가지 단계가 있음
- Read Uncommitted는 가장 낮은 격리 수준
- SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리지 않기 때문에, 처리 중이거나 아직 Commit하지 않은 데이터를 다른 트랜잭션이 읽는 것이 가능

https://velog.io/@bbkyoo/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B2%A9%EB%A6%AC-%EC%88%98%EC%A4%80Transaction-Isolation-Level

23.04.25
## Q. VPN과 VPC에 대해서 설명해주세요(네트워크)

A.  
VPN(Virtual Private Network)
- 가상 사설망
- 물리적인 네트워크가 아닌, 가상에서 같은 이더넷 내에 있게끔 취급해주는 네트워크

VPC(Virtual Private Cloud)
- VM(Virtual Machine) 여러 개가 거대한 컴퓨터 안에 들어가 있는 것
- VPS와 다르게 탄력적, 유동적임
- 트래픽이 갑자기 증가하게 되면 그만한 자원을 제공할 수 있음

https://2kiju.tistory.com/55

23.04.26
## Q. IPC(Inter Process Communication)의 종류와 특징에 대해 설명해주세요.(운영체제)

A.  
1. PIPE
    - 두 개의 프로세스를 연결하고, 하나의 프로세스는 데이터를 쓰기만, 다른 하나는 읽기만 할 수 있음
    - 한쪽 방향으로만 통신이 가능하기 때문에 Half-Duplex(반이중) 통신이라고도 부름
    - 매우 간단하게 사용할 수 있다는 장점과 반이중 통신이므로 프로세스가 읽기 쓰기 통신 모두 해야 하는 상황에 부적합하다는 단점이 있음

2. Named PIPE
    - 통신을 할 프로세스가 명확하지 않은 상태, 즉 서로 모르는 프로세스 사이의 통신의 경우 사용됨
    - PIPE와 달리, Named PIPE는 부모 프로세스와 무관하게 전혀 다른 모든 프로세스들 사이에서 통신이 가능함
    - 읽기/쓰기 동시에 가능하지 않음

3. Message Queue
    - FIFO 구조의 통신설비로 커널에서 관리함
    - PIPE와 같은 데이터 흐름이 아니라 메모리 공간
    - 사용할 데이터에 번호를 붙임으로써 여러 개의 프로세스가 동시에 데이터를 쉽게 다룰 수 있음

4. Shared Memory
    - 통신을 사용하는 게 아니라, 공유메모리가 데이터 자체를 공유하도록 지원하는 설비
    - 프로세스간 메모리 영역을 공유해서 사용할 수 있도록 허용
    - 프로세스가 공유 메모리 할당을 커널에 요청하면 커널은 해당 프로세스에 메모리 공간을 할당하여 어떤 프로세스건 해당 메모리에 접근할 수 있게 함
    - 중개자 없이 곧바로 메모리에 접근할 수 있기 때문에 모든 IPC들 중에서 가장 빠르게 작동함

5. Memory Map
    - Shared Memory와 비슷하나, 열린 파일을 메모리에 맵핑시켜 공유하는 방식

6. Socket
    - 프로세스들 사이의 통신을 가능하게 함
    - 소켓 생성 후 이름, domain, type, Protocol 지정
    - 소켓을 전송하여 데이터를 주고 받을 수 있음

7. Semaphore
    - 프로세스 간 데이터를 동기화하고 보호함
    - 문제가 발생했을 때 공유된 자원에 여러 개의 프로세스가 동시에 접근하면 안 되므로 한 번에 하나의 프로세스만 접근 가능하도록 만들어줌

https://12bme.tistory.com/287

23.04.27
## Q. Stack 2개로 Queue를 구현하는 방법을 설명해주세요.(자료구조)

A.  
- Stack1과 Stack2로 구분한다
- 데이터를 입력받으면 Stack1에 넣는다
- 만약 Stack2가 비어있으면, Stack1에서 가장 위 데이터를 pop하여 Stack2에 넣는다
- 데이터를 출력하려면, Stack2에서 가장 위 데이터를 pop하여 return한다

https://velog.io/@wonhee010/Stack-2%EA%B0%9C%EB%A1%9C-Queue-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0

23.04.28
## Q. Weighted Interval Scheduling 문제에 대해 설명하고 이를 해결하기 위한 알고리즘을 제시하세요.(알고리즘)

A.  
Weighted Interval Scheduling  
- n개의 일이 주어지고 각각의 일을 j라고 할 때, s_j에서 시작해서 f_j에 끝나며 v_j의 weight를 가지고 있는 경우 최대한 일을 겹치지 않는 선에서 weight의 합을 최대로 만드는 문제  
- Dynamic Programming으로 해결
- 끝나는 시간을 기준으로 일을 정렬
- j라는 일을 선택한 경우와 선택하지 않은 경우에 대해서 weight의 합이 큰 경우를 선택하며 최적의 해를 탐색
- i번째 일이 j번째 일보터 먼저 일어났을 경우, i와 j가 compatible 하다는 것은 f_i가 s_j보다 작거나 같다는 것을 의미

https://velog.io/@claude_ssim/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Dynamic-Programming-Weighted-Interval-Scheduling

23.04.29
## Q. Normalization과 Regularization의 차이에 대해 설명해주세요.(머신러닝)

A.  
#### Normalization
- 값의 범위(scale)를 0~1 사이의 값으로 바꾸는 것
- 학습 전에 scaling하는 것
    - 머신러닝에서 scale이 큰 feature의 영향이 비대해지는 것을 방지
    - 딥러닝에서 Local Minima에 빠질 위험 감소(학습 속도 향상)

#### Regularization
- weight를 조정하는데 규제(제약)를 거는 기법
- Overfitting을 막기위해 사용함
- L1 regularization, L2 regularizaion 등의 종류가 있음
    - L1: LASSO(라쏘), 마름모
    - L2: Lidge(릿지), 원

https://realblack0.github.io/2020/03/29/normalization-standardization-regularization.html

23.04.30
## Q. 로깅을 이용한 데이터베이스의 회복에 대해서 간략히 설명해주세요.(데이터베이스)

A.  
[22.11.21 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-%EB%A1%9C%EA%B9%85%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%9D%98-%ED%9A%8C%EB%B3%B5%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EA%B0%84%EB%9E%B5%ED%9E%88-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4)

23.05.01
## Q. CSRF 공격에 대해서 설명해주시고 해결방법에 대해 말씀해주세요.(네트워크)  

A.  
CSRF 공격(Cross Site Request Forgery)  
- 웹 어플리케이션 취약점 중 하나로 인터넷 사용자(희생자)가 자신의 의지와는 무관하게 공격자가 의도한 행위(수정, 삭제, 등록 등)를 특정 웹사이트에 요청하게 만드는 공격
- CSRF를 통해 해커는 희생자의 권한을 도용하여 중요 기능을 실행하는 것이 가능

해결방법  
- Referrer 검증: Back-end 단에서 request의 referrer를 확인하여 domain이 일치하는 지 검증하는 방법
- Security Token 사용 (A.K.A CSRF Token): 사용자의 세션에 임의의 난수 값을 저장하고 사용자의 요청마다 해당 난수값을 포함시켜 전송한 후, Back-end 단에서 요청을 받을 때마다 세션에 저장된 토큰값과 요청 파라미터에 전달되는 토큰값이 일치하는지 검증하는 방법

https://itstory.tk/entry/CSRF-%EA%B3%B5%EA%B2%A9%EC%9D%B4%EB%9E%80-%EA%B7%B8%EB%A6%AC%EA%B3%A0-CSRF-%EB%B0%A9%EC%96%B4-%EB%B0%A9%EB%B2%95

23.05.02
## Q. PCB(Process Control Block)이란 무엇인가요?

A.  
PCB(Process Control Block)  
- 운영체제가 프로세스를 제어하기 위해 정보를 저장해 놓는 곳으로, 프로세스의 상태 정보를 저장하는 구조체이다.
- 프로세스 상태 관리와 문맥교환(Context Switching)을 위해 필요하다.
- PCB는 프로세스 생성 시 만들어지며 주기억장치에 유지된다.

https://dev-mystory.tistory.com/119

23.05.03
## Q. HashMap과 HashTable의 차이를 설명해주세요.(자료구조)

A.  
[22.11.18 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-hashmap%EA%B3%BC-hashtable%EC%9D%98-%EC%B0%A8%EC%9D%B4%EB%A5%BC-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0)

23.05.04
## Q. 그리디 알고리즘(Greedy Algorithm)이 무엇인지 설명하고 그리디 알고리즘의 종류에 대해 아는 대로 이야기해주세요.(알고리즘)

A.  
[22.10.31 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98greedy-algorithm%EC%9D%B4-%EB%AC%B4%EC%97%87%EC%9D%B8%EC%A7%80-%EC%84%A4%EB%AA%85%ED%95%98%EA%B3%A0-%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%98-%EC%A2%85%EB%A5%98%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%84%EB%8A%94-%EB%8C%80%EB%A1%9C-%EC%9D%B4%EC%95%BC%EA%B8%B0%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)

23.05.05
## Q. Logistic Regression의 정의와 장단점, 활용 방안에 대해 설명해주세요.(머신러닝)

A.  
Logistci Regression(로지스틱 회귀)
- 이벤트가 발생할 확률을 결정하는 데 사용되는 통계 모델
- 특성 간의 관계를 보여주고 특정 결과의 확률을 계산함

장점  
- 매우 효율적이고 엄청난 양의 계산 리소스를 필요로 하지 않음
- 쉽게 해석할 수 있고 입력 기능을 확장할 필요가 없음
- 정규화하기 쉽고, 그것이 제공하는 결과는 잘 보정된 예측 확률임
- 쉽게 구현되고 학습하기 쉬우므로 다른 복잡한 알고리즘의 성능을 측정하는 데 도움이 되는 훌륭한 기준이 됨

단점  
- 비선형 문제를 해결하는 데 사용할 수 없음
- 데이터 표시에 크게 의존하므로 필요한 모든 독립 변수를 식별하지 않는 한 출력이 가치가 없음
- 이산적 결과의 경우 범주형 결과를 예측하는 데만 사용할 수 있음
- 과적합에 취약함

활용 방안  
- 보건 의료: 외상 및 상해 심각도 점수(TRISS, 상해를 입은 환자의 사망률 예측), 특정 질병에 걸릴 가능성 예측 등
- 정치: 선거 결과 예측(연령, 성별, 거주지, 사회적 지위 및 이전 투표 패턴(변수)를 기반으로 투표 예측(응답 변수) 생성)
- 제품 테스트: 테스트 중인 시스템 또는 프로토타입 제품의 성공 또는 실패 예측
- 마케팅: 고객의 문의가 판매로 전환될 가능성, 구독이 시작 또는 종료될 가능성, 새로운 제품 라인에 대한 잠재적인 고객 관심 예측 등
- 금융: 신용 카드 회사의 고객 채무 불이행 가능성 예측 등
- 전자상거래: 광고 및 판촉 캠페인 전략 최적화

https://www.tibco.com/ko/reference-center/what-is-logistic-regression

23.05.06
## Q. STEAL과 ¬STEAL 정책의 차이점과 UNDO 복구가 무조건적으로 필요한 정책은 둘 중 어느 것인지 설명해주세요.(데이터베이스)

A.  
- 아직 완료되지 않은 트랜잭션이 수정한 페이지들도 디스크에 출력될 수 있으므로, 만약 해당 트랜잭션이 어떤 이유든 정상적으로 종료할 수 없게 되면 트랜잭션이 변경한 페이지들은 원상복구 되어야 하고, 이런 복구를 UNDO라고 함
- 수정된 페이지를 디스크에 쓰는 시점을 기준으로 STEAL과 ¬STEAL 정책으로 나뉨
- STEAL: 수정된 페이지를 언제든지 디스크에 쓸 수 있는 정책
- ¬STEAL: 수정된 페이지들을 최소한 트랜잭션 종료 시점(EOT, End of Transaction)까지는 버퍼에 유지하는 정책
- UNDO 복구가 무조건적으로 필요한 정책은 STEAL 정책(수정된 페이지가 어떠한 시점에도 디스크에 써질 수 있기 때문에)

https://d2.naver.com/helloworld/407507  
([23.03.29 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-force%EC%99%80-force-%EC%A0%95%EC%B1%85%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EA%B3%BC-redo%EB%B3%B5%EA%B5%AC%EA%B0%80-%EB%AC%B4%EC%A1%B0%EA%B1%B4%EC%A0%81%EC%9C%BC%EB%A1%9C-%ED%95%84%EC%9A%94%ED%95%9C-%EC%A0%95%EC%B1%85%EC%9D%80-%EB%91%98-%EC%A4%91-%EC%96%B4%EB%8A%90-%EA%B2%83%EC%9D%B8%EC%A7%80-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4) 참고)

23.05.07
## Q. 멀티캐스팅과 브로드캐스팅의 차이에 대해 말씀해주세요.(네트워크)

A.  
- 멀티캐스팅: 수신 대상이 정해져있어 송신자가 여러 수신자에게 한 번에 메시지가 전송되도록 하는 전송 방식
- 브로드캐스팅: 불특정 다수를 대상으로 데이터를 전송하는 전송 방식

https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=eqqus&logNo=140188701607

23.05.08
## Q. 데드락(Deadlock)을 해결하는 3가지 방법을 설명해주세요.(운영체제)

A.  
1. 예방(Prevention):
    - 데드락 발생조건 4가지 중 하나라도 발생하지 않게 하는 것
    - 각각의 조건을 방지(부정)하여 데드락 발생 가능성을 차단
    - 자원의 상호 배제 조건 방지, 점유 대기 조건 방지, 비선점 조건 방지, 순환 대기 조건 방지
2. 회피(Avoidance):
    - 자원을 할당한 후에도 시스템이 항상 Safe state에 있을 수 있도록 할당을 허용
    - 안정 상태(Safe State): 시스템의 프로세스들이 요청하는 모든 자원을, 데드락을 발생시키지 않으면서도 차례로 모두에게 할당해줄 수 있는 상태
    - 은행원 알고리즘(Banker's Algoritm)
3. 탐지(Detection) 및 회복(Recovery):
    - 데드락이 발생을 허용하고, 발생 시 이를 탐지하고 회복하는 알고리즘
    - 현재 시스템의 자원 할당 상태를 통해 데드락 발생 여부 파악
    - 프로세스 1개 이상 중단, 자원 선점하기 등을 통해 순환 대기에서 벗어나 데드락으로부터 회복

https://chanhuiseok.github.io/posts/cs-2/

23.05.09
## Q. 트리 순회 방식인 전위 순회, 중위 순회, 후위 순회에 대해 설명해주세요.(자료구조)

A.  
[22.12.01 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-%ED%8A%B8%EB%A6%AC-%EC%88%9C%ED%9A%8C-%EB%B0%A9%EC%8B%9D%EC%9D%B8-%EC%A0%84%EC%9C%84-%EC%88%9C%ED%9A%8C-%EC%A4%91%EC%9C%84-%EC%88%9C%ED%9A%8C-%ED%9B%84%EC%9C%84-%EC%88%9C%ED%9A%8C%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0)

23.05.10
## Q. 최소 스패닝 트리(Minimum Spanning Tree)의 개념과 특징, 사용 사례에 대해 설명해주세요.(알고리즘)

A.  
[22.10.17 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-%EC%B5%9C%EC%86%8C-%EC%8A%A4%ED%8C%A8%EB%8B%9D-%ED%8A%B8%EB%A6%ACminimum-spanning-tree%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%ED%8A%B9%EC%A7%95-%EC%82%AC%EC%9A%A9-%EC%82%AC%EB%A1%80%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)  
https://gmlwjd9405.github.io/2018/08/28/algorithm-mst.html

23.05.11
## Q. Batch Normalization에 대해서 설명해주세요.(머신러닝)

A.  
배치 정규화(Batch Normalization)  
- 가중치 소멸 문제(Gradient Vanishing) 또는 가중치 폭발 문제(Gradient Exploding)를 해결하기 위한 접근 방법 중 하나
- 학습의 효율을 높이기 위해 도입되었으며, Regulation을 해준다고 볼 수 있음
- 활성화함수의 활성화값 또는 출력값을 정규화(정규분포로 만드는 것)하는 작업
- 학습 시의 미니배치를 한 단위로 정규화함으로써 분포의 평균이 0, 분산이 1이 되도록 정규화함

https://sacko.tistory.com/44

23.05.12
## Q. 데이터베이스 REDO에 대해서 설명해주세요.(데이터베이스)

A.  
- 트랜잭션은 ACID 특성을 지켜야 함
- A: Atomicity(원자성), C: Consistency(일관성), I: Isolation(고립성), D: Durability(지속성)
- REDO 로그: 데이터베이스에 문제가 생겨 정보가 손상됐을 때, 이를 복구하기 위해 필요한 변경 이력 데이터 로그
- 오래된 데이터를 최신 데이터로 만들기(롤 포워드, roll-forward) 위해 필요함

https://loosie.tistory.com/527

23.05.13
## Q. Scale-up과 Scale-out에 대해서 설명해주세요.(네트워크)

A.  
Scale-up(스케일 업)
- 서버 그 자체를 증강하는 것에 의해서 처리 능력을 향상시키는 것
- 수직 스케일로 불리기도 함
- 전형적으로는 SMP(대칭형 멀티 프로세서)에 대해 프로세서를 추가하는 것이나 프로세서 그 자체를 고성능 모델로 옮겨놓는 것
- 어플리케이션 서버에서는 스케일 아웃이 가능해도 빈번히 갱신이 발생하여 정합성 유지가 어려운 데이터베이스 서버에서는 스케일 업이 필요함
- 즉 하나의 이미지 데이터베이스에 대해서 빈번히 갱신이 발생하는, 이른바 OLTP(온라인 트랜잭션 처리)에는 스케일 업이 적합함

Scale-out(스케일 아웃)
- 접속된 서버의 대수를 늘려 처리 능력을 향상시키는 것
- 수평 스케일로 불리기도 함
- 전형적으로는 웹 서버 펌으로서 사용되고 있는 랙 마운트 서버군에 서버를 추가하는 것이나 블레이드 서버에 블레이드를 추가하는 것
- 서버의 가상화 기능을 사용하고 하나의 케이스 내에서 가상적으로 복수 서버를 구축해 스케일 아웃과 동등의 효과를 제공할 수도 있음
- 이러한 방식을 특히 스케일 위드인 또는 가상 스케일 아웃으로 부르기도 함
- 개개의 처리는 비교적 단순하지만 다수의 처리를 동시 병행적으로 실시하지 않으면 안 되는 경우에 적합한데, 갱신 데이터의 정합성 유지에 대한 요건이 별로 어렵지 않은 경우에 적절함
- 즉 높은 병렬성을 실현하기 쉬운 경우
- 웹 서버 펌, 데이터가 읽기 전용인 검색엔진, 데이터 분석 처리, VOD(주문형 비디오), 일부 과학기술 계산, 메일 서버나 게시판 등의 어플리케이션 등에 적용할 수 있음

https://m.blog.naver.com/islove8587/220548900044

23.05.14
## Q. 동기(Synchronous)와 비동기(Asynchronous)의 차이에 대해 설명해주세요.(운영체제)

A.  
- I/O 작업은 user space에서 직접 수행할 수 없기 때문에 user process가 kernel에 I/O 작업을 '요청'하고 '응답'을 받는 구조
- 응답을 어떤 순서로 받는지(synchronous/asynchronous)에 따라 동기 작업과 비동기 작업으 분류됨

**동기 작업(Synchronous)**  
- 작업이 한 번에 하나씩 수행되며 진행 중인 작업이 끝나기 전까지는 해당 작업 외의 다른 작업을 수행하지 못함
- 모든 I/O 요청-응답 작업이 일련의 순서를 따르므로 작업의 순서가 보장됨
- 작업 완료를 user space에서 판단하고 다음 작업을 언제 요청할지 결정함
- 일련의 Pipeline을 준수하는 구조에서 효율적임

**비동기 작업(Asynchronous)**  
- 한 번에 하나 이상의 작업이 수행될 수 있으므로 현재 작업을 진행 중이더라도 다른 작업을 수행할 수 있음
- 작업에 대한 결과를 바로 원하지 않음
- kernel에 I/O 작업을 요청해두고 다른 작업 처리가 가능하나, 작업의 순서는 보장되지 않음
- 작업 완료를 kernel space에서 통보해줌
- 각 작업들이 독립적이거나, 작업 별 지연이 큰 경우 효율적임

https://private.tistory.com/24

23.05.15
## Q. 단일 연결리스트와 원형 연결리스트를 구별하는 방법에 대해 설명해주세요.(자료구조)

A.  
[22.10.11 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-%EB%8B%A8%EC%9D%BC-%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8%EC%99%80-%EC%9B%90%ED%98%95-%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EA%B5%AC%EB%B3%84%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)

23.05.16
## Q. 크루스칼 알고리즘(Kruskal's Algorithm)에 대해 설명해주세요.(알고리즘)

A.  
[22.10.22 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-%ED%81%AC%EB%A3%A8%EC%8A%A4%EC%B9%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98kruskals-algorithm%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)

23.05.17
## Q. 활성함수(Activation Function)에서 ReLU 함수를 사용하는 이유에 대해 설명해주세요.(머신러닝)

A.  
ReLU 함수  
- h = max(0, a) where a = Wx + b

ReLU 함수를 사용하는 이유
- Sparsity(a가 0보다 작을 때): sparse 하다는 것은 벡터를 표시하는 값들 중 0이 많은 수를 차지하는 것. 활성화 값(a)이 0보다 작은 뉴런들이 많을수록 sparse하다. ReLU 함수를 사용하면 sigmoid 함수에 비해 더 sparse한 형태를 만들고, 뉴런의 활성화값이 0인 경우 다음 레이어로 연결되는 weight를 곱하더라도 결괏값이 0이기에, 이는 연산량을 월등히 줄여줌
- Vanishing Gradient(a가 0보다 클 때): sigmoid의 gradient는 x의 절댓값이 증가하는 만큼 작아지게 되는 것에 비해, ReLU의 역함수는 1이므로 ReLU의 경우에는 gradient로 상수를 갖게 되고, 일정한 gradient값은 빠르게 학습하는 것을 도와줌

https://joonable.tistory.com/2

23.05.18
## Q. 데이터베이스 UNDO에 대해서 설명해주세요.(데이터베이스)

A.  
- 트랜잭션은 ACID 특성을 지켜야 함
- A: Atomicity(원자성), C: Consistency(일관성), I: Isolation(고립성), D: Durability(지속성)
- UNDO 정보: 데이터베이스의 데이터 정보가 변경됐을 때, 이를 원래대로 되돌리기 위해 필요한 정보
- 변경을 취소하고 과거의 상태로 되돌리는 롤백(rollback)을 위해 필요함

https://loosie.tistory.com/527

23.05.19
## Q. 도메인의 CNAME과 A레코드에 대해서 설명해주세요.(네트워크)

A.  
CNAME(Canonical Name)
- 하나의 도메인에 도메인 별칭을 부여하는 방식(도메인의 또 다른 도메인 이름)
- 도메인에 도메인이 매핑되어 있기 때문에 IP의 변경에 직접적인 영향을 받지 않음

A레코드(A Record)
- 도메인 이름(Domain Name)에 IP주소(IP Address)를 매핑하는 방법
- 직접적으로 IP가 할당되어 있기 때문에 IP가 변경되면 직접적으로 도메인에 영향을 미침

https://coding-start.tistory.com/348

23.05.21
## Q. (Blocking)과 논-블로킹(Non-blocking)의 차이점에 대해 설명해주세요.(운영체제)

A.  
블로킹(Blocking)
- 동기 작업 중에 I/O를 받아 오기 전까지 프로그램을 멈추어 비동기 수행을 할 수 있게 하는 것
- Blocking 시간에 다른 작업을 할 수 있게 됨
- Thread가 Blocking 된다는 것은 CPU가 점유되어 실행되지 못함을 의미함

논-블로킹(Non-Blocking)
- Wait 하지 않고 작업이 그냥 수행됨
- 자신이 호출되었을 때 즉 System call을 받았을 때 제어권을 바로 자신을 호출한 쪽으로 넘겨 다른 작업을 할 수 있도록 하는 것을 의미
- Thread가 Waiting하지 않으므로 CPU 제어는 그대로임

https://luv-n-interest.tistory.com/1121  
https://jaehoney.tistory.com/242  

23.05.22
## Q. 원형 큐(Circular Queue)에 대해 설명해주세요.(자료구조)

A.  
- 선형 큐의 문제점을 보완하기 위한 자료구조
- 선형 큐의 문제점은 rear이 가리키는 포인터가 배열의 마지막 인덱스를 가리키고 있을 때 앞쪽에서 Dequeue로 발생한 배열의 빈 공간을 활용할 수 없다는 점
- 원형 큐는 포인터 증가 방식이 (rear + 1) % arraysize 형식으로 변환하기 때문에 배열의 첫 인덱스부터 다시 데이터의 삽입이 가능해짐

https://lktprogrammer.tistory.com/59

23.05.23
## Q. 프림 알고리즘(Prim's Algorithm)에 대해 설명해주세요.(알고리즘)

A.  
[22.11.14 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-%ED%94%84%EB%A6%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98prims-algorithm%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)

23.05.24
## Q. Back Propagation에 대해 설명해주세요.(머신러닝)

A.  
Back Propagation(역전파) 알고리즘
- Output Layer에서 시작하여 직전 레이어로 이동하면서 Cost를 구하는 최적화 알고리즘
- Chain Rule을 이용하여 Forward Propagtion에 비해 연산량을 현저히 줄이게 됨

https://box-world.tistory.com/19

23.05.26
## Q. 온프레미스와 클라우드 차이를 설명해주세요.(네트워크)

A.  
온프레미스  
- 서비스를 공급하는 서비스 제공자가 직접적으로 IT 자원을 관리하는 주체가 됨  
- 서비스에 필요한 인프라를 직접 보유함
- 초기 비용이 많이 듦

클라우드  
- 서비스를 공급하는 제공자는 IT 자원을 사용할 뿐, 대부분의 IT 자원 관리는 클라우드 서비스 제공자에게 제공받음
- 서비스에 필요한 인프라를 직접 보유하지 않고 필요할 때만 사용할 수 있음
- 필요한 만큼만 사용하고 사용료를 내면 됨

https://7942yongdae.tistory.com/82

23.05.27
## Q. 임계 영역(critical section)에 대해 설명해주세요.(운영체제)

A.  
- 한 순간 반드시 프로세스 하나만 진입해야 하는데, 프로그램에서 임계 자원을 이용하는 부분으로 공유 자원의 독점을 보장하는 코드 영역을 의미함
- 임계 구역은 지정된 시간이 지난 후 종료됨
- 공유되는 자원, 즉 동시접근하려고 하는 그 자원에서 문제가 발생하지 않게 독점을 보장해줘야 하는 영역을 임계 영역이라고 함

https://velog.io/@lovi0714/%EC%9E%84%EA%B3%84-%EC%98%81%EC%97%AD-Critical-Section

23.05.28
## Q. 큐(Queue)의 개념, 연산, 예시에 대해 설명해주세요.(자료구조)

A.  
개념
- 선입선출 성질의 선형 자료구조

연산
- Enqueue: 큐 맨 뒤에 어떠한 요소를 추가
- Dequeue: 큐 맨 앞쪽의 요소를 삭제
- Peek: front에 위치한 데이터를 읽음
- front: 큐의 맨 앞의 위치(인덱스)
- rear: 큐의 맨 뒤의 위치(인덱스)

예시
- 은행 번호표
- 버스 대기줄

https://monsieursongsong.tistory.com/5

23.05.29
## Q. 위상 정렬(Topological Sort) 알고리즘의 동작 방식과 시간 복잡도에 대해 설명해주세요.(알고리즘)

A.  
위상 정렬(Topological Sort) 알고리즘
- 순서가 정해져있는 작업을 차례로 수행해야 할 때 그 순서를 결쟁해주기 위해 사용하는 알고리즘

동작 방식  
- DAG(Directed Acyclic Graph), 즉 사이클이 발생하지 않는 방향 그래프에 대해서만 적용 가능
- 큐를 이용하여 다음과 같은 절차대로 진행
    1. 진입차수가 0인 정점을 큐에 삽입함
    2. 큐에서 원소를 꺼내 연결된 모든 간선을 제거함
    3. 간선 제거 이후에 진입차수가 0이 된 정점을 큐에 삽입함
    4. 큐가 빌 때까지 2~3번 과정을 반복함
    5. 모든 원소를 방문하기 전에 큐가 빈다면 사이클이 존재하는 것이고, 모든 원소를 방문했다면 큐에서 꺼낸 순서가 위상 정렬의 결과

시간 복잡도
- O(V + E): 그래프에서 정점의 개수 + 간선의 개수

https://m.blog.naver.com/ndb796/221236874984

23.05.30
## Q. 기울기 폭발 문제(Gradient Exploding Problem)와 이를 해결하는 방법에 대해 설명해주세요.(머신러닝)

A.  
기울기 폭발 문제(Gradient Exploding Problem)
- 깊은 인공 신경망 학습 도중 역전파 과정에서 초기 부분의 입력층으로 갈수록 기울기가 점차적으로 커지면서 가중치들이 비정상적으로 크게 업데이트 되는 문제

해결 방법
- 그래디언트 클리핑(Gradient Clipping)
    - 역전파될 때 일정 임계값을 넘어서지 못하게 기울기값을 자르는 방법
    - 임계치만큼 크기를 감소시켜 학습의 안정화를 도모함
    - 주로 그래디언트의 L2 norm으로 나눠주는 방식을 이용함
- 가중치 초기화
    - 세이비어 초기화: 여러 층의 기울기 분산 사이에 균형을 맞춰서 특정 층이 너무 주목을 받거나 다른 층이 뒤쳐지는 것을 막음
    - He 초기화: 세이비어 초기화와 다르게 다음 층의 뉴런 수를 반영하지 않음
- 배치 정규화
    - 한 번에 들어오는 배치 단위로 정규화하는 것
    - 각 층에서 활성화 함수를 통과하기 전이나 후에 모델을 하나 추가함
    - 단순하게 입력을 원점에 맞추고 정규화한 다음, 정규화된 데이터에 대해서 두 개의 새로운 파라미터를 사용하여 스케일과 시프트를 수행함

https://casa-de-feel.tistory.com/m/36

23.05.31
## Q. WAL이 무엇이고 왜 필요한지 설명해주세요.(데이터베이스)

A.  
[22.09.26 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-wal%EC%9D%B4-%EB%AC%B4%EC%97%87%EC%9D%B4%EA%B3%A0-%EC%99%9C-%ED%95%84%EC%9A%94%ED%95%9C%EC%A7%80-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)  

23.06.01
## Q. 블록킹 방식과 논블록킹 방식의 차이점에 대해서 설명해주세요.(네트워크)

A.  
- 처리되어야 하는 작업이 전체적인 작업 흐름을 막는지에 대한 관점의 차이

블록킹(Blocking)  
- 자신의 작업을 진행하다가 다른 주체의 작업이 시작되면 자신의 작업을 멈추고 해당 작업을 기다렸다가 다시 자신의 작업을 시작함
1. 유저는 커널에게 read 작업을 요청함.
2. 커널은 데이터가 입력될 때까지 무한정 대기함(Blocking)
    - 즉, 리소스가 일을 하지 않고 낭비됨
3. 데이터가 입력되면 커널이 유저에게 결과를 전달함

논블록킹(Non-Blocking)
- 다른 주체의 작업에 관련 없이 자신의 작업을 함
1. 유저가 커널에게 read 작업을 요청함
2. 커널은 데이터 입력 여부와 관계 없이 결과를 반환함
3. 이후 커널은 유저로부터 입력 데이터가 올 때까지 수 차례 확인함
4. 입력 데이터가 있으면 커널이 유저에게 결과를 전달함

https://jaehoney.tistory.com/242

23.06.02
## Q. 커널 수준의 스레드와 사용자 수준의 스레드의 차이점에 대해 설명해주세요.(운영체제)

A.  
[23.03.19 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-%EC%BB%A4%EB%84%90-%EC%88%98%EC%A4%80%EC%9D%98-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%99%80-%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%88%98%EC%A4%80%EC%9D%98-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C)

23.06.03
## Q. 덱(deque)에 대해 설명해주세요.(자료구조)

A.  
선형 자료구조의 한 유형
double-ended queue의 줄임말로, 큐의 단점을 보완한 자료구조

23.06.04
## Q. 칸 알고리즘(Kahn's Algorithm)에 대해 섦명해주세요.(알고리즘)

A.  
[22.11.09 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-%EC%B9%B8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98kahns-algorithm%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)

23.06.05
## Q. 퍼셉트론(Perceptron)의 개념과 학습 방법에 대해 설명해주세요.(머신러닝)

A.  
퍼셉트론(Perceptron)  
- 인공 신경망 모형의 하나
- 다수의 신호(Input)을 입력받아서 하나의 신호(Output)를 출력함
- 가중치(weight)가 각각의 입력신호에 부여되어 입력신호와 계산을 하고 신호의 총합이 정해진 입계값($\theta\$, theta, 세타)을 넘어섰을 때 1을 출력함
- 각 입력신호에는 고유한 weight가 부여되며 weight가 클수록 해당 신호가 중요하다고 볼 수 있음
- 기계학습이 하는 일은 이 weight(입력을 조절하니 매개변수로도 볼 수 있음)의 값을 정하는 작업이라고 할 수 있음

퍼셉트론 학습 방법
- 처음에는 임의로 설정된 weight로 시작함
- 학습 데이터를 퍼셉트론 모형에 입력하여 분류가 잘못됐을 때 weight를 개선해나감

https://sacko.tistory.com/m/10

23.06.07
## Q. 2단계 로킹 프로토콜에 대해서 설명해주세요.(데이터베이스)

A.  
로킹 기법
- 두 개의 연산 lock와 unlock 연산으로 트랜잭션의 데이터를 상호배제하여 제어하는 기법

2단계 로킹기법(2PLP: two-phase locking protocol)
- 기본적인 로킹기법은 직렬 가능성이 보장되지 않지만, 2단계 로킹기법은 직렬성을 보장

https://noil0816.tistory.com/153

23.06.08
## Q. 비동기란 무잇언가요?(네트워크)

A.  
- 요청을 보냈을 때 응답 상태와 상관없이 다음 동작을 수행할 수 있음
- A 작업이 시작하면 동시에 B 작업이 실행되고, A 작업은 결과값이 나오는대로 출력됨
- 동기에 비해 복잡하지만 결과가 주어지는 데 시간이 걸려도 그 시간 동안 다른 작업을 할 수 있어서 보다 효율적일 수 있음

23.06.09
## Q. 메모리 단편화를 해결하는 방법에 대해 설명해주세요.(운영체제)

A.  
[23.03.25 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8B%A8%ED%8E%B8%ED%99%94%EB%A5%BC-%ED%95%B4%EA%B2%B0%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C)

23.06.10
## Q. 스택(Stack)을 구현함에 있어 링크드리스트로 구현하는 것과 배열로 구현하는 것의 차이점을 설명해주세요.(자료구조)

A.  
스택(Stack)
- 후입선출(LIFO, Last In First Out) 형태의 선형 자료구조

배열(Array)을 이용한 구현
- 데이터를 저장할 배열, 스택의 최대 크기를 저장할 변수, 스택의 입출력 데이터를 가리키는 top을 관리하기 위한 변수가 필요함
- 처음 생성한 크기를 바꿀 수 없다는 단점이 있음

링크드리스트(Linked List, 연결 리스트)를 이용한 구현
- Node 클래스를 이용해 데이터를 추가할 때마다 다음 노드에 저장하여 연결하여
- 전체 길이가 정해져 있지 않기 때문에 스택이 다 찼는지 여부를 체크할 필요가 없음

https://m.blog.naver.com/simjunbo/220023493124

23.06.11
## Q. 계수 정렬(Count Sort)의 구현 방식, 시간복잡도, 공간복잡도, 장단점에 대해 설명해주세요.(알고리즘)

A.  
구현 방식  
- 입력 배열의 크기 범위만큼 빈도수(counting) 배열을 생성
- 입력 배열을 순회하며 각 원소의 빈도수를 counting 배열에 기록
- 빈도수 배열을 이용하여 정렬된 결과 배열을 생성

시간복잡도
- O(N + k)
- 이때 N은 입력 배열의 크기, k는 입력 배열 내 최댓값

공간복잡도  
- O(N + k)
- 빈도수 배열 생성 O(k), 정렬된 결과 배열 저장 O(N)

장점  
- 빠르고 효율적

단점  
- k가 큰 경우 많은 메모리 공간이 필요함

https://gyoogle.dev/blog/algorithm/Counting%20Sort.html

23.06.12
## Q. 하이퍼파라미터 튜닝 기법 종류를 3가지 이상 이야기해주세요.(머신러닝)

A.  
| 종류                                          | 설명                                                          | 적용 시 고려사항                                                                                                                                                                 |
|-----------------------------------------------|---------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 학습률<br>(Learning Rate)                     | gradient의 방향으로 얼마나 빠르게 이동할 것인지 결정하는 변수 | – 너무 작으면 학습의 속도가 늦고, 너무 크면 학습 불가                                                                                                                            |
| 손실 함수<br>(Cost Function)                  | 입력에 따른 기대 값과 실제 값의 차이를 계산하는 함수          | – 평균 제곱 오차<br>– 교차 엔트로피 오차                                                                                                                                         |
| 정규화 파라미터<br>(Regularization parameter) | L1 또는 L2 정규화 방법 사용                                   | – 사용하는 일반화 변수도 하이퍼 파라미터로 분류                                                                                                                                  |
| 미니 배치 크기<br>(Mini-batch Size)           | 배치셋 수행을 위해 전체 학습 데이터를 등분하는(나누는) 크기   | – 가용 메모리 크기와 epoch 수행 성능을 고려<br>– 최소 사이즈 : 32 /<br> * 참조논문( arxiv.org/abs/1804.07612)<br>– 배치 크기는 GPU의 물리적인 구조로 인해 항상 2의 제곱으로 설정 |
| 훈련 조기 종료<br>(Early Stopping)            | 학습의 조기 종료를 결정하는 변수                              | – 학습 효율이 떨어지는 시점을 적절히 판단                                                                                                                                        |
| 은닉층의 뉴런 개수<br>(Hidden Unit)           | 훈련 데이터에 대한 학습 최적화 결정 변수                      | – 첫 Hidden Layer의 뉴런 수가 Input Layer 보다 큰 것이 효과적                                                                                                                    |
| 가중치 초기화<br>(Weight Initialization)      | 학습 성능에 대한 결정 변수                                    | – 모든 초기값이 0일 경우 모든 뉴런이 동일한 결과                                                                                                                                 |

https://daje0601.tistory.com/m/197

23.06.14
## Q. 프록시 서버에 대해 설명해주세요.(네트워크)

A.  
프록시 서버(Proxy Server)  
- 시스템이 방화벽을 가지고 있는 경우 외부와의 통신을 위해 만들어 놓은 서버
- 클라이언트가 자신을 통해서 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터
- 보안 상의 이유 등으로 직접 통신할 수 없는 두 점 사이에 대리로 통신을 수행하는 기능을 프록시라고 하며 그 중계 기능을 하는 것이 프록시 서버
- 프록시 서버에 요청된 내용들을 캐시를 이용하여 저장
- 캐시를 이용하여 전송시간 단축, 불필요한 외부와의 연결 및 트래픽 감소, 네트워크 병목 현상 방지가 가능함

https://yunyoung1819.tistory.com/9

23.06.15
## Q. 비선점 스케줄링의 종류에 대해 설명해주세요.(운영체제)

A.  
[23.04.19 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#%EB%B9%84%EC%84%A0%EC%A0%90-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81%EC%9D%98-%EC%A2%85%EB%A5%98%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C)

23.06.16
## Q. 스택(Stack)의 개념, 연산, 예시에 대해 설명해주세요.(자료구조)

A.  
개념
- 한 쪽 끝에서만 자료를 넣고 뺄 수 있는 LIFO(Last In First Out) 형식의 자료 구조

연산
- pop(): 스택에서 가장 위에 있는 항목을 제거
- push(item): item 하나를 스택의 가장 윗 부분에 추가
- peek(): 스택의 가장 위에 있는 항목을 return
- isEmpty(): 스택이 비어 있을 때 True를 return

예시
- 백트래킹 재귀 알고리즘
- 웹 브라우저 방문기록(뒤로가기)
- 실행 취소
- 역순 문자열 만들기

https://gmlwjd9405.github.io/2018/08/03/data-structure-stack.html

23.06.17
## Q. 정렬 알고리즘을 모두 이야기하고 각각의 시간 복잡도와 공간 복잡도에 대해 설명해주세요.(알고리즘)

A.  
<table class="tg">
<thead>
  <tr>
    <th class="tg-57pk" rowspan="2">정렬 종류</th>
    <th class="tg-mr14" colspan="3">시간 복잡도</th>
    <th class="tg-57pk" rowspan="2">공간 복잡도</th>
  </tr>
  <tr>
    <th class="tg-tj68">평균(Average)</th>
    <th class="tg-4ufn">최선(Best)</th>
    <th class="tg-4ufn">최악(Worst)</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-yxh0"><span style="color:#333">선택 정렬</span></td>
    <td class="tg-bea3">O(n^2)</td>
    <td class="tg-bea3">O(n^2)</td>
    <td class="tg-bea3">O(n^2)</td>
    <td class="tg-bea3">O(n^2)</td>
  </tr>
  <tr>
    <td class="tg-yxh0"><span style="color:#333">버블 정렬</span></td>
    <td class="tg-citn">O(n^2)</td>
    <td class="tg-citn">O(n)</td>
    <td class="tg-citn">O(n^2)</td>
    <td class="tg-citn">O(n)</td>
  </tr>
  <tr>
    <td class="tg-yxh0"><span style="color:#333">삽입 정렬</span></td>
    <td class="tg-bea3">O(n^2)</td>
    <td class="tg-bea3">O(n)</td>
    <td class="tg-bea3">O(n^2)</td>
    <td class="tg-bea3">O(n^2)</td>
  </tr>
  <tr>
    <td class="tg-kez1"><span style="background-color:#DCDDDD">합병 정렬</span></td>
    <td class="tg-citn">O(n×log n)</td>
    <td class="tg-citn">O(n×log n)</td>
    <td class="tg-citn">O(n×log n)</td>
    <td class="tg-citn">O(n×log n)</td>
  </tr>
  <tr>
    <td class="tg-kez1"><span style="background-color:#DCDDDD">퀵 정렬</span></td>
    <td class="tg-bea3">O(n×log n)</td>
    <td class="tg-bea3">O(n×log n)</td>
    <td class="tg-bea3">O(n^2)</td>
    <td class="tg-bea3">O(n×log n)</td>
  </tr>
  <tr>
    <td class="tg-kez1"><span style="background-color:#DCDDDD">힙 정렬</span></td>
    <td class="tg-citn">O(n×log n)</td>
    <td class="tg-citn">O(n×log n)</td>
    <td class="tg-citn">O(n×log n)</td>
    <td class="tg-citn">O(n×log n)</td>
  </tr>
  <tr>
    <td class="tg-kez1"><span style="background-color:#DCDDDD">쉘 정렬</span></td>
    <td class="tg-2uhg"><span style="background-color:#F0F0F0">O(N^1.25)</span></td>
    <td class="tg-2uhg"><span style="background-color:#F0F0F0">O(N^1.25)</span></td>
    <td class="tg-2uhg"><span style="background-color:#F0F0F0">O(N^1.25)</span></td>
    <td class="tg-bea3">O(n)</td>
  </tr>
  <tr>
    <td class="tg-yxh0"><span style="color:#333">기수 정렬</span></td>
    <td class="tg-tsok"><span style="color:#000">O(dn)</span></td>
    <td class="tg-tsok"><span style="color:#000">O(dn)</span></td>
    <td class="tg-tsok"><span style="color:#000">O(dn)</span></td>
    <td class="tg-citn"> </td>
  </tr>
</tbody>
</table>

https://yabmoons.tistory.com/250  
https://coding-factory.tistory.com/615

23.06.18
## Q. 기울기 소실 문제(Gradient Vanishing Problem)와 해결 방법에 대해 설명해주세요.(머신러닝)

A.  
기울기 소실 문제(Gradient Vanishing Problem)  
- Back Propagation에서 계산 결과와 정답과의 오차를 통해 가중치를 수정하는데, 입력층으로 갈수록 기울기가 작아져 가중치들이 업데이트 되지 않아 최적의 모델을 찾을 수 없는 문제

해결 방법  
- ReLU(Rectified Linear Unit, 경사함수) 도입
- Leaky ReLU 도입
- 배치 정규화(Batch Normalization)
- Resnet(Residual Network)

https://velog.io/@yunyoseob/Gradient-Vanishing-%EA%B8%B0%EC%9A%B8%EA%B8%B0-%EC%86%8C%EC%8B%A4

23.06.20
## Q. 웹소켓이란 무엇인가요?(네트워크)

A.  
웹소켓
- Transport Protocol의 일종으로, 서버와 클라이언트 간의 효율적인 양방향 통신을 실현하기 위한 구조
- 단순한 API로 구성되어 있으며, 하나의 HTTP 접속으로 양방향 메시지를 자유롭게 주고받을 수 있음

https://choseongho93.tistory.com/266

23.06.21
## Q. 내부 단편화와 외부 단편화의 차이점에 대해 설명해주세요.(운영체제)

A.  
[22.10.21 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-%EB%82%B4%EB%B6%80-%EB%8B%A8%ED%8E%B8%ED%99%94%EC%99%80-%EC%99%B8%EB%B6%80-%EB%8B%A8%ED%8E%B8%ED%99%94%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)

23.06.23
## Q. 단일 연결리스트에서 중간 삽입과 삭제를 O(n)이 아니라 더 낮은 시간복잡도로 구현하는 방법을 설명해주세요.(자료구조)

A.  
헤드 포인터와 테일 포인터 사용
- 연결 리스트의 헤드 포인터와 테일 포인터를 유지하는 방법을 사용하면, 중간 위치에 노드를 삽입하거나 삭제하는 것이 아니라 헤드나 테일에서 삽입 및 삭제를 수행할 수 있음
- 이를 통해 O(1)의 시간 복잡도로 중간 삽입과 삭제를 구현할 수 있음
- 단, 중간 위치에 있는 노드에 대한 접근이 필요한 경우에는 여전히 O(n)의 시간 복잡도가 필요함

추가적인 데이터 구조 사용
- 연결 리스트 외에 추가적인 데이터 구조를 사용하여 중간 위치에 대한 정보를 미리 유지하는 방법
- 예를 들어, 배열이나 해시 테이블 등을 사용하여 특정 인덱스에 해당하는 노드를 O(1)의 시간 복잡도로 찾을 수 있게 됨
- 이 방법은 중간 삽입과 삭제 시에 배열이나 해시 테이블을 업데이트해야 하므로, 추가적인 메모리 공간을 사용해야 한다는 점에 유의해야 함

출처: ChatGPT  
https://gusdnd852.tistory.com/100

23.06.24
## Q. 기수 정렬(Radix Sort)의 구현 방식, 시간복잡도, 공간복잡도, 장단점에 대해 설명해주세요.(알고리즘)

A.  
기수정렬(Radix Sort)
- 데이터를 구성하는 기본 요소(Radix)를 이용하여 정렬을 진행하는 알고리즘
- 자릿수의 값(둘째 자리, 첫째 자리 등)별로  정렬

시간복잡도
- O(d * (n + b))
- d는 정렬할 숫자의 자릿수, b는 10(k와 같으나 10으로 고정되어 있음)

공간복잡도
- O(n + b)

장점
- 문자열, 정수 정렬 가능

단점
- 자릿수가 없는 것(부동소숫점)은 정렬할 수 없음
- 중간 결과를 저장할 bucket 공간이 필요함

https://gyoogle.dev/blog/algorithm/Radix%20Sort.html

23.06.25
## Q. 활성함수(activation function)을 비선형 함수를 사용하는 이유에 대해 설명해주세요.(머신러닝)

A.  
1. XOR 문제 해결
    - 직선으로 해결할 수 없는 결정경계 문제 해결
2. 입력 피처의 왜곡
    - 타겟 함수의 곡률(curvature)을 바꿀 수 있게 해줌으로써, 이후의 레이어에서 선형으로 분리할 수 있도록 만들어줌

https://myeonghak.github.io/deeplearning/Deep-Learning-%EB%B9%84%EC%84%A0%ED%98%95-%ED%95%A8%EC%88%98%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0%EC%97%90-%EB%8C%80%ED%95%9C-%EC%8B%9C%EA%B0%81%EC%A0%81-%EC%84%A4%EB%AA%85/

23.06.26
## Q. 트랜잭션의 격리성에 대해서 예를 들어 설명해주세요.(데이터베이스)

A.  
트랜잭션
- 여러 개의 작업을 하나로 묶은 실행 유닛

ACID 원칙
- 데이터베이스 내에서 일어나는 하나의 트랜잭션의 안전성을 보장하기 위해 필요한 성질
- Atomicity(원자성)
- Consistency(일관성)
- Isolation(격리성, 고립성)
- Durability(지속성)

격리성(Isolation)
- 모든 트랜잭션은 다른 트랜잭션으로부터 독립되어야 한다는 원칙

예시
- 계좌 A에 만 원이 있다고 가정
- 계좌 A에서 계좌 B로 6천 원, 계좌 C로 6천 원을 동시에 이체하는 경우, 계좌 B에 먼저 송금한 뒤 계좌 C에 보내는 결과와 동일해야 함
- 동시에 트랜잭션을 실행한다고 해서 계좌 B와 계좌 C에 각각 6천 원씩 송금하여 마이너스 통장이 되는 것은 아님
- 각각의 송금 작업을 연속으로 실행하는 것과 동일한 결과가 나타나야 함
- 격리성을 지키는 각 트랜잭션은 철저히 독립적이기 때문에, 다른 트랜잭션의 작업 내용을 알 수 없음
- 트랜잭션이 동시에 실행될 때와 연속으로 실행될 때의 데이터베이스 상태가 동일해야 함

https://hanamon.kr/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98-acid-%EC%84%B1%EC%A7%88/

23.06.27
## Q. 웹소켓과 SocketIO의 차이점에 대해 설명해주세요.(네트워크)

A.  
웹소켓(WebSocket)
- 양방향 소통을 위한 프로토콜
- HTML5 웹 표준 기술
- 매우 빠르게 작동하며 통신할 때 아주 적은 데이터를 이용함
- 이벤트를 단순히 듣고, 보내는 것만 가능함

Socekt.IO
- 양방향 통신을 하기 위해 웹소켓 기술을 활용하는 라이브러리
- 표준 기술이 아니며, 라이브러리임
- 소켓 연결 실패 시 fallback을 통해 다른 방식으로 알아서 해당 클라이언트와 연결을 시도함
- 방 개념을 이용해 일부 클라이언트에게만 데이터를 전송하는 브로드캐스팅이 가능함

https://www.peterkimzz.com/websocket-vs-socket-io/

23.06.28
## Q. 선점 스케줄링의 종류에 대해 설명해주세요.(운영체제)

A.  
[23.04.13 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-%EC%84%A0%EC%A0%90-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81%EC%9D%98-%EC%A2%85%EB%A5%98%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C)

23.06.29
## Q. 다섯가지 점근 푶기법에 대해 설명해주세요.(자료구조)

A.  
[22.09.28 질문 및 답](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-%EB%8B%A4%EC%84%AF-%EA%B0%80%EC%A7%80-%EC%A0%90%EA%B7%BC-%ED%91%9C%EA%B8%B0%EB%B2%95%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)

23.06.30
## Q. 이분탐색(Binary Search) 알고리즘에 대해 설명해주세요.(알고리즘)

A.  
이분 탐색(Binary Search)
- 결정 문제(Decision Problem)의 답이 이분적일 때 사용할 수 있는 탐색 기법
- 경계를 포함하는 구간 [lo, hi]를 잡은 뒤 구간의 길이를 절반씩 줄여나가며 lo, hi이 경계 지점에 위치하도록 하는 것

https://www.acmicpc.net/blog/view/109

23.07.01
## Q. 퍼셉트론(Perceptron)의 한계점에 대해 설명해주세요.(머신러닝)

A.  
XOR GATE에서 A와 B 중 1개씩만 1인 경우 직선을 그어 결괏값이 1인 값을 구분할 수 없다는 점

https://gggggeun.tistory.com/m/103

23.07.02
## Q. 트랜잭션 스케줄링이 non-serial함과 serializable함의 차이점에 대해서 설명해주세요.(데이터베이스)

A.  
serial schedule(직렬 스케줄)
- 여러 트랜잭션들의 집합을 한번에 한 트랜잭션씩 차례대로 수행

non-serial schedule(비직렬 스케줄)
- 여러 트랜잭션들을 동시에 수행

serializable schedule(직렬 가능 스케줄)
- 비직렬 스케줄의 결과가 직렬 스케줄의 결과와 동등

https://woochan-autobiography.tistory.com/627#2.%20%EB%8F%99%EC%8B%9C%EC%84%B1%20%EC%A0%9C%EC%96%B4

23.07.03
## Q. long polling과 polling에 대해 설명해주세요.(네트워크)

A.  
http 프로토콜  
- 웹에서 사용되는 표준 프로토콜
- 클라이언트가 서버에 request(요청)를 넣으면 서버가 클라이언트에게 response(응답)하는 단방향 통신 방식

polling
- http 프로토콜의 한계를 넘어, 통신하는 것처럼 느끼게 방법 중 초기모델
- 클라이언트에서 서버로 일정 시간 간격으로 계속해서 request를 넣는 방식
- 특징
    - 주기적으로 물어보므로 응답 간격을 일정하게 할 수 있음
    - 주기적으로 몰아서 물어보는 게 가능하므로 자동으로 배치 프로세싱(일괄 처리)되어서 DB 튜닝을 하는 효과가 나옴
    - 실시간으로 주는 건 불가능함(간격을 줄이면 되지만 서버와 클라이언트 모두에게 부담이 됨)
    - 보낼 데이터가 없어도 계속해서 데이터를 줘야 하므로 서버의 리소스를 낭비함

long polling
- polling의 단점을 개선한 모델
- request를 보내고 time out 될 때까지 무한정 기다림
- 서버에서 연결이 끊어지면 클라이언트에서 바로 다시 연결함
- 반대로 서버에서 response를 주면 바로 클라이언트에게 전달함
- 클라이언트는 response를 받자마자 바로 다시 서버에 request를 보냄
- 특징
    - 항상 연결이 유지되어 있음
    - 변경에 매우 민감하게 반응하여 사실상 실시간으로 통신이 가능함
    - 데이터가 주어지는 즉시 반응하고 보내므로 요청간격이 줄어든다면 polling보다 훨씬 데이터를 많이 보내게 됨

https://kamang-it.tistory.com/entry/Webhttp%ED%86%B5%EC%8B%A0%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%96%91%EB%B0%A9%ED%96%A5-%ED%86%B5%EC%8B%A0%EA%B8%B0%EB%B2%95-long-polling

23.07.04
## Q. 운영체제와 커널의 차이점에 대해 설명해주세요.(운영체제)

A.  
[22.11.06 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80-%EC%BB%A4%EB%84%90%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C)  

- 운영체제는 시스템의 자원을 관리하는 시스템 프로그램이며, 커널은 운영체제의 중요한 부분(프로그램)
- 커널은 시스템의 소프트웨어와 하드웨어 간의 인터페이스 역할을 하는 반면 운영체제는 사용자와 컴퓨터 간의 인터페이스 역할을 함
- 운영체제는 단일 및 다중 프로그래밍 일괄 처리 시스템, 분산 운영 체제, 실시간 운영 체제로 더 분류되는 반면 커널은 모놀리식 커널과 마이크로 커널로 분류됨
- 커널은 메모리 관려, 프로세스 관리, 작업 관리 및 디스크 관리를 담당하는 반면 운영 체제는 커널의 책임 외에도 시스템의 보호 및 보안을 담당함

https://ko.gadget-info.com/difference-between-kernel

23.07.06
## Q. 단일연결리스트와 이중연결리스트의 차이점에 대해 설명해주세요.(자료구조)

A.  
[22.12.13 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-%EB%8B%A8%EC%9D%BC%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8%EC%99%80-%EC%9D%B4%EC%A4%91%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0)

23.07.07
## Q. 쉘 정렬(Shell Sort)의 구현 방식, 시간복잡도, 공간복잡도, 장단점에 대해 설명해주세요.(알고리즘)

A.  
[22.10.28 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-%EC%89%98-%EC%A0%95%EB%A0%ACshell-sort%EC%9D%98-%EA%B5%AC%ED%98%84-%EB%B0%A9%EC%8B%9D-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84-%EA%B3%B5%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84-%EC%9E%A5%EB%8B%A8%EC%A0%90%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)

23.07.08
## Q. 활성함수(activation function)의 정의와 종류에 대해 설명해주세요.(머신러닝)

A.  
정의  
- 신경망 회로에서, 한 노드에 대해 입력값을 다음 노드에 보낼지 말지에 대해 결정하는 함수.

종류
- Step Function
- Sigmoid Function
- tanh 함수
- ReLU 함수

https://m.blog.naver.com/good5229/221752705030

23.07.09
## Q. 동시성 제어를 하지 않고 다수의 트랜잭션을 동시에 수행할 경우 발생 가능한 문제를 설명해주세요.(데이터베이스)

A.  
갱신 손실(Lost Update)
- 하나의 트랜잭션이 갱신한 내용을 다른 트랜잭션이 덮어씀으로써 갱신이 무효화가 되는 것을 의미
- 두 개 이상 트랜잭션이 한 개의 데이터를 동시에 갱신(Update)할 때 발생

현황파악 오류(Dirty Read)
- 읽기 작업을 하는 트랜잭션1이, 쓰기 작업을 하는 트랜잭션2가 작업한 중간 데이터를 읽기 때문에 발생하는 문제
- 작업 중인 트랜잭션2가 작업을 Rollback한 경우 트랜잭션1은 무효가 된 데이터를 읽게 디ㅗ고 잘못된 결과를 도출함

모순성(Inconsistency)
- 다른 트랜잭션들이 해당 항목 값을 갱신하는 동안 한 트랜잭션이 두 개의 항목 값 중 어떤 것은 갱신되기 전의 값을 읽고 다른 것은 갱신된 후의 값을 읽게 되어 데이터의 불일치가 발생하는 상황

연쇄 복귀(Cascading Rollback)
- 두 트랜잭션이 동일한 데이터 내용을 접근할 때 발생
- 한 트랜잭션이 데이터를 갱신한 다음 실패하여 Rollback 연산을 수행하는 과정에서 갱신과 Rollback 연산을 실행하고 있는 사이에 해당 데이터를 읽어서 사용할 때 발생할 수 있는 문제

https://jokerkwu.tistory.com/125

23.07.10
## Q. 웹서버와 WAS의 차이점에 대해 설명해주세요.(네트워크)

A.  
웹서버  
- 개념
    - 소프트웨어와 하드웨어로 구분됨
        - 하드웨어: Web 서버가 설치되어 있는 컴퓨터
          - 소프트웨어: 웹 브라우저 클라이언트로부터 HTTP 요청을 받아 정적인 컨텐츠(.html, .jpeg, .css 등)를 제공하는 컴퓨터 프로그램
- 기능
    - HTTP 프로토콜을 기반으로 하여 클라이언트(웹 브라우저 또는 웹 크롤러)의 요청을 서비스하는 기능을 담당함
    - 요청에 따라 아래의 두 가지 기능 중 적절하게 선택하여 수행함
        - 기능1
            - 정적인 컨텐츠 제공
            - WAS를 거치지 않고 바로 자원을 제공
        - 기능2
            - 동적인 컨텐츠 제공을 위한 요청 전달
            - 클라이언트의 요청(Request)을 WAS에 보내고, WAS가 처리한 결과를 클라이언트에게 전달(응답, Response)함
            - 클라이언트는 일반적으로 웹 브라우저를 의미함
- 예시
    - Apache Server, Nginx, IIS(Windows 전용 Web 서버) 등

WAS(Web Application Server)
- 개념
    - DB 조회나 다양한 로직 처리를 요구하는 동적인 컨텐츠를 제공하기 위해 만들어진 Application Server
    - HTTP를 통해 컴퓨터나 장치에 애플리케이션을 수행해주는 미들웨어(소프트웨어 엔진)
    - "웹 컨테이너(Web Container)" 혹은 "서블릿 컨테이너(Servlet Container)"라고도 불림
        - Container란 JSP, Servlet을 실행시킬 수 있는 소프트웨어
        - 즉, WAS는 JSP, Servlet 구동 환경을 제공함
- 역할
    - WAS = Web Server + Web Container
    - Web Server 기능들을 구조적으로 분리하여 처리하고자 하는 목적으로 제시됨
        - 분산 트랜잭션, 보안, 메시징, 쓰레드 처리 등의 기능을 처리하는 분산 환경에서 사용됨
        - 주로 DB 서버와 같이 수행됨
    - 현재는 WAS가 가지고 있는 Web Server도 정적인 컨텐츠를 처리하는 데 있어서 성능 상 큰 차이가 없음
- 기능
    - 프로그램 실행 환경과 DB 접속 기능
    - 여러 개의 트랜잭션 관리 기능
    - 업무를 처리하는 비즈니스 로직 수행
- 예시
    - Tomcat, JBoss, Jeus, Web Sphere 등

https://gmlwjd9405.github.io/2018/10/27/webserver-vs-was.html

23.07.11
## Q. 페이징이란 무엇인가요?(운영체제)

A.  
[22.11.02 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-%ED%8E%98%EC%9D%B4%EC%A7%95%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C)

23.07.12
## Q. 인접행렬과 인접리스트의 장단점에 대해 설명해주세요.(자료구조)

A.  
[22.12.25 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q&A%20a%20Day/Notes.md#q-%EC%9D%B8%EC%A0%91%ED%96%89%EB%A0%AC%EA%B3%BC-%EC%9D%B8%EC%A0%91%EB%A6%AC%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0)

23.07.13
## Q. 퀵 정렬(Quick Sort)의 구현 방식, 시간복잡도, 공간복잡도, 장단점에 대해 설명해주세요.

A.  
[22.10.07 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-%ED%80%B5-%EC%A0%95%EB%A0%ACquick-sort%EC%9D%98-%EA%B5%AC%ED%98%84-%EB%B0%A9%EC%8B%9D-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84-%EA%B3%B5%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84-%EC%9E%A5%EB%8B%A8%EC%A0%90%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)

23.07.14
## Q. 하이퍼파라미터의 종류에 대해 아는 대로 이야기해주세요.(머신러닝)

A.  
하이퍼파라미터(Hyperparameter)
- 머신러닝에서 하이퍼파라미터는 최적의 훈련 모델을 구현하기 위해 모델에 설정하는 변수로 학습률(Learning Rate), 에포크 수(훈련 반복 횟수), 가중치 초기화 등을 결정할 수 있음. 또한 하이퍼파라미터 튜닝 기법을 적용하여 훈련 모델의 최적값들을 찾을 수 있음

하이퍼파라미터의 특징
- 모델의 매개 변수를 추정하는 데 도움이 되는 프로세스에서 사용됨
- 하이퍼파라미터는 개발자에 의해 수동으로 설정할 수 있음(임의 조정 가능)
- 학습 알고리즘의 샘플에 대한 일반화를 위해 조절됨

하이퍼파라미터의 예
- 학습률
- 손실 함수
- 일반화 파라미터
- 미니배치 크기
- 에포크 수
- 가중치 초기화
- 은닉층의 개수
- k-NN의 k값

하이퍼파라미터의 튜닝 기법
- 그리드 탐색
- 랜덤 탐색
- 베이지안 최적화
- 휴리스틱 탐색

정리
- 모델 파라미터는 새로운 샘플이 주어지면 무엇을 예측할지 결정하기 위해 사용하는 것이며 학습 모델에 의해 결정
- 하이퍼파라미터는 학습 알고리즘 자체의 파라미터로 모델이 새로운 샘플에 잘 일반화되도록 하이퍼파라미터들의 최적값을 찾으나, 데이터 분석 결과로 얻어지는 값이 아니므로 절대적인 최적값은 존재하지 않고, 사용자가 직접 설정

https://ittrue.tistory.com/m/42  
[23.06.12 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-%ED%95%98%EC%9D%B4%ED%8D%BC%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0-%ED%8A%9C%EB%8B%9D-%EA%B8%B0%EB%B2%95-%EC%A2%85%EB%A5%98%EB%A5%BC-3%EA%B0%80%EC%A7%80-%EC%9D%B4%EC%83%81-%EC%9D%B4%EC%95%BC%EA%B8%B0%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D)

23.07.15
## Q. 데이터베이스의 트랜잭션에 대해서 설명해주세요.(데이터베이스)

A.  
[23.02.15 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%9D%98-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4)

23.07.16
## Q. CDN이란 무엇인가요?(네트워크)

A.  
[23.03.06 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-cdn%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC)

23.07.17
## Q. 파일접근 방식인 순차접근과 임의접근에 대해 설명해주세요.(운영체제)

A.  
[22.10.06 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-%ED%8C%8C%EC%9D%BC%EC%A0%91%EA%B7%BC-%EB%B0%A9%EC%8B%9D%EC%9D%B8-%EC%88%9C%EC%B0%A8%EC%A0%91%EA%B7%BC%EA%B3%BC-%EC%9E%84%EC%9D%98%EC%A0%91%EA%B7%BC%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)

23.07.19
## Q. 연관 컨테이너의 종류와 각각의 특징에 대해 설명해주세요.(자료구조)

A.  
[22.10.27 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-%EC%97%B0%EA%B4%80-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%9D%98-%EC%A2%85%EB%A5%98%EC%99%80-%EA%B0%81%EA%B0%81%EC%9D%98-%ED%8A%B9%EC%A7%95%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0)

23.07.20
## Q. 힙 정렬(Heap Sort)의 구현 방식, 시간복잡도, 공간복잡도, 장단점에 대해 설명해주세요.(알고리즘)

A.  
[22.10.19 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-%ED%9E%99-%EC%A0%95%EB%A0%ACheap-sort%EC%9D%98-%EA%B5%AC%ED%98%84-%EB%B0%A9%EC%8B%9D-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84-%EA%B3%B5%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84-%EC%9E%A5%EB%8B%A8%EC%A0%90%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)

23.07.21
## Q. 회귀(Regression) 모델의 성과를 측정하는 지표에 대해 설명해주세요.(머신러닝)

A.  
1. MSE(Mean Squared Error: 평균 제곱 오차)
    - 실제값과 예측값의 차이를 제곱해 평균한 것
2. RMSE(Root Mean Squared Error: 평균 제곱근 오차)
    - MSE값은 오류의 제곱을 구하므로, 실제 오류의 평균보다 값이 더 커지는 특성이 있으므로, MSE에 루트를 씌운 것
3. MAE(Mean Absolute Error: 평균 절대 오차)
    - 실제값과 예측값의 차이를 절댓값으로 변환해 평균한 것
4. MAPE(Mean Absolute Percentage Error: 평균 절대비율 오차)
    - MSE, RMSE의 단점을 보완

https://bigdaheta.tistory.com/53

23.07.22
## Q. 트랜잭션의 원자성에 대해서 예를 들어 설명해주세요.(데이터베이스)

A.  
[22.09.22 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98-%EC%9B%90%EC%9E%90%EC%84%B1%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%98%88%EB%A5%BC-%EB%93%A4%EC%96%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)

23.07.23
## Q. 인증과 인가의 차이점에 대해 설명해주세요.(네트워크)

A.  
인증(Authentication)  
- 어떤 개체(사용자 또는 장치)의 신원을 확인하는 과정

인가(Authorization)
- 어떤 개체가 어떤 리소스에 접근할 수 있는지 또는 어떤 동작을 수행할 수 있는지를 검증하는 것, 즉 접근 권한을 얻는 일

인가 vs 인증
- 인증은 인가로 이어지지만 인가는 인증으로 이어지지는 않음
- 신원증명이 접근 권한을 승인하기에 충분하다고해도, 인가가 개체를 식별하는 데 사용할 수 있는 건 아님
- ex) 비행기 탑승권의 경우 본인 확인(인증)과 탑승 허가(인가) 모두 가능하지만, 공연 티켓은 입장 허용(인가)은 되지만 본인 확인(인증)은 안 됨

https://dextto.tistory.com/234

23.07.24
## Q. 멀티프로그래밍과 멀티태스킹의 차이점에 대해 설명해주세요.(운영체제)

A.  
[22.09.27 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EA%B3%BC-%EB%A9%80%ED%8B%B0%ED%83%9C%EC%8A%A4%ED%82%B9%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)

23.07.25
## Q. 컨테이너 어댑터의 종류와 각각의 특징에 대해 설명해주세요.(자료구조)

A.  
[22.12.31 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EC%96%B4%EB%8C%91%ED%84%B0%EC%9D%98-%EC%A2%85%EB%A5%98%EC%99%80-%EA%B0%81%EA%B0%81%EC%9D%98-%ED%8A%B9%EC%A7%95%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0)

23.07.26
## Q. 거품 정렬(Bubble Sort)의 구현 방식, 시간복잡도, 공간복잡도, 장단점에 대해 설명해주세요.(알고리즘)

A.  
[22.10.04 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-%EA%B1%B0%ED%92%88-%EC%A0%95%EB%A0%ACbubble-sort%EC%9D%98-%EA%B5%AC%ED%98%84-%EB%B0%A9%EC%8B%9D-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84-%EA%B3%B5%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84-%EC%9E%A5%EB%8B%A8%EC%A0%90%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)

23.07.27
## Q. Learning rate가 학습에 중요한 이유에 대해 설명해주세요.(머신러닝)

A.  
학습률(Learning rate)  
- 경사하강법 알고리즘은 기울기에 학습률(Learning rate) 또는 보폭(Step size)이라 불리는 스칼라를 곱해 다음 지점을 결정
- Local minimum에 효율적으로 도달할 수 있도록, 너무 크지도 작지도 않은 적절한 학습률을 세팅해야 함
- 학습률이 큰 경우: 데이터가 무질서하게 이탈하며, 최저점에 수렴하지 못함
- 학습률이 작은 경우: 학습시간이 매우 오래 걸리며, 최저점에 도달하지 못함

https://bioinformaticsandme.tistory.com/m/130

23.07.29
## Q. 트랜잭션의 지속성에 대해서 예를 들어 설명해주세요.(데이터베이스)

A.  
트랜잭션(Transaction)  
- 여러 개의 작업을 하나로 묶은 실행 유닛
- 데이터베이스의 상태를 변환시키는 기능을 수행하기 위한 하나 이상의 쿼리를 모아 놓은 하나의 작업 단위
- 각 트랜잭션은 하나의 특정 작업으로 시작해서 묶여 있는 모든 작업을 다 완료해야 정상적으로 종료됨
- 만약 하나의 트랜재겻ㄴ에 속해있는 여러 작업 중 단 하나라도 실패하면, 이 트랜잭션에 속한 모든 작업을 실패한 것으로 판단함
- 작업이 하나라도 실패하면 트랜잭션은 실패, 모든 작업이 성공하면 트랜잭션은 성공
- 성공 또는 실패이며 미완료된 작업이 없어야 함

지속성(Durability)
- 하나의 트랜잭션이 성공적으로 수행되었다면, 해당 트랜잭션에 대한 로그가 남아야 하는 성질
- 만약 런타임 오류나 시스템 오류가 발생하더라도, 해당 기록은 영구적이어야 한다는 의미
- ex)
    - 은행에서 계좌이체를 성공적으로 실행한 뒤에, 해당 은행 데이터베이스에 오류가 발생해 종료되더라도 계좌이체 내역은 기록으로 남아야 함
    - 계좌이체를 로그로 기록하기 전에 시스템 오류 등에 의해 종료가 되면, 해당 이체 내역은 실패로 돌아가고 각 계좌들은 계좌이체 이전 상태로 돌아가게 됨

https://hanamon.kr/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98-acid-%EC%84%B1%EC%A7%88/

23.07.30
## Q. JWT와 OAuth는 무엇이고 어떤 차이가 있을까요?

A.  
JWT(Json Web Token)
- json 객체를 통해 안전하게 정보를 전송하는 웹표준
- '.'을 구분자로 가지며 헤더, 내용, 서명 세 부분의 문자열로 이루어짐
- 헤더는 토큰 타입과 알고리즘, 내용은 실제 전달할 정보, 서명은 위변조를 방지하기 위한 값을 저장
- JSON 객체를 암호화하여 만든 문자열 값으로 위변조가 어렵고 다른 토큰들과 달리 토큰 자체에 데이터를 가지고 있음
- 사용자의 인증 요청 시 필요한 정보를 전달하는 객체로 사용할 수 있음

OAuth(Open Authorization)
- 인터넷 사용자들이 비밀번호를 제공하지 않고 다른 웹사이트 상의 자신들의 정보에 대해 웹사이트나 애플리케이션의 접근 권한을 부여할 수 있는 공통적인 수단으로서 사용되는 접근 위임을 위한 개방형 표준
- 사용자들이 타사 애플리케이션이나 웹사이트의 계정에 관한 정보를 공유할 수 있게 허용함
- 표준화한 인증방식으로, OAuth를 이용하면 이 인증을 공유하는 애플리케이션끼리 별도의 인증이 필요없음

JWT와 OAuth의 차이점
- JWT는 Token의 한 형식안 반면, OAuth는 하나의 Framework
- JWT는 안전한 정보 교환을 위한 토큰 기반의 인증 방식인 반면, OAuth는 웹 서비스 간 사용자 인증 및 권한 부여를 위한 프로토콜

https://lewis-kku.tistory.com/34  
https://lewis-kku.tistory.com/19  
https://ko.wikipedia.org/wiki/OAuth  
ChatGPT 답변

23.07.31
## Q. 기아상태와 교착상태의 차이점에 대해 설명해주세요.(운영체제)

A.  
[22.10.26 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-%EA%B8%B0%EC%95%84%EC%83%81%ED%83%9C%EC%99%80-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C)

23.08.01
## Q. 시퀀스 컨테이너의 조건과 종류, 각각의 특징에 대해 설명해주세요.(자료구조)

A.  
[22.11.01 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q&A%20a%20Day/Notes.md#q-%EC%8B%9C%ED%80%80%EC%8A%A4-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%9D%98-%EC%A1%B0%EA%B1%B4%EA%B3%BC-%EC%A2%85%EB%A5%98-%EA%B0%81%EA%B0%81%EC%9D%98-%ED%8A%B9%EC%A7%95%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0)  
http://www.tcpschool.com/cpp/cpp_container_sequence

23.08.02
## Q. 합병 정렬(Merge Sort)의 구현 방식, 시간복잡도, 공간복잡도, 장단점에 대해 설명해주세요.(알고리즘)

A.  
[22.10.13 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-%ED%95%A9%EB%B3%91-%EC%A0%95%EB%A0%ACmerge-sort%EC%9D%98-%EA%B5%AC%ED%98%84-%EB%B0%A9%EC%8B%9D-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84-%EA%B3%B5%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84-%EC%9E%A5%EB%8B%A8%EC%A0%90%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)

23.08.03
## Q. Batch Gradient Descent, Stochastic Gradient Descent, Mini-batch Gradient Descent 알고리즘의 차이점과 각각의 장단점에 대해 설명해주세요.(머신러닝)

A.  
Batch(배치)  
- 일괄적으로 처리되는 집단. 한 번에 여러 개의 데이터를 묶어서 입력하는 것
- GPU의 병렬 연산 기능을 최대한 효율적으로 사용하기 위해 쓰는 방법
- Iteration 1회당 사용되는 training data set의 묶음
- Iteration: 정해진 batch size를 사용하여 학습(forward-backward)를 반복하는 횟수

Batch Gradient Descent(BGD)  
- 전체 데이터 셋에 대한 에러를 구한 뒤 기울기를 한 번만 계산하여 모델의 parameter를 업데이트 하는 방법
- 전체 데이터에 대해 업데이트가 한 번에 이루어지기 때문에 SGD보다 업데이트 횟수가 적고 전체적인 계산 횟수가 적음
- 한 스텝에 모든 학습 데이터 셋을 사용하므로 학습이 오래 걸림

Stochastic Gradient Descent(SGD)  
- 추출된 데이터 한 개에 대해서 error gradient를 계산하고, Gradient descent 알고리즘을 적용하는 방법
- Shooting이 일어나기 때문에 local optimal에 빠질 리스크가 적고 step에 걸리는 시간이 짧기 때문에 수렴속도가 상대적으로 빠름
- global optimal을 찾지 못할 가능성이 있고 데이터를 한 개씩 처리하기 때문에 GPU의 성능을 전부 활용할 수 없음

Mini-batch Gradient Descent(MBGD)  
- 전체 데이터 셋에서 뽑은 Mini-batch 안의 데이터 m개에 대해서 각 데이터에 대한 기울기를 m개 구한 뒤, 그것의 평균 기울기를 통해 모델을 업데이트 하는 방법
- BGD와 SGD의 장점만 모은 알고리즘으로, 전체 데이터 셋을 여러 개의 mini-batch로 나누어, 한 개의 mini-batch마다 기울기를 구하고 모델을 업데이트 하는 방법
- BGD보다 local optimal에 빠질 리스크가 적고 SGD보다 병렬처리에 유리함
- 전체 학습데이터가 아닌 일부분의 학습데이터만 사용하기 때문에 메모리 사용이 BGD보다 적음
- batch szie(mini-batch size)를 설정해야 함
- 에러에 대한 정보를 mini-batch 크기만큼 축적해서 계산해야 하기에 SGD보다 메모리 사용이 높음

https://light-tree.tistory.com/133

23.08.06
## Q. 스풀링(Spooling)에 대해서 설명해주세요.(운영체제)

A.  
스풀링(Spooling)
- Simultaneous Peripheral Operation On-Line의 약자
- 디스크를 매우 큰 버퍼처럼 사용하는 것
- 입력장치에서 미리 읽어들여 출력장치가 받을 수 있을 때까지 출력 파일을 저장함
- 한 작업의 입출력을 수행하면서 다른 작업의 계산도 할 수 있음
- 많은 작업의 입출력과 계산을 함께 할 수 있고, CPU 대기 시간을 줄일 수 있음

https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=jk130694&logNo=220677926732

23.08.07
## Q. 컨테이너의 종류와 각각의 특징에 대해 아는대로 모두 설명해주세요.(자료구조)

A.  
[22.10.02 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%9D%98-%EC%A2%85%EB%A5%98%EC%99%80-%EA%B0%81%EA%B0%81%EC%9D%98-%ED%8A%B9%EC%A7%95%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%84%EB%8A%94%EB%8C%80%EB%A1%9C-%EB%AA%A8%EB%91%90-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94)

23.08.09
## Q. 삽입 정렬(Insertion Sort)의 구현 방식, 시간복잡도, 공간복잡도, 장단점에 대해 설명해주세요.(알고리즘)

A.  
[22.10.15 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-%EC%82%BD%EC%9E%85-%EC%A0%95%EB%A0%ACinsertion-sort%EC%9D%98-%EA%B5%AC%ED%98%84-%EB%B0%A9%EC%8B%9D-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84-%EA%B3%B5%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84-%EC%9E%A5%EB%8B%A8%EC%A0%90%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)

23.08.11
## Q. 분류(Classification) 모델의 성과를 측정하는 지표에 대해 설명해주세요.(머신러닝)

A.  
1) 정확도(Accuracy)
    - 전체 데이터 중에 정확하게 예측한 데이터의 수
2) 오차 행렬(Confusion Matrix)
    - 분류의 예측 범주와 실제 데이터의 분류 범주를 교차 표(Cross Table) 형태로 정리한 행렬
    - 이진 분류의 예측 오류가 얼마인지와, 어떠한 유형의 예측 오류가 발생하고 있는지 함께 나타냄
3) 정밀도(Precision)
    - 양성으로 판단한 것 중 진짜 양성의 비율
4) 재현율(Recall) = 민감도(Sensitivity)
    - 진짜 양성인 것들 중 올바르게 양성으로 판단한 비율
5) F1 Score
    - 정밀도와 재현율을 결합하여 만든 지표로, 정밀도와 재현율이 어느 한 쪽으로 치우치지 않는 수치를 나타냄

https://bigdaheta.tistory.com/53

23.08.12
## Q. 트랜잭션의 연산 중 ROLLBACK의 개념을 간략히 설명해주세요.(데이터베이스)

A.  
[22.11.28 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98-%EC%97%B0%EC%82%B0-%EC%A4%91-rollback%EC%9D%98-%EA%B0%9C%EB%85%90%EC%9D%84-%EA%B0%84%EB%9E%B5%ED%9E%88-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4)
