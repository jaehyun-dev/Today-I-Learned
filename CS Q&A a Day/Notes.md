22.09.12  
## Q. 라우터의 라우팅 기술인 정적라우팅과 동적라우팅에 대해 설명해주세요.  

A. 정적 라우팅(Static Routing)은 송수신 호스트 사이에서 패킷 전송이 이루어지기 전에 경로 정보를 라우터에 미리 저장하여 중개하는 방식이다. 패킷을 중개하기 위한 최적의 경로 정보는 개별 라우터별로 저장하여 관리하는데, 운용 중인 네트워크 구성에 변화가 생기면 이에 적절하게 대처할 수 없다는 문제점이 있다. 즉, 라우터에 보관된 경로 정보가 고정되어 변화된 정보를 갱신하기가 용이하지 않으며, 특히 네트워크 내부의 혼잡도를 반영할 수 없다.  
  
동적 라우팅(Dynamic Routing)은 라우터에서 사용하는 경로 정보를 네트워크 상황에 따라 적절하게 변경하는 방식으로, 경로 정보의 변경 주기에 따라 계속 보완할 수 있다. 따라서 현재의 네트워크 상황을 고려해 최적 경로 정보를 선택할 수 있지만, 경로 정보를 수집하고 관리하는 등의 복잡한 작업이 추가로 필요하다. 이는 네트워크에 새로운 부하를 가해 성능에 부정적인 영향을 미친다.
  
동적 라우팅 방식을 사용하려면 현재의 네트워크 링크 상태를 점검해 이를 새로운 경로 배정 시 적용해야 한다. 각 라우터에서는 주변 라우터의 존재 유무와 전송 지연 시간 등을 확인할 수 있어야 한다. 또한 각 라우터가 획득한 경로 정보를 다른 라우터에 통보함으로써, 네트워크의 최신 경로 정보를 신속하게 공유하고 갱신해야 한다.
  
[네이버 지식백과] 라우팅

https://m.blog.naver.com/dreamxpeed/221671848467

22.09.13
## Q. 전송계층의 기능 중 멀티플렉싱과 디멀티플렉싱 기술에 대해 설명해주세요.

A. 멀티플렉싱(다중화)은 데이터 전송에서 두 개 이상의 데이터 송신 장치가 각각의 통신로를 갖도록 한 개의 전송 매체를 공유시키는 기능이다. 디멀티플렉싱(역다중화)은 원래의 독립 신호 또는 이들 신호의 군(群)을 복원시키기 위해 다중화된 복합 신호를 분리하여, 원래의 신호 또는 신호의 군으로 복원하는 과정이다.

[네이버 지식백과] 다중화, 역다중화  

https://m.blog.naver.com/kiseop91/221554095982

22.09.14
## Q. 고정IP와 유동IP에 대해서 설명해주세요.

A. **고정 IP 주소**  
공인 IP 주소든 가상 IP 주소든 컴퓨터 등에 IP 주소를 설정하려면, 누군가(주로 서버 시스템)가 IP 주소를 컴퓨터에 배급, 할당해 줘야 한다. 공인 IP 주소라면 해당 인터넷 서비스 업체의 주소 할당 서비스가, 가상 IP 주소라면 인터넷 공유기가 이 역할을 수행한다. 이때 IP 주소를 할당 받는 컴퓨터 등은 이를 자동으로 설정할지, 아니면 수동으로 설정할지를 선택할 수 있다. 고정 IP 주소는 사용자가 직접 IP 주소를 입력해 주소를 설정하는 방식을 말한다. IP 주소가 변경되면 안 되는 컴퓨터(파일 공유 서버 등) 등에 적합한 것으로 일반적으로 특별한 경우 외에는 사용할 기회가 거의 없다. 윈도우의 네트워크 연결 속성 페이지에서 '다음 IP 주소 사용' 옵션을 선택하고, 원하는 IP 주소를 4개 마디에 맞게 입력하면 된다(각 마디는 255를 넘을 수 없다).

**유동 IP 주소**  
IP 주소를 할당하는 특정 서버가 보내 주는 정보 그대로 컴퓨터에 자동 설정되는 방식이다. 이를 'DHCP(Dynamic Host Configuration Protocol)' 서비스라 하는데, 컴퓨터가 부팅하면 DHCP 서버에 IP 주소 할당을 요청하고, 이를 수신한 DHCP 서버가 해당 컴퓨터에 IP 주소 등의 네트워크 정보를 전달하면, 컴퓨터에서는 이를 자동으로 등록, 설정하게 된다. 이 DHCP 서비스는 컴퓨터 수가 많은 환경에서 특히 간편하고 유용하다. 이론적으로 컴퓨터가 매번 부팅할 때마다(즉 IP 할당 요청이 발생할 때마다) IP 주소는 변경되지만, 이전에 할당 받았던 IP 주소 그대로 재할당 받는 경우가 더 많다. 인터넷 공유기는 가상 IP 주소를 생성(NAT 서비스)하여 각 컴퓨터 등에 자동 할당(DHCP 서비스)하는 역할을 동시에 수행하는 것이다.

1. 컴퓨터가 부팅되며 DHCP 서버가 존재함을 탐지한다
2. DHCP 서버는 컴퓨터에 IP 주소 등이 할당되어 있는지 확인한다
3. 컴퓨터가 DHCP 서버에 IP 주소 할당을 요청한다
4. DHCP 서버는 IP 주소 할당 현황에 따라 IP 주소 등의 정보를 컴퓨터에 할당한다

물론 DHCP 서비스를 적용했어도 특정 컴퓨터에 고정 IP 주소를 할당해야 한다면, (앞서 설명한 대로) 윈도우 네트워크 속성 페이지에서 '다음 IP 주소 사용' 설정을 이용하면 된다. 그럼 그 컴퓨터는 IP 주소 자동 할당 목록에서 제외된다.

[네이버 지식백과] IP 주소 - 컴퓨터 네트워크의 전화번호 (용어로 보는 IT, 이문규, IT 동아)

https://yoo11052.tistory.com/32?category=945084

22.09.16
## Q. 버퍼링(Buffering)에 대해서 설명해주세요.

A. 컴퓨터 시스템에서의 처리를 어떤 장치로부터 다른 장치로 데이터를 일방통행으로 전송할 때 양자의 속도차를 수정하기 위하여 중간에서 데이터를 일시적으로 기억 장소에 축적하는 수법. 이 방식에 의하면 고속 중앙 처리 장치(CPU)와 저속 입출력 장치의 작동 속도를 조정할 수 있으며, 컴퓨터 시스템 전체의 처리 능력이 향상된다. 현재 거의 모든 컴퓨터 시스템에서 채용하고 있다.

[네이버 지식백과] 완충(buffering)

https://m.blog.naver.com/jk130694/220677902462

22.09.17
## Q. 선점 스케줄링과 비선점 스케줄링의 차이점에 대해서 설명해주세요.

A. 선점 스케줄링(preemptive scheduling)은 한 프로세스가 중앙 처리 장치(CPU)를 점유했을 때 또 다른 프로세스가 그 CPU를 점유할 수 있도록 하는 것이다. 선점 스케줄링은 높은 우선 순위의 프로세스들이 긴급을 요할 때 유용하며, 대화식 시분할 시스템에서 빠른 응답 시간을 유지하는 데 대단히 중요하다.

비선점 스케줄링(non-preemptive scheduling)은 작업이 프로세스로 생성되어 CPU를 할당받으면 프로세스가 종료되거나 입출력 조작을 위해 자발적으로 중지될 때까지 계속 실행되도록 보장하는 스케줄링 정책이다. 한 프로세스가 일단 CPU를 할당받으면 다른 프로세스가 CPU를 강제로 뺏을 수 없는 방식이다. 비선점 스케줄링은 프로세스 간의 오버헤드(overhead)가 적어 효율적이나, 대화식 시분할 시스템에는 적합하지 않고, 긴 작업이 짧은 작업을 오랫동안 기다리게 되는 경우가 발생되는 단점이 있다.

[네이버 지식백과] 선점 스케줄링, 비선점 스케줄링

https://www.uname.in/m/252

22.09.18
## Q. 데이터베이스의 차수와 카디널리티에 대해서 설명해주세요.

A. **차수**  
하나의 릴레이션에서 속성의 전체 개수를 릴레이션의 차수(degree)라고 한다. 모든 릴레이션은 최소 1 이상의 차수를 유지해야 한다. 릴레이션의 차수는 일반적으로 자주 변하지 않는다는 정적인 특징이 있다.

**카디널리티**  
하나의 릴레이션에서 투플의 전체 개수를 릴레이션의 카디널리티(cardinality)라고 한다. 투플이 없는 릴레이션이 존재할 수도 있다. 새로운 투플이 계속 삽입되거나 기존 투플이 삭제될 수 있으므로 릴레이션의 카디널리티는 일반적으로 자주 변한다는 동적인 특징이 있다.

[네이버 지식백과] 차수, 카디널리티

https://jhnyang.tistory.com/108

22.09.19
## Q. 후보키, 기본키, 대체키의 상관관계에 대해서 설명해주세요.

A. **후보키**(candidate key)는 유일성과 최소성을 만족하는 속성 또는 속성들의 집합이다. 최소성(minimality)은 키를 구성하고 있는 여러 속성 중에서 하나라도 없으면 투플을 유일하게 구별할 수 없는, 꼭 필요한 최소한의 속성들로만 키를 구성하는 특성이다. 그러므로 하나의 속성으로 구성된 키는 당연히 최소성을 만족한다.

릴레이션에서 투플을 구별하기 위해 여러 개의 후보키를 모두 사용할 필요는 없다. 데이터베이스 설계자나 관리자는 여러 후보키 중에서 기본적으로 사용할 키를 반드시 선택해야 하는데 이것이 **기본키**(primary key)다. 만약 후보키가 한 개만 존재하면 당연히 해당 후보키를 기본키로 선택해야 하겠지만 여러 개일 경우에는 데이터베이스 사용 환경을 고려하여 적합한 것을 기본키로 선택하면 된다.

**대체키**(alternate key)는 기본키로 선택되지 못한 후보키들이다. 이름에서 알 수 있듯이 대체키는 기본키를 대신할 수 있지만 기본키가 되지 못하고 탈락한 이유가 있을 수 있다. 따라서 기본키로 선택되지 못한 속성 집합이 대체키가 된다.

![image](https://dbscthumb-phinf.pstatic.net/4515_000_1/20160715112620819_1D1GTA96B.jpg/ka26_87_i1.jpg?type=w406_fst_n&wm=Y)

[네이버 지식백과] 후보키, 기본키, 대체키

https://computer-science-student.tistory.com/195

22.09.20
## Q. 도메인 제약조건에 대해서 설명해주세요.

A.
<li>각 애트리뷰트 값이 반드시 <b>원자값</b>이어야 함</li>
<li>애트리뷰트 값의 디폴트 값, 가능한 값들의 범위 등을 지정할 수 있음</li>
<li>데이터 형식을 통해 값들의 유형을 제한하고, CHECK 제약 조건을 통해 값들의 범위를 제한할 수 있음</li>
<li>SQL2는 도메인을 명시적으로 정의하는 것을 허용하지만, 오라클은 지원하지 않음</li>
<br>
  
https://rainbow97.tistory.com/entry/Database-02-4-%EB%AC%B4%EA%B2%B0%EC%84%B1-%EC%A0%9C%EC%95%BD%EC%A1%B0%EA%B1%B4

22.09.21
## Q. 물리적 데이터베이스의 히프파일과 순차파일에 대해서 설명해주세요.

A. **히프 파일**(Heap File)  
- 삽입된 순서대로 레코드를 파일 내에 배치하는 것으로서 파일의 마지막에 새로운 레코드를 삽입한다.

**순서 파일**Sequential File)  
- 레코드 필드들 중에서 순서 필드라고 하는 한 필드 값의 순서대로 디스크에 물리적으로 정렬할 수 있다.

https://swin9333.tistory.com/65

22.09.22
## Q. 트랜잭션의 원자성에 대해서 예를 들어 설명해주세요.

A. 트랜잭션의 **원자성**(atomicity)은 트랜잭션을 구성하는 연산들이 모두 정상적으로 실행되거나 하나도 실행되지 않아야 한다는 all-or-nothing 방식을 의미한다. 만약 트랜잭션을 수행하다가 장애가 발생하여 작업을 완료하지 못했다면, 지금까지 실행한 연산들 모두 처리를 취소하고 데이터베이스를 트랜잭션 작업 전의 상태로 되돌려 트랜잭션의 원자성을 보장해야 한다. 트랜잭션의 원자성을 보장하면 트랜잭션을 구성하는 연산 중 일부만 처리한 결과를 데이터베이스에 반영하는 일이 없게 된다.

[네이버 지식백과] 원자성

https://hanamon.kr/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98-acid-%EC%84%B1%EC%A7%88/

22.09.23  
## Q. SQL조건절에 사용되는 ANY / ALL 의 차이를 설명해주세요.

A. **ANY 연산자**는 주로 서브쿼리에 사용되며 하나라도 만족하는 값이 있다면 true를 반환한다.

**ALL 연산자**는 전체 만족해야 true를 반환하는 특징을 가지고 있다.

https://lhoris.tistory.com/136 

22.09.25
## Q. 현재 레코드에 공유로크가 걸려있는 경우 해당 레코드에 공유로크와 독점로크를 요청했을 때 결과를 설명해주세요.

A. 공유로크가 걸려있는 경우, 공유로크를 요청하면 허용하게 되고, 독점로크를 요청하면 대기하게 된다.

https://velog.io/@chez_kwak/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-9.-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98

22.09.26
## Q. WAL이 무엇이고 왜 필요한지 설명해주세요.

A. **WAL**(Write-Ahead-Logging)
- WAL이란 Write-Ahead Logging의 약자로 로그 선행 기입
- WAL을 사용하는 시스템에서 모든 수정은 적용을 하기 전에 먼저 로그에 기록된다.
- 트랜잭션 발생시 로그에 일단 기입하여 기록을 남기고, 특정 데이터가 쌓이면 이를 flush 해 DB의 disk에 DATA BLOCK 형태로 write하게 된다.
- 일단 Log에 적히게 되면 누가 조회를 하던간에 같은 데이터를 보여주는 일관성 (Consistency)을 보장하게 되고 서버가 다운되도 이미 Log에 기입되어 있기 때문에 원자성 (Atomicity)도 보장할 수 있다.
- REDO 및 UNDO 정보를 모두 로그에 기록하며, buffer를 비우기 전에 로그파일에 기록

https://nays111.tistory.com/12

22.09.27
## Q. 멀티프로그래밍과 멀티태스킹의 차이점에 대해 설명해주세요.

A. **멀티 프로그래밍** (Multi-programming)  
초기의 컴퓨터에서는 하나의 프로그램이 메모리에 올라가면 하나의 프로그램만 CPU가 처리를 진행할 수 있었다. 이 과정에서 프로세서의 처리 속도와 입출력 속도 간의 차이로 인해, 입출력이 완료될 때까지 프로세서는 idle한 상태가 된다. 따라서 이는 프로세서의 자원 낭비로 이루어진다.  
프로세서가 입출력 작업의 종료를 대기할 동안 하나의 프로세서에서 다른 프로그램을 수행할 수 있도록 하는 것이 멀티프로그래밍이다.

**멀티 태스킹** (Multi-tasking)  
Task란 운영체제에서 처리하는 작업의 단위 또는 정해진 일을 수행하기 위한 명령어 집합을 뜻하는데 (process 보다 확장된 개념), 멀티 태스킹은 task를 OS의 스케쥴링에 의해 task를 번갈아가며 수행하는 것을 의미한다.  
여러개의 task를 자주 번갈아가며 수행하다보니 사용자는 동시에 여러 task가 수행되고 있다고 느끼게 된다.

https://velog.io/@chy0428/OS-%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EC%84%B8%EC%8B%B1

22.09.28
## Q. 다섯 가지 점근 표기법에 대해 설명해주세요.

A.  
| 표기법 |         대략적 의미        |
|:------:|:--------------------------:|
| f=ω(g) |     f는 g보다 크다, f>g    |
| f=Ω(g) | f는 g보다 크거나 같다, f≥g |
| f=Θ(g) |   f는 g와 대략 같다, f=g   |
| f=O(g) | f는 g보다 작거나 같다, f≤g |
| f=o(g) |     f는 g보다 작다, f<g    |

https://ratsgo.github.io/data%20structure&algorithm/2017/09/13/asymptotic/

22.09.29
## Q. 데드락(Deadlock) 회피 기법인 은행원 알고리즘에 대해 설명해주세요.

A. **데드락**(교착상태) 회피는 데드락이 빠질 가능성이 있는지 없는지 운영체제가 검사하고 빠질 가능성이 없을 경우에만 자원을 할당함으로써 문제 발생을 피하는 방법이다.

데드락 회피 기법 중 하나인 **은행원 알고리즘**은, 교착상태에 빠질 가능성이 있는지 판단하기 위해 상태를 '안전상태(safe state)'와 '불안전상태(unsafe state)'로 나누고, 안전상태를 유지할 수 있는 요구만을 수락하고 불안전 상태를 초래할 사용자의 요구는 나중에 만족될 수 있을 때까지 계속 거절하는 알고리즘이다.

https://jhnyang.tistory.com/102

22.09.30
## Q. 인터럽트(interrupt)의 정의와 종류에 대해 설명해주세요.

A.  
정의: 프로그램을 실행하는 도중에 예기치 않은 상황이 발생할 경우 현재 실행 중인 작업을 즉시 중단하고, 발생된 상황에 대한 우선 처리가 필요함을 CPU에게 알리는 것.  
지금 수행 중인 일보다 더 중요한 일(ex. 입출력, 우선 순위 연산 등)이 발생하면 그 일을 먼저 처리하고 나서 하던 일을 계속해야 한다.

종류: 외부 인터럽트, 내부 인터럽트, 소프트웨어 인터럽트

https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/Interrupt.md

22.10.01
## Q. 2단계 로킹 프로토콜에 대해서 설명해주세요.

A. 기본 로킹 규약의 문제를 해결하고 트랜잭션의 직렬 가능성을 보장하기 위해 lock과 unlock 연산의 수행 시점에 대한 새로운 규약을 추가한 것이 **2단계 로킹 규약**(2PLP;2 Phase Locking Protocol)이다. 트랜잭션 스케줄의 모든 트랜잭션이 2단계 로킹 규약을 준수하면 해당 스케줄은 직렬 가능성이 보장된다.

[네이버 지식백과] 2단계 로킹 규약

https://noil0816.tistory.com/153

22.10.02
## Q. 컨테이너의 종류와 각각의 특징에 대해 아는대로 모두 설명해주세요.

A.
- 시퀀스 컨테이너: 데이터를 선형적으로 저장하고 삽입된 요소의 순서가 그대로 유지된다.
- 연관 컨테이너: 관련있는 데이터를 하나의 쌍으로 저장하는 컨테이너로 보통 균형 이진 트리나 해시 테이블을 사용하여 구현된다.
- 어댑터 컨테이너: 기존 커너테이너의 인터페이스를 제한하거나 변형하여 만든 컨테이너로 반복자를 지원하지 않아 STL 알고리즘을 이요할 수 없다.

https://techbless.github.io/2020/11/04/C-STL-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EC%9A%94%EC%95%BD-%EC%A0%95%EB%A6%AC/

22.10.04
## Q. 거품 정렬(Bubble Sort)의 구현 방식, 시간복잡도, 공간복잡도, 장단점에 대해 설명해주세요.

A.  
구현 방식:
1. 1회전에 첫 번째 원소와 두 번째 원소를, 두 번째 원소와 세 번째 원소를, 세 번째 원소와 네 번째 원소를, … 이런 식으로 (마지막-1)번째 원소와 마지막 원소를 비교하여 조건에 맞지 않는다면 서로 교환한다.
2. 1회전을 수행하고 나면 가장 큰 원소가 맨 뒤로 이동하므로 2회전에서는 맨 끝에 있는 원소는 정렬에서 제외되고, 2회전을 수행하고 나면 끝에서 두 번째 원소까지는 정렬에서 제외된다. 이렇게 정렬을 1회전 수행할 때마다 정렬에서 제외되는 데이터가 하나씩 늘어난다.

시간복잡도: O(n^2)

공간복잡도: O(n)

장점:  
- 구현이 매우 간단하고, 소스코드가 직관적이다.
- 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않다. => 제자리 정렬(in-place sorting)
- 안정 정렬(Stable Sort) 이다.

단점:  
- 시간복잡도가 최악, 최선, 평균 모두 O(n^2)으로, 굉장히 비효율적이다.
- 정렬 돼있지 않은 원소가 정렬 됐을때의 자리로 가기 위해서, 교환 연산(swap)이 많이 일어나게 된다.

https://gyoogle.dev/blog/algorithm/Bubble%20Sort.html

22.10.05
## Q. 단일 연결리스트에서 중간 삽입과 삭제를 O(n)이 아니라 $\Theta$(1)로 만들 수 있는 이유에 대해 설명해주세요.

A. 삽입 시에는 새로운 노드를 만들고 앞 노드의 주소칸만 수정하면 되고, 삭제 시에는 원하는 노드를 삭제하고 앞 노드의 주소칸만 수정하면 되기 때문이다.

https://gusdnd852.tistory.com/100

22.10.06
## Q. 파일접근 방식인 순차접근과 임의접근에 대해 설명해주세요.

A. **순차 접근(Sequential Access)**  
원하는 레코드를 찾기 위해 파일의 현재 위치에서 차례대로 탐색을 실시하는 접근 방법이다. 특별한 구현이 없다면, 레코드를 접근할 때마다 디스크를 물리적으로 움직여야하기 때문에 매우 비효율적이다.

**임의 접근(Random Access)**  
시스템이나 프로그래머가 원하는 위치부터 파일을 읽는 접근 방법이다. 5번 레코드를 접근하기 위해 1, 2, 3, 4, 5 레코드를 모두 접근하는 것이 아니라 5번 레코드를 바로 접근하기 때문에 직접 접근(direct access)라고도 한다. 단 한번의 디스크 접근을 통해 레코드에 접근하기 때문에 항상 순차 접근보다 성능이 좋거나 같다.

https://untitledtblog.tistory.com/64

22.10.07
## Q. 퀵 정렬(Quick Sort)의 구현 방식, 시간복잡도, 공간복잡도, 장단점에 대해 설명해주세요.

A.
구현 방식:  
1. 배열 가운데서 하나의 원소를 고른다. 이렇게 고른 원소를 피벗(pivot) 이라고 한다.
2. 피벗 앞에는 피벗보다 값이 작은 모든 원소들이 오고, 피벗 뒤에는 피벗보다 값이 큰 모든 원소들이 오도록 피벗을 기준으로 배열을 둘로 나눈다. 이렇게 배열을 둘로 나누는 것을 분할(Divide) 이라고 한다. 분할을 마친 뒤에 피벗은 더 이상 움직이지 않는다.
3. 분할된 두 개의 작은 배열에 대해 재귀(Recursion)적으로 이 과정을 반복한다.

시간복잡도: 평균 O(nlog₂n), 최악의 경우 O( $n^2$ )

공간복잡도: O(n)

장점:
- 불필요한 데이터의 이동을 줄이고 먼 거리의 데이터를 교환할 뿐만 아니라, 한 번 결정된 피벗들이 추후 연산에서 제외되는 특성 때문에, 시간 복잡도가 O(nlog₂n)를 가지는 다른 정렬 알고리즘과 비교했을 때도 가장 빠르다.
- 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않는다.

단점:
- 불안정 정렬(Unstable Sort) 이다.
- 정렬된 배열에 대해서는 Quick Sort의 불균형 분할에 의해 오히려 수행시간이 더 많이 걸린다.

https://www.google.com/search?q=quick+sort+time+complexity&oq=quick+sort+time+&sourceid=chrome&ie=UTF-8


22.10.08
## Q. List, Set, Map의 차이점에 대해 설명해주세요.

A.
1. List: 저장공간이 필요에 의해 자동으로 늘어난다(순서가 있는 저장공간)
- 특징: 순서가 있고, 중복을 허용(배열과 유사)
- 장점: 가변적인 배열(배열이 자동으로 늘어남)
- 단점: 원하는 데이터가 뒤쪽에 위치하는 경우 속도가 느림
- 방식: equals()를 이용한 데이터 검색

2. Set: 집합. 순서가 없다. 집합이므로 중복된 데이터가 들어갈 수 없다. 중복되지 않는 숫자(데이터)를 구할 때 사용하면 유용하다.
- 특징: 순서가 없고, 중복을 허용하지 않는다.
- 장점: 빠른 속도
- 단점: 단순 집합의 개념으로 정렬하려면 별도의 처리가 필요하다.

3. Map: 키와 데이터를 같이 저장
- 특징: Key(키)와 Value(값)으로 나눠서 데이터 관리. 순서는 없으며, 키에 대한 중복은 없음
- 장점: 빠른 속도
- 단점: Key의 검색 속도에 의해 속도가 좌우

https://milkoon1.tistory.com/44

22.10.09
## Q. 기아상태를 설명하는 식사하는 철학자 문제에 대해 설명해주세요.(운영체제)

A. 식사하는 철학자들 문제는 전산학에서 동시성과 교착 상태를 설명하는 예시로, 여러 프로세스가 동시에 돌아갈 때 교착 상태가 나타나는 원인을 직관적으로 알 수 있다.  
다섯 명의 철학자가 원탁에 앉아 있고, 각자의 앞에는 스파게티가 있고 양옆에 젓가락이 한 짝씩 있다. 그리고 각각의 철학자는 다른 철학자에게 말을 할 수 없다. 이때 철학자가 스파게티를 먹기 위해서는 양 옆의 젓가락 짝을 동시에 들고 있어야 한다. 이때 각각의 철학자가 왼쪽의 젓가락 짝을 들고 그 다음 오른쪽의 젓가락 짝을 들어서 스파게티를 먹는 알고리즘을 가지고 있으면, 다섯 철학자가 동시에 왼쪽의 젓가락 짝을 든 다음 오른쪽의 젓가락 짝을 들 때까지 무한정 기다리는 교착 상태에 빠지게 될 수 있다.  
또한 어떤 경우에는 동시에 젓가락 양짝을 집을 수 없어 식사를 하지 못하는 기아 상태가 발생할 수도 있고, 몇몇 철학자가 다른 철학자보다 식사를 적게 하는 경우가 발생하기도 한다.

https://starbirds.tistory.com/68

22.10.10
## Q. 삽입 정렬(Insertion Sort)의 구현 방식, 시간복잡도, 공간복잡도, 장단점에 대해 설명해주세요.

A.  
- 구현 방식  
1. 정렬은 2번째 위치(index)의 값을 temp에 저장한다.
2. temp와 이전에 있는 원소들과 비교하여 삽입해나간다.
3. '1'번으로 돌아가 다음 위치(index)의 값을 temp에 저장하고, 반복한다.
- 시간복잡도: 최선의 경우 O(n), 평균과 최악의 경우 O( $n^2$ )
- 공간복잡도: O(n)
- 장점:
  - 알고리즘이 단순하다.
  - 대부분의 원소가 이미 정렬되어 있는 경우, 매우 효율적일 수 있다.
  - 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않는다. → 제자리 정렬(in-place sorting)
  - 안정 정렬(Stable Sort)이다.
  - Selection Sort나 Bubble Sort과 같은 O( $n^2$ ) 알고리즘에 비교하여 상대적으로 빠르다.
- 단점:
  - 평균과 최악의 시간복잡도가 O( $n^2$ )으로 비효율적이다.
  - Bubble Sort와 Selection Sort와 마찬가지로, 배열의 길이가 길어질수록 비효율적이다.  

https://gyoogle.dev/blog/algorithm/Insertion%20Sort.html

22.10.11
## Q. 단일 연결리스트와 원형 연결리스트를 구별하는 방법에 대해 설명해주세요.

A.  
- 단순 연결 리스트와 다르게 원형 연결 리스트는 꼬리가 머리를 가리키는 구조
- 단순 연결 리스트에서 꼬리가 머리를 가리키게만 하면 됨
  - 단순 연결 리스트의 마지막 노드는 NULL을 가리킴
  - 원형 연결 리스트의 마지막 노드는 첫 번째 노드를 가리킴

https://seongkyun.github.io/data_structure/2019/03/20/data_structure/

22.10.12
## Q. IPC(Inter-Process Communication)가 무엇인가요?

A. 프로세스들 사이의 통신 기법으로서 크게 공유 기억 장치 기법과 메시지 시스템 기법이 있다. 공유 기억 장치 기법은 통신하는 프로세스들 사이에 어떤 변수를 공유하고 이 공유 변수를 이용해서 정보를 교환하도록 한다. 메시지 시스템 방법은 통신을 제공하는 책임을 운영 체제가 가지고 프로세스가 메시지를 교환할 수 있게 한다.  

[네이버 지식백과] 프로세서 간 통신(interprocessor communication)

https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/IPC(Inter%20Process%20Communication).md

22.10.13
## Q. 합병 정렬(Merge Sort)의 구현 방식, 시간복잡도, 공간복잡도, 장단점에 대해 설명해주세요.(알고리즘)

A. 병합 정렬이라고도 부르며, 분할 정복 방법을 통해 구현. 빠른 정렬로 분류되며, 퀵소트와 함께 많이 언급되는 정렬 방식이다.  
구현 방식:
1. 리스트를 반으로 나눈다
2. 왼쪽 리스트와 오른쪽 리스트를 각각 정렬한다
3. 정렬된 두 리스트를 하나의 정렬된 리스트로 합병한다.  

시간복잡도: 평균 Θ(nlogn), 최악 O(nlogn)  
공간복잡도: O(n)  
장점: 길이가 긴 리스트에서 다른 정렬 방식보다 빠르게 동작한다.  
단점: 이미 정렬이 되어있어도 전체 과정을 진행해야 한다.

https://gyoogle.dev/blog/algorithm/Merge%20Sort.html

22.10.14
## Q. 큐에 비해 원형큐가 가지는 장단점을 설명해주세요.(자료구조)

A. 장점: 데이터를 출력한 영역을 재사용할 수 없다는 선형큐의 단점을 해결할 수 있다.  
단점: 큐의 길이만큼의 원소를 저장할 수 있기 때문에, 원형큐의 사이즈를 미리 알고 있어야 한다.

https://reakwon.tistory.com/30

22.10.15
## Q. 삽입 정렬(Insertion Sort)의 구현 방식, 시간복잡도, 공간복잡도, 장단점에 대해 설명해주세요.(알고리즘)

A.  
구현 방식: 2번째 원소부터 시작하여 그 앞(왼쪽)의 원소들과 비교하여 삽입할 위치를 지정한 후, 원소를 뒤로 옮기고 지정된 자리에 자료를 삽입하여 정렬하는 알고리즘.
1. 정렬은 2번째 위치(index)의 값을 temp에 저장한다.
2. temp와 이전에 있는 원소들과 비교하며 삽입해나간다.
3. '1'번으로 돌아가 다음 위치(index)의 값을 temp에 저장하고, 반복한다.

시간복잡도: O( $n^2$ )

공간복잡도: O(n)

장점:
- 알고리즘이 단순하다.
- 대부분의 원소가 이미 정렬되어 있는 경우, 매우 효율적일 수 있다.
- 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않는다. -> 제자리 정렬(in-place sorting)
- 안정 정렬(stable sort)이다.
- Selection Sort나 Bubble Sort과 같은 O( $n^2$ ) 알고리즘에 비교하여 상대적으로 빠르다.

단점:
- 평균과 최악의 시간복잡도가 O( $n^2$ )으로 비효율적이다.
- Bubble Sort와 Selection Sort와 마찬가지로, 배열의 길이가 길어질수록 비효율적이다.

https://gyoogle.dev/blog/algorithm/Insertion%20Sort.html

22.10.17
## Q. 최소 스패닝 트리(Minimum Spanning Tree)의 개념과 특징, 사용 사례에 대해 설명해주세요.(알고리즘)

A. 한 그래프의 스패닝 트리들 중에서 가중값의 합이 가장 작은 것.  
모든 꼭지점을 연결하면서 사이클이 생기지 않는 모든 가능한 스패닝 트리 중에서 간선의 가중치 합이 최소가 된다.  
통신 회사에서 케이블을 매설하려고 할 때, 집을 꼭짓점으로, 케이블을 간선으로, 케이블 매설 비용을 가중치로 하는 그래프를 생각하면, 최소 스패닝 트리가 통신 회사 입장에서 가장 경제적인 방법이 된다.

[네이버 지식백과] 최소 스패닝 트리  
[Wikipedia] Minimun spanning tree

22.10.18
## Q. Race Condition이란 무엇인가요?(운영체제)

A. 두 개 이상의 프로세스가 공통 자원을 병행적으로(concurrently) 읽거나 쓸 때, 공용 데이터에 대한 접근이 어떤 순서에 이루어졌는지에 따라 그 실행 결과가 달라지는 상황.

https://drehzr.tistory.com/m/87

22.10.19
## Q. 힙 정렬(Heap Sort)의 구현 방식, 시간복잡도, 공간복잡도, 장단점에 대해 설명해주세요.(알고리즘)

A. 구현 방식:  
1. 완전이진 트리로 정렬할 원소들을 최대 힙 트리로 구성한다.
2. 원소 하나씩 추출(삭제)하여 배열의 뒤부터 저장한다.
3. 최댓값부터 삭제되며, 삭제되는 순서로 정렬된다.

시간복잡도: O(nlogn)

공간복잡도: O(nlogn)

장점: 항상 O(nlogn)이라는 시간 복잡도를 가져 효율적이다.

단점: 불안정 정렬이다. 이상적일 경우에 퀵정렬보다 느리다. 데이터 상태에 따라 다른 정렬에 비해 느린 편이다.

[네이버 지식백과] 힙 정렬

https://velog.io/@jaeyunn_15/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B0%81-%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B9%84%EA%B5%90

https://gyoogle.dev/blog/algorithm/Heap%20Sort.html

22.10.20
## Q. 모바일 기기용 주소록에 BST와 HashTable 중 어떤 자료구조를 사용하는 것이 좋은가요? 이유와 함께 설명해주세요.(자료구조)

A. 모바일 기기용 주소록을 위해서는 이진 탐색 트리(Binary Search Tree, BST)를 사용하는 것이 해시 테이블(Hash Table)을 사용하는 것보다 좋다. 해시 테이블은 서로 다른 두 개의 키값이 해시 함수에 의해 같은 해시값으로 변환되는 해시 충돌이 일어날 수 있다. 이진 탐색 트리는 범위 기반 쿼리가 가능하다. 또한 메모리 효율 측면에서도 이진 탐색 트리가 더 유리하다.

https://algorfati.tistory.com/123

https://adevspoon.com/?code=CraoR_VdQ88QEcGkHil4mvWlchcI-MEvvCJHnyFcBLjvVPro7wvnxFb3iVtr3XPQrmViMAo9dJkAAAGD9Zmmqw

22.10.21
## Q. 내부 단편화와 외부 단편화의 차이점에 대해 설명해주세요.

A.  
내부 단편화: 기억 장치가 의도된 바 없이 할당될 때 일어난다. 공간이 낭비된다. "내부"라는 용어는 필요 없는 기억 자료가 할당된 영역 안에 있지만 쓰이지 않는 것을 말한다. 운영체제의 메모리 관리기법 중 페이징을 이용할 때 발생할 수 있다. 일정 크기의 페이지에 프로세스 할당시, 프로세스의 크기가 페이지보다 작을 경우 내부 단편화가 발생한다.  
외부 단편화: 여유 공간이 여러 조각으로 나뉘는 현상을 말한다. 프로그램이 다양한 크기의 기억 장소의 남은 영역을 할당하고 할당을 해제할 때 일어나며, 할당 알고리즘이 약화된다. 비록 남은 기억 공간을 사용할 수 있지만, 조각이 너무 작게 나 있어서 응용 프로그램의 성능을 뒷받쳐 주지 못하기 때문에 효과적으로 사용하지 못하게 된다. "외부"라는 용어는 사용할 수 없는 기억 장소가 할당된 영역 밖에 있다는 것을 뜻한다.

[위키백과] 단편화  

https://m.blog.naver.com/rbdi3222/220623825770

22.10.22
## Q. 크루스칼 알고리즘(Kruskal's Algorithm)에 대해 설명해주세요.(알고리즘)

A. 그래프 내의 모든 정점들을 가장 적은 비용으로 연결하기 위해 사용되는 최소 신장 트리 알고리즘. 그래프 간선들을 가중치의 오름차순으로 정렬해 놓은 뒤, 사이클을 형성하지 않는 선에서 정렬된 순서대로 간선을 선택한다.

https://chanhuiseok.github.io/posts/algo-33/

22.10.23
## Q. Red-Black Tree에 대해 설명해주세요.(자료구조)

A. 레드-블랙 트리(Red-Black Tree)는 이진 트리의 특수한 형태로서, 컴퓨터 공학 분야에서 숫자 등의 비교 가능한 자료를 정리하는 데 쓰이는 자료구조이다. 레드-블랙 트리에서는 리프 노드들은 비어있고, 자료를 가지고 있지 않다. 레드-블랙 트리는 각각의 노드가 레드나 블랙인 색상 속성을 가지고 있다. 이진 탐색 트리가 가지고 있는 일반적인 조건에 다음과 같은 추가적인 조건을 만족하면 레드-블랙 트리가 된다.

1. 노드는 레드 혹은 블랙 중의 하나이다.
2. 루프 노드는 블랙이다.
3. 모든 리프 노드들(NIL)은 블랙이다.
4. 레드 노드의 자식노드 양쪽은 언제나 블랙이다. (즉, 레드 노드는 연달아 나타날 수 없으며, 블랙 노드만이 레드 노드의 부모 노드가 될 수 있다.)
5. 어떤 노드로부터 시작되어 그에 속한 하위 리프 노드에 도달하는 모든 경로에는 리프 노드를 제외하면 모두 같은 개수의 블랙 노드가 있다.

위 조건들을 만족하게 되면, 레드-블랙 트리는 가장 중요한 특성을 나타내게 된다: 루트 노드부터 가장 먼 잎노드 경로까지의 거리가, 가장 가까운 잎노드 경로까지의 거리의 두 배보다 항상 작다. 다시 말해서 레드-블랙 트리는 개략적으로 균형이 잡혀 있다. 따라서 삽입, 삭제, 검색 시 최악의 경우에서의 시간복잡도가 트리의 높이에 따라 결정되기 때문에 보통의 이진 탐색 트리에 비해 효율적이라고 할 수 있다.

[위키백과] 레드-블랙 트리

https://blogshine.tistory.com/102

22.10.24
## Q. RDBMS와 Nospl의 차이점을 설명해주세요.(데이터베이스)

A.  
관계형 데이터베이스(RDBMS)는 정해진 스키마에 따라 데이터를 저장해야 하므로 명확한 데이터 구조를 보장한다는 장점이 있는 반면, 테이블 간 관계를 맺고 있어 시스템이 커질 경우 JOIN문이 많은 복잡한 쿼리가 만들어질 수 있고, 성능 향상을 위해서는 서버의 성능을 향상시키는 Scale-up만을 지원하기에 비용이 기하급수적으로 늘어날 수 있으며, 스키마로 인해 데이터가 유연하지 못하고 스키마가 변경될 경우 번거롭고 어렵다는 단점이 있다.  
Nosql(Not Only SQL)은 스키마가 없기 때문에 유연하고 자유로운 데이터 구조를 가질 수 있으므로 언제든 저장된 데이터를 조정하고 새로운 필드를 추가할 수 있으며, 데이터 분산이 용이하며 성능 향상을 위한 Scale-up 뿐만이 아닌 Scale-out 또한 가능하다는 장점이 있는 반면, 데이터 중복이 발생할 수 있으며 중복된 데이터가 변경될 경우 수정을 모든 컬렉션에서 수행해야 하고, 스키마가 존재하지 않기에 명확한 데이터 구조를 보장하지 않으며 데이터 구조 결정이 어려울 수 있다는 단점이 있다.

https://khj93.tistory.com/entry/Database-RDBMS%EC%99%80-NOSQL-%EC%B0%A8%EC%9D%B4%EC%A0%90#:~:text=NoSQL%EC%9D%B4%EB%9E%80(Not%20Only%20SQL,%EA%B4%80%EA%B3%84%EB%A5%BC%20%EC%A0%95%EC%9D%98%ED%95%98%EC%A7%80%20%EC%95%8A%EC%8A%B5%EB%8B%88%EB%8B%A4.

22.10.25
## Q. 선택 정렬(Selection Sort)의 구현 방식, 시간복잡도, 공간복잡도, 장단점에 대해 설명해주세요.(알고리즘)

A.  
구현 방식:
1. 주어진 배열 중에 최솟값을 찾는다.
2. 그 값을 맨 앞에 위치한 값과 교체한다.
3. 맨 처음 위치를 뺀 나머지 배열을 같은 방법으로 교체한다.

시간복잡도: O( $n^2$ )

공간복잡도: O(n)

장점: 알고리즘이 단순하다, 많은 교환이 일어나야 하는 자료상태에서 비교적 효율적이다, 다른 메모리 공간을 필요로 하지 않는다.

단점: 시간복잡도 측면에서 비효율적이다, 불안정 정렬이다.

https://gyoogle.dev/blog/algorithm/Selection%20Sort.html

22.10.26
## Q. 기아상태와 교착상태의 차이점에 대해 설명해주세요.(운영체제)

A. 교착 상태는 프로세스가 실행을 위해 진행되지 않고 각 프로세스가 다른 프로세스에 의해 획득된 리소스를 기다리는 조건인 반면 기아 상태에서는 우선순위가 높은 프로세스가 우선순위가 낮은 프로세스를 방지하는 리소스를 지속적으로 사용하여 리소스를 확보한다.

https://ko.gadget-info.com/difference-between-deadlock

22.10.27
## Q. 연관 컨테이너의 종류와 각각의 특징에 대해 설명해주세요.(자료구조)

A.  
**연관 컨테이너**(associate container)는 키(key)와 값(value)처럼 관련있는 데이터를 하나의 쌍으로 저장하는 컨테이너이다. 키와 값을 이용한 연관 컨테이너는 요소들에 대한 빠른 접근을 제공해준다. 하지만 연관 컨테이너는 삽입되는 요소의 위치를 지정할 수는 없다. 이러한 연관 컨테이너는 보통 균형 잡힌 이진 탐색 트리(balanced binary search tree)나 해시 테이블(hash table)을 이용하여 구현한다.  

종류:
1. set: 집합(set) 컨테이너는 저장하는 데이터 그 자체를 키로 사용하는 가장 단순한 연관 컨테이너이다. 검색 속도가 매우 빠르다. 키의 중복을 허용하지 않는다.
2. multiset: 키의 중복을 허용하므로, 같은 값을 여러 번 저장할 수 있다.
3. map: 맵(map) 컨테이너는 키와 값의 쌍으로 데이터를 관리하는 진정한 연관 컨테이너이다. 검색 속도가 매우 빠르다. 키의 중복을 허용하지 않는다.
4. multimap: 값의 중복을 허용하므로, 하나의 키가 여러 개의 값과 연관될 수 있다.

http://www.tcpschool.com/cpp/cpp_container_associate

22.10.28
## Q. 쉘 정렬(Shell Sort)의 구현 방식, 시간복잡도, 공간복잡도, 장단점에 대해 설명해주세요.(알고리즘)

A. 구현 방식:
1. 일정한 간격으로 배열을 분류한다.
2. 연속적이지 않은 여러 부분 배열을 생성한다.
3. 각 부분 배열에 삽입 정렬을 이용하여 정렬한다.
4. 모든 부분 배열이 정렬되면 다시 전체 배열을 부분 배열로 만들며 반복한다.(부분 배열로 나눌 때 간격은 홀수가 좋으나, 짝수가 나오면 +1을 해서 홀수로 만든다.)
5. 부분 배열의 개수가 1이 될 때까지 반복한다.

시간복잡도: 평균 O( $n^1.5$ ), 최악 O( $n^2$ )

공간복잡도: O(n)

장점: 버블정렬보다 빠르다.

단점: 구조가 복잡하고 이해하기 어렵다.

[네이버 지식백과, 위키백과] 쉘 정렬

https://yabmoons.tistory.com/247

22.10.29
## Q. Array와 ArrayList의 차이점에 대해 설명해주세요.(자료구조)

A.  
Array는 고정 길이이다. 따라서, 정해진 길이의 배열을 모두 채우면, 새로운 데이터를 추가하고 싶을 경우 새로운 배열을 만들어주어야 한다.  
ArrayList는 가변 길이이다. 하지만 내부적으론 배열로 구성되어 있다.  

https://velog.io/@humblechoi/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-Array-vs-ArrayList

22.10.30
## Q. Race Condition이 발생하는 경우는 언제인가요?(운영체제)

A.
## [OS] Race Condition

공유 자원에 대해 여러 프로세스가 동시에 접근할 때, 결과값에 영향을 줄 수 있는 상태

> 동시 접근 시 자료의 일관성을 해치는 결과가 나타남

<br>

#### Race Condition이 발생하는 경우

1. ##### 커널 작업을 수행하는 중에 인터럽트 발생

   - 문제점 : 커널모드에서 데이터를 로드하여 작업을 수행하다가 인터럽트가 발생하여 같은 데이터를 조작하는 경우
   - 해결법 : 커널모드에서 작업을 수행하는 동안, 인터럽트를 disable 시켜 CPU 제어권을 가져가지 못하도록 한다.

2. ##### 프로세스가 'System Call'을 하여 커널 모드로 진입하여 작업을 수행하는 도중 문맥 교환이 발생할 때

   - 문제점 : 프로세스1이 커널모드에서 데이터를 조작하는 도중, 시간이 초과되어 CPU 제어권이 프로세스2로 넘어가 같은 데이터를 조작하는 경우 ( 프로세스2가 작업에 반영되지 않음 )
   - 해결법 : 프로세스가 커널모드에서 작업을 하는 경우 시간이 초과되어도 CPU 제어권이 다른 프로세스에게 넘어가지 않도록 함

3. ##### 멀티 프로세서 환경에서 공유 메모리 내의 커널 데이터에 접근할 때

   - 문제점 : 멀티 프로세서 환경에서 2개의 CPU가 동시에 커널 내부의 공유 데이터에 접근하여 조작하는 경우
   - 해결법 : 커널 내부에 있는 각 공유 데이터에 접근할 때마다, 그 데이터에 대한 lock/unlock을 하는 방법

https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/Race%20Condition.md#os-race-condition

22.10.31
## Q. 그리디 알고리즘(Greedy Algorithm)이 무엇인지 설명하고 그리디 알고리즘의 종류에 대해 아는 대로 이야기해주세요.(알고리즘)

A. 그리디 알고리즘이란 현재 상황에서 가장 좋은 것(최선의 선택)을 고르는 알고리즘이다.  
종류:
- 선택 정렬
- 배낭 문제
- 최소 신장 트리
- 단일 출발지 최단 경로
- 스케줄링 문제
- 프림 알고리즘
- 크루스컬 알고리즘
- 다익스트라 알고리즘
- 허프만 코딩
- 포드-풀커슨 알고리즘

https://velog.io/@contea95/%ED%83%90%EC%9A%95%EB%B2%95%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98
https://www.programiz.com/dsa/greedy-algorithm

22.11.01
## Q. 시퀀스 컨테이너의 조건과 종류, 각각의 특징에 대해 설명해주세요.(자료구조)

A. **시퀀스 컨테이너**(sequence container)
- 메모리 상에서 모든 요소가 직전 순서로 배치되어 순서가 존재해야 한다. 즉, 첫 번째 요소와 마지막 요소를 제외한 모든 요소는 앞뒤로 컨테이너의 요소가 존재해야 한다.
- 반복자가 이동할 때 요소의 순서가 변경되지 않음을 보장하기 위해 반복자는 최소 순방향 반복자를 사용해야 한다.
- 시퀀스 컨테이너는 직선 순서로 배치되어 명확한 순서가 존재하므로 특정 위치에 대한 참조가 가능해야 한다.

종류:
- vector: 벡터 컨테이너는 동적 배열의 클래스 템플릿으로 가장 기본이 되는 컨테이너로, 데이터가 들어가고 나올 수 있는 입출구가 뒤쪽 하나이며 앞쪽은 막혀있는 형태이다. 따라서 데이터를 넣을 때도 뒤에서부터 쌓이고 데이터를 꺼낼 때는 맨 뒤에서부터 뺄 수 있다.
- deque: 디큐 컨테이너는 vector 컨테이너를 개선한 컨테이너로, double-ended queue를 의미하며 양쪽에 끝이 있는 큐(queue)라는 뜻이다. vector는 뒤쪽에서만 요소의 삽입과 삭제가 가능했지만 deque는 양 끝에서 빠르게 요소를 삽입하거나 삭제할 수 있다.
- list: 리스트 컨테이너는 vector, deque와 같은 시퀀스 컨테이너이지만 노드 기반 컨테이너로 이중 연결 리스트(double linked list)의 클래스 템플릿 표현이다. 노드 기반이기 때문에 [ ]이나 at() 함수를 통한 임의 접근은 불가능하지만 컨테이너의 모든 요소에서 양방향 접근을 통해 빠른 삽입과 삭제가 가능하다.

https://winterflower.tistory.com/113

22.11.02
## Q. 페이징이란 무엇인가요?(운영체제)

A. 페이징(paging)이란 논리주소의 고정된 페이지(Page)라고 불리는 블록들로 분할 관리하는 기법이다. 각각의 페이지는 물리 메모리의 프레임과 맴핑한다. 페이지를 가리키는 논리주소에서 프레임을 가리키는 물리주소로 변환한다.

https://jhnyang.tistory.com/m/290

22.11.03  
## Q. 인터넷과 인트라넷의 차이점에 대해서 설명해주세요.(네트워크)

A.  
인터넷(internet): 통신망과 통신망들이 연결되어 있는 망들의 집합들을 의미한다. 중앙의 호스트 컴퓨터도 없고, 관리하는 단체 및 조직도 없다. 서로의 통신망이 연결된 서비스이다. 전세계를 망라하는 초거대 통신 네트워크 망의 집합체이다.  
인트라넷(intranet): 네트워크 기술을 이용하여 특정 단체의 내부업무를 통합하는 정보시스템을 의미한다. 인터넷이 아닌 별도의 통신망을 이용하여 조직 내부시스템을 구축하는 것이다.  
공통점: 같은 통신망을 이용한다.  
차이점: 모든 사람이 사용하는지, 특정 대상만 사용하는지

https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=bloghkit&logNo=220576307382

22.11.04
## Q. 다익스트라 알고리즘(Dijkstra's Algorithm)에 대해 설명해주세요.(알고리즘)

A. 다익스트라 알고리즘은 그래프에서 한 정점(노드)에서 다른 정점까지의 최단 경로를 구하는 알고리즘 중 하나이다. 현재 위치한 노드의 인접한 방문하지 않은 노드 중 거리가 가장 짧은 노드를 방문하는 것을 반복하는 알고리즘이다. 가중치가 양수일 때만 사용 가능하다는 중요한 특징이 있다.

https://velog.io/@717lumos/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BCDijkstra-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98

22.11.05
## Q. 보조인덱스와 클러스터링 인덱스의 차이에 대해 설명해주세요.(데이터베이스)

A.  
보조 인덱스
- 데이터와 인덱스를 각각 다른 위치에 저장
- 인덱스는 해당 데이터의 위치에 대한 포인터를 포함
- 테이블당 여러 개 생성 가능

클러스터형 인덱스
- 키 값에 대한 테이블의 데이터 행을 정렬하는 인덱스의 한 유형
- 테이블의 데이터를 정렬해서 저장되는 순서를 정의
- 테이블당 하나만 생성 가능
- 행 데이터를 인덱스로 지정한 열에 맞춰서 자동으로 정렬

https://jie0025.tistory.com/107

22.11.06
## Q. 운영체제와 커널의 차이점에 대해 설명해주세요.(운영체제)

A.  
운영체제: 시스템 리소스를 관리하는 시스템 소프트웨어. 사용자와 시스템 하드웨어 간의 인터페이스 역할을 한다.  
커널: 운영체제의 핵심. 시스템 작동을 시작하기 위해 주 메모리에 로드되는 운영 체제의 첫 번째 프로그램. 사용자가 입력한 명령을 컴퓨터가 이해하도록 변환한다.

https://ko.gadget-info.com/difference-between-kernel

22.11.07
## Q. 그래프와 트리의 차이점에 대해 설명해주세요.(자료구조)

A.   
그래프와 트리는 모두 비선형 자료구조이다. 인접(전후) 원소들 간에 트리는 1:n 관계로, 그래프는 n:m 관계로 배치된다. 트리는 사이클이 없는 연결 그래프이고, 그래프는 트리의 성질을 포함하면서 사이클을 허용한다.

https://bigsong.tistory.com/33

22.11.08
## Q. 프로토콜에 대해서 설명해주세요.(네트워크)

A. 프로토콜(Protocol): 통신 프로토콜 또는 통신 구약은 컴퓨터나 원거리 통신 장비 사이에서 메시지를 주고 받는 양식과 규칙의 체계이다. 즉 통신 규약 및 약속이다.

프로토콜의 기본 요소
- 구문(Syntax): 전송하고자 하는 데이터의 형식(Format), 부호화(Coding), 신호 레벨(Signal Level) 등을 규정
- 의미(Semantics): 두 기기 간의 효율적이고 정확한 정보 전송을 위한 협조 사항과 오류 관리를 위한 제어 정보를 규정
- 시간(Timing): 두 기기 간의 통신 속도, 메시지의 순서 제어 등을 규정

프로토콜의 종류
|          계층          |                프로토콜                |
|:----------------------:|:--------------------------------------:|
| 응용(Application)      | HTTP, SMTP, FTP, Telnet                |
| 표현(Presentation)     | ASCII, MPEG, JPEG, MIDI                |
| 세션(Session)          | NetBIOS, SAP, SDP, NWLink              |
| 전송(Transport)        | TCP, UDP, SPX                          |
| 네트워크(Network)      | IP, IPX                                |
| 데이터 링크(Data Link) | Ethernet, Token Ring, FDDI, Apple Talk |
| 물리(Physical)         | 없음                                   |

프로토콜의 기능  
단편화(Fragmentation)와 재합성(Assembly)  
단편화: 송신 측에서는 긴 데이터 블록을 손쉽게 전송할 수 있도록 크기가 똑같은 작은 블록으로 나누어 전송
재합성: 수신 측에서 쪼개진 작은 데이터 블록을 재합성하여 원래의 메시지로 복원하는 기능

캡슐화(Encapsulation)  
각 프로토콜에 적합한 데이터 블록을 만들려고 데이터에 정보를 추가하는 것  
플래그, 주소, 제어 정보, 오류 검출 부호 등을 부착하는 기능

연결 제어(Connection Control)  
비연결 데이터 전송(데이터그램)과 연결 위주 데이터 전송(가상회선)을 위한 통신로를 개설, 유지, 종결하는 기능

흐름 제어(Flow Control)  
데이터양이나 통신속도 등이 수신 측의 처리 능력을 초과하지 않도록 조정하는 기능

오류 제어(Error Control)  
데이터 전송 중 발생할 수 있는 오류나 착오 등을 검출하고 정정하는 기능

순서 결정(Sequencing)  
연결 위주의 데이터를 전송할 때 송신 측이 보내는 데이터 단위 순서대로 수신 측에 전달하는 기능

주소 설정(Addressing)  
발생지, 목적지 등의 주소를 명기하여 데이터를 정확하게 전달하는 기능

동기화(Synchronization)  
두 통신 객체의 상태(시작, 종류, 검사 등)를 일치시키는 기능

다중화(Multiplexing)  
하나의 통신로를 여러 개로 나누거나 회선 여러 개를 하나의 통신로로 변환시켜 다수의 가입자가 동시에 사할 수 있도록 하는 기능

전송 서비스(Transmission Service)  
통신 객체를 사용하기 쉽도록 별도로 추가 서비스(패리티 검사, 보안도, 서비스 등급, 우선순위 등)를 제공하는 기능

https://computer-science-student.tistory.com/377

22.11.09
## Q. 칸 알고리즘(Kahn's Algorithm)에 대해 설명해주세요.(알고리즘)

A. 위상 정렬 알고리즘 중 하나이다. 궁극적인 위상 정렬로써 같은 순서 속에 있는 꼭짓점에 의해 선택된다.

https://www.techiedelight.com/ko/kahn-topological-sort-algorithm/

22.11.10
## Q. 기본키와 엔티티 무결성 제약 조건에 대해서 설명해주세요.(데이터베이스)

A. 기본키와 엔티티 무결성 제약조건(entity integrity constraint)
- 기본키가 각 튜플들을 식별하기 위하여 사용되기 때문에 릴레이션의 기본키를 구성하는 어떤 애트리뷰트도 Null값을 가질 수 없다는 제약조건
- 대체키에는 적용되지 않음(기본키에만 적용)
- 사용자는 릴레이션을 생성하는 데이터 정의문에서 어떤 애트리뷰터가 릴레이션의 기본키의 구성요소인가를 DBMS에게 알려줌

https://rainbow97.tistory.com/entry/Database-02-4-%EB%AC%B4%EA%B2%B0%EC%84%B1-%EC%A0%9C%EC%95%BD%EC%A1%B0%EA%B1%B4

22.11.11
## Q. URL과 URI의 차이에 대해 설명해주세요.(네트워크)

A.  
URI(Uniform Resource Identifier): 특정 리소스를 식별하는 통합 자원 식별자. 웹기술에서 사용하는 논리적 또는 물리적 리소스를 식별하는 고유한 문자열 시퀀스이다.  
URL(Uniform Resource Locator): 흔히 웹 주소라고도 하는, 컴퓨터 네트워크 상에서 리소스가 어디 있는지 알려주기 위한 규약. URI의 서브셋이다.  
URI는 식별하고 URL은 위치를 가리킨다.

https://www.charlezz.com/?p=44767

22.11.12
## Q. CPU 스케줄링 알고리즘의 종류와 각각에 대해 아는대로 설명해주세요.(운영체제)

A.
- FCFS(First Come, First Serve): 먼저 도착한 프로세스를 먼저 처리하는 스케줄링 알고리즘이다.
- SJF(Shortest Job First): 최단적업우선 스케줄링 알고리즘이다. 여기서 최단작업이란 CPU버스트 타임이 가장 짧은 프로세스를 말한다.
- Priority Scheduling(우선순위 스케줄링): 미리 주어진 프로세스의 우선순위에 따라서 스케줄링하는 방식이다.
- Round Robin(라운드 로빈): 정해진 시간 할당량만큼 프로세스를 할당한 뒤, 작업이 끝난 프로세스는 준비완류 큐(순환 큐)의 가장 마지막에 가서 재할당을 기다린다.
- Multilevel-Queue(다단계 큐): 준비완료 큐를 여러 개의 큐로 분류하여 각 큐가 각각 다른 스케줄링 알고리즘을 가지는 방식.
- Multilevel-Feedback-Queue(다단계-피드백 큐): 기존 다단계 큐 방식은 특정 프로세스가 큐에 고정되는 방식인 반면 다단계 피드백 큐에서는 큐와 큐 사이에 프로세스가 이동하는 걸 허용한다.

https://dduddublog.tistory.com/23

22.11.13
## Q. Stack 2개로 queue를 구현하는 방법을 섦명해주세요.(자료구조)

A.  
1. Stack1로는 data를 입력받는다.
2. Stack2로는 data를 pop한다.
3. Stack2가 비어있다면 Stack1에서 Stack2로 data를 옮긴다.

https://velog.io/@wonhee010/Stack-2%EA%B0%9C%EB%A1%9C-Queue-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0

22.11.14
## Q. 프림 알고리즘(Prim's Algorithm)에 대해 설명해주세요.(알고리즘)

A. MST(최소신장트리)를 찾기 위한 그리디 패러다임 알고리즘.
1. 임의의 점 하나를 선택하여 T에 넣는다.
2. T 밖에 있는 점들 중에서 T에 있는 점과 가장 가까운 점을 T에 추가한다.
3. 2를 n-1회 수행한다.

https://www.weeklyps.com/entry/%ED%94%84%EB%A6%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Prims-algorithm

22.11.15
## Q. 데이터 사전(data dictionary)에 대해서 설명해주세요.(데이터베이스)

A. 데이터 사전(Data Dictionary)이란?
- 데이터 사전이란 대부분 읽기전용으로 제공되는 테이블 및 부들의 집합으로 데이터베이스 전반에 대한 정보를 제공한다.
- 오라클 데이터베이스는 명령이 실행될 때마다 데이터 사전을 Access 한다.
- DB작업 동안 Oracle은 데이터 사전을 읽어 객체의 존재여부와 사용자에게 적합한 Access 권한이 있는지를 확인한다. 또한 Oracle은 데이터 사전을 계속 갱신하여 데이터베이스 구조, 감사, 사용자권한, 데이터 등의 변경사항을 반영한다.

https://tragramming.tistory.com/75

22.11.16
## Q. 라우터와 스위치의 차이에 대해 말씀해주세요.(네트워크)

A.  
**스위치**  
- 목적지로 출발한 데이터를 중간에 적합한 경로로 스위칭해주는 역할. 데이터링크 계층에 속해있으므로 MAC주소 기반으로 동작한다.

**라우터**
- 목적지로 가는 적합한 경로를 찾아주는 라우팅 기능을 한다. 네트워크 계층에 속해있으므로 IP주소를 기반으로 동작한다.

**라우터와 스위치의 차이**
- 라우터는 네트워크 계층에서 IP주소를 기반으로 동작하며 스위치는 데이터링크 계층에서 MAC주소를 기반으로 동작한다.
- 스위치는 브로드캐스트 도메인을 구분할 수 없는 반면 라우터는 브로드캐스트 도메인을 구분하여 서로 다른 네트워크 대역을 구분한다.
- 스위치는 불명확한 목적지를 가진 데이터를 처리할 때 모든 포트로 데이터를 퍼뜨리는 브로드캐스트를 하지만 라우터는 해당 데이터를 버린다.
- 스위치는 관리자의 설정이 필요없지만 라우터는 관리자의 설정으로 라우팅 테이블 생성과 통신을 해야 한다.

https://velog.io/@jihoon97/%EC%8A%A4%EC%9C%84%EC%B9%98-%EB%9D%BC%EC%9A%B0%ED%84%B0%EC%9D%98-%EC%B0%A8%EC%9D%B4

22.11.17
## Q. CISC와 RISC의 차이에 대해 설명해주세요.(운영체제)

A.  
**CISC(Complex Instruction Set Computer)**
- 필요한 모든 명령어 셋을 갖추도록 설계된 마이크로프로세서

**RISC(Reduced Instruction Set Computer)**
- 가장 자주 사용되는 명령어만으로 개수를 줄인 마이크로프로세서

**차이점**
|        분류       |                                 CISC컴퓨터                                 |                                 RISC컴퓨터                                 |
|:-----------------:|:--------------------------------------------------------------------------:|:--------------------------------------------------------------------------:|
|      레지스터     |              8~16개의 범용 레지스터 사용 부동소수점 연산 제공              | 16~32개의 범용 레지스터 사용 부가적인 레지스터 사용 가능기본적인 연산 제공 |
|      설계목적     |               최소의 프로그램 길이 1개의 명령어로 최대의 동작              |            프로그램의 길이는 길어도 명령어 당 실행 시간의 최소화           |
|     명령어형식    | 다양한 길이와 형식 LOAD /STORE,레지스터와 메모리의 다양한 명령어 형식 제공 |                   고정길이의 명령어 제공 두가지 형식 제공                  |
|      명령어군     |          OS와 RUN TIME 유틸리티를 지원하는 데이터 형과 명령어 제공         |               LOAD/STORE 범용 레지스터 레지스터의 데이터 연산              |
|       인코딩      |                          1개의 명령어 = 1개의 문장                         |                  1개의 명령어 = 1개의 오퍼랜드나 1개 연산                  |
|     구현측면성    |               마이크로 프로그램 제어 방식의 프로 웨어로 구성               |             하드웨어 제어 방식의 프로세서와 소프트 세서로 구성             |
|      기타특징     |                              하드웨어가 강조됨                             |                             소프트웨어가 강조됨                            |
| 코드크기와 사이클 |                  작은 코드 크기, 단위시간동안 높은 사이클                  |                  단위시간동안 낮은 사이클수, 큰 코드 크기                  |
|     트렌지스터    |                축약명령어를 저장을 위해 트랜지스터가 사용됨.               |              메모리 레지스터에 보다 많은 트랜지스터가 사용됨.              |

https://chlalgud8505.tistory.com/8

22.11.18
## Q. HashMap과 HashTable의 차이를 설명해주세요.(자료구조)

A.  
- HashMap은 동기화(Synchronization)을 지원하지 않는 반면 다중 스레드 환경에서 HashTable은 동기화를 지원한다.
- 속도 측면에서 HashTable은 동기화 처리 비용 때문에 HashMap에 비해 더 느리다.
- HashMap은 저장된 요소들의 순회를 위해 Fail-Fast Iterator를 반환하는 반면 HashTable은 Enumeration을 반환한다.

https://odol87.tistory.com/3

22.11.19
## Q. 피보나치 수열을 구현할 때에 재귀, 동적 계획법, 반복을 이용하는 방식의 차이를 시간 복잡도와 연관지어 설명해주세요.(알고리즘)

A.  
재귀: 피보나치 수열을 재귀방식으로 구현하게 되면, f(n)은 f(n-2) + f(n-1)을 리턴하고, 이는 다시 f(n-4) + f(n-3)과 f(n-3) + f(n-2)을 더하는 것으로 리턴이 된다. 이렇게 f(0) = 0, f(1) = 1의 base step까지 재귀 호출을 하게 되는데, 이때 실행되는 횟수는 $2^n$회이므로, 시간 복잡도는 O( $2^n$ )이 된다.

동적 계획법: 피보나치 수열을 동적 계획법으로 구현하게 되면, f(0) = 0, f(1) = 1에서 시작하여 f(0) + f(1) = f(2)의 f(2)값을 저장하고, f(1) + f(2) = f(3)의 f(3)값을 저장하는 등의 순서로 f(n-2) + f(n-1) = f(n)까지 반복하게 된다. 이때 실행되는 횟수는 n-1회이므로, 시간 복잡도는 O(n)이 된다.

반복: 피보나치 수열을 for 반복문을 이용하여 구현하게 되면, 시간 복잡도는 동적 계획법과 마찬가지로 O(n)이지만 대신 각 스텝에서 피보나치 수를 저장하지 않기 때문에, 공간 효율이 더 낫다.

https://velog.io/@im_lily/%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%EC%88%98%EC%97%B4-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84

22.11.20
## Q. 심층 신경망(DNN)의 장단점에 대해 설명해주세요.

A.  
장점:
1. 연속형, 범주형 변수에 상관없이 모두 분석 가능하다.
2. 입력 변수들 간의 비선형 조합이 가능하다. 이는 다른 신경망에 비해 DNN이 가지는 가장 좋은 장점 중 하나이다.
3. 예측력이 다른 머신러닝 기법들에 비해 상대적으로 우수한 경우가 많다.
4. feature extraction이 자동으로 수행된다. 이것은 변수 선택의 번거로움을 줄여준다.
5. Data 양이 많아지면 성능이 계속 좋아진다.

단점:
1. 신경망이 복잡할 경우 작동하는 데 시간이 오래 걸린다. 때문에 GPU가 장착된 컴퓨터 및 고사양의 컴퓨터가 필요하다.
2. 분석 시 변수들을 일정한 순서나 방식으로 넣는 것이 아니기 때문에 결과가 일정하지 않다.
3. 가중치의 의미를 정확히 해석하기가 어렵기 때문에 결과 해석이 어렵다.

https://www.todaymart.com/631

22.11.21
## Q. 로깅을 이용한 데이터베이스의 회복에 대해서 간략히 설명해주세요.(데이터베이스)

A.  
1. **지연 갱신 회복 기법(Defferred Update)**  
트랜잭션이  부분 완료 상태에 이르기까지 발생한 모든 변경 내용을 로그 파일에만 저장하고, 데이터베이스에는 Commit이 발생할 때까지 저장을 지연하는 기법

2. **즉시 갱신 회복 기법(Immediate Updat)**  
트랜잭션 수행 도중 데이터를 변경하면 변경 정보를 로그 파일에 저장하고, 트랜잭션이 부분 완료되기 전이라도 모든 변경 내용을 즉시 데이터베이스에 반영하는 기법

https://itwiki.kr/w/%EB%A1%9C%EA%B7%B8_%EA%B8%B0%EB%B0%98_%ED%9A%8C%EB%B3%B5_%EA%B8%B0%EB%B2%95  
https://bubble-dev.tistory.com/entry/DB-Recovery-%EB%A1%9C%EA%B9%85-%EB%B0%A9%EC%8B%9D

22.11.22
## Q. 프록시에 대해 설명해주세요.(네트워크)

A. **프록시(proxy)**  
데이터를 가져올 때 해당 사이트에서 바로 자신의 PC로 가져오는 것이 아니라 임시 저장소를 거쳐서 가져오는 것. 프록시를 설정하면 수 초의 빠른 속도를 느낄 수 있다. 프록시 서버에는 다수의 사용자들이 들르는 사이트에 대한 데이터가 저장되어 있어 경우에 따라 해당 사이트에 들르지 않고 바로 이 서버에 있는 데이터를 이용하기도 한다. 하지만 프록시 서버에 문제가 생겼거나 과부하가 걸렸을 경우 오히려 더 느려지는 경우도 있다. (사이트 → 프록시 서버 → PC)

[네이버 지식백과] 프록시  
https://terms.naver.com/entry.naver?docId=834076&cid=42344&categoryId=42344  
https://brownbears.tistory.com/191

22.11.23
## Q. 페이징(Paging)과 세그멘테이션(Segmentation)을 사용하는 이유와 차이점에 대해 설명해주세요.(운영체제)

A.  
다중 프로그래밍 시스템에서 다수의 프로세스를 수용하기 위해 주기억장치를 동적으로 분할하는 메모리 관리 작업을 위해 페이징과 세그멘테이션을 사용함.  

**페이징(Paging)**  
- 프로세스를 일정한 크기의 페이지로 분할해서 메모리에 적재하는 방식
- 하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애는 메모리 관리 방법  

**세그멘테이션(Segmentation)**  
- 가상 메모리를 서로 크기가 다른 논리적 단위로 분할한 것
- 프로세스를 물리적 단위인 페이지가 아닌 논리적 단위인 세그먼트로 분할해서 메모리에 적재하는 방식
- 세그먼트는 의미가 같지 않은 논리적 내용을 기준으로 프로그램을 분할하기 때문에 크기가 같지 않음  

**차이점**
- 페이징은 외부 단편화가 생기지 않는 대신 내부 단편화가 발생할 수 있고, 세그멘테이션은 반대로 내부 단편화가 생기지 않는 대신 외부 단편화가 발생할 수 있음

https://velog.io/@gang_shik/%ED%8E%98%EC%9D%B4%EC%A7%95Paging%EA%B3%BC-%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%85%8C%EC%9D%B4%EC%85%98Segmentation#%ED%8E%98%EC%9D%B4%EC%A7%80%EC%99%80-%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%85%8C%EC%9D%B4%EC%85%98

22.11.24
## Q. AVL 트리에 대해서 설명해주세요.(자료구조)

A.  
이진탐색트리는 한 쪽으로 노드가 쏠릴 경우 탐색 시간 복잡도가 O(N)이 되게 된다. 이런 단점을 극복할 수 있는 자료구조가 **AVL 트리**(Adelson-Velsky and Landis 이름의 앞글자를 따서)이다. 편향트리를 AVL트리로 재구성하면 O(logN)의 시간 복잡도를 갖게 된다. AVL트리는 다음과 같은 특징을 갖는다.  
1. 이진 탐색 트리의 속성을 가진다.
2. 왼쪽, 오른쪽 서브 트리의 높이 차이가 최대 1이다.
3. 높이 차이가 1보다 커지면 회전(Rotation)을 통해 균형을 맞춰 높이 차이를 줄인다.
4. 삽입, 검색, 삭제의 시간 복잡도가 O(logN)이다.

https://code-lab1.tistory.com/61?category=1213002

22.11.26
## Q. n개의 배열에서 k째로 큰 수를 찾는 알고리즘에 대해 설명해주세요.(알고리즘)

A.  
Quick Selection 알고리즘:  
1. Array의 element 중 random한 하나의 element를 pivot으로 정한다.
2. Array를 A1(Array의 element 중 pivot보다 작은 element들을 모은 Array)와 A2(pivot보다 큰 element들을 모은 Array)로 partitioning 한다.
3. A1의 배열 Size에 따라, 다음의 세 가지 경우로 나뉜다.
    - k번째 큰 element가 A2 배열 내에 있는 경우, Input Array를 A2로 정한 뒤 k번째 큰 element를 찾는 Subproblem의 값을 반환한다.
    - k가 A1의 Size + 1인 경우, pivot이 k번째 큰 element가 되므로 pivot을 반환한다.
    - k번째 큰 element가 A1 배열 내에 있는 경우, Input Array를 A1으로 정한 뒤 k-(A2 Size + 1)번째 큰 element를 찾는 Subproblem의 값을 반환한다.

https://2jinishappy.tistory.com/124  
https://gils-lab.tistory.com/94

22.11.27
## Q. 의사결정나무(Decision Tree)의 장단점에 대해 설명해주세요.(머신러닝)

A. **의사결정나무(Decision Tree)**  
한 번에 하나씩의 설명을 하면서, 예측 가능한 규칙들의 집합을 생성하는 알고리즘.  

장점:  
- 범주와 연속형 수치를 모두 예측할 수 있다.
- 구조가 단순하여 해석이 용이하고, 유용한 입력 변수의 파악, 예측 변수 간의 상호작용, 비선형성을 고려하여 수학적 가정이 불필요한 비모수적 모형이다.
- 시장조사, 광고조사, 의학연구, 품질관리 등 다양한 분야에서 활용되고 있다.
- 고객 타겟팅, 고객의 신용점수화, 캠페인에 대한 반응, 고객 행동 예측 등에 유용하다.

단점:
- 분류 기준값의 경계선 근방의 자료값에 대해서는 오차가 클 수 있다.
- 로지스틱 회귀와 같이 각 예측 변수의 효과를 파악하기 어렵다.
- 새로운 자료에 대한 예측이 불안정할 수 있다.
- 상위 노드로부터, 하위 노드로 트리구조를 형성하는 모든 단계마다 기준값의 선택이 중요하다.

https://schoolforkids.tistory.com/entry/decision-tree

22.11.28
## Q. 트랜잭션의 연산 중 ROLLBACK의 개념을 간략히 설명해주세요.(데이터베이스)

A.  
- 작업 중 문제가 발생되어서 트랜잭션의 처리 과정에서 발생한 발견사항을 취소하는 명령어
- ROLLBACK 역시 하나의 트랜잭션 과정을 종료하게 됨
- 트랜잭션으로 인한 하나의 묶음 처리가 시작되기 이전의 상태로 되돌림
- Transaction(INSERT, UPDATE, DELETE) 작업 내용을 취소함
- 이전 COMMIT한 곳까지만 복구함

https://itprogramming119.tistory.com/entry/Oracle-ROLLBACK%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%EA%B3%BC%EC%A0%95

22.11.29
## Q. 쿠키와 세션의 차이에 대해 설명해주세요.(네트워크)

A.  
- 쿠키와 세션은 비슷한 역할을 하며, 동작원리도 비슷함. 그 이유는 세션도 결국 쿠키를 사용하기 때문
- 가장 큰 차이점은 사용자의 정보가 저장되는 위치. 때문에 쿠키는 서버의 자원을 전혀 사용하지 않으며, 세션은 서버의 자원을 사용
- 보안 면에서 세션이 더 우수하며, 요청 속도는 쿠키가 더 빠름. 세션은 서버의 처리가 필요하기 때문
- 쿠키는 클라이언트 로컬에 저장되기 때문에 변질되거나 request에서 스니핑당할 우려가 있어 보안에 취약하지만 세션은 쿠키를 이용해서 sessioned 만 저장하고 그것으로 구분해서 서버에서 처리하기 때문에 비교적 보안성이 좋음
- 쿠키도 만료시간이 있지만 파일로 저장되기 때문에 브라우저를 종료해도 계속해서 정보가 남아있을 수 있음. 또한 만료기간을 넉넉하게 잡아두면 쿠키삭제를 할 때까지 유지될 수도 있음
- 세션도 만료시간을 정할 수 있지만 브라우저가 종료되면 만료시간에 상관없이 삭제됨. 예를 들어, 크롬에서 다른 탭을 사용해도 세션은 공유됨. 다른 브라우저를 사용하게 되면 다른 세션을 사용할 수 있음
- 쿠키에 정보가 있기 때문에 서버에 요청 시 속도가 빠르고 세션은 정보가 서버에 있기 때문에 처리가 요구도어 비교적 느린 속도를 가짐

https://interconnection.tistory.com/74

22.11.30
## Q. 가상 메모리(Virtual Memory)에 대해 설명해주세요.

A. main memory(RAM)의 크기가 작아서 모든 정보를 담기에 부족한 경우 하드디스크까지 main memory(RAM)를 확장해서 사용하는 것을 Virtual Memory 기법이라고 한다.  

https://d-cron.tistory.com/30

22.12.01
## Q. 트리 순회 방식인 전위 순회, 중위 순회, 후위 순회에 대해 설명해주세요.(자료구조)

A. **이진 트리의 순회 종류**  
- 이진 트리의 노드 전체를 한 번씩 방문하는 것을 순회(traversal)라고 함
- 노드 데이터를 처리하는 순서에 따라 전위 순회, 중위 순회, 후위 순회로 구분됨
- 전위 순회
  1. 현재 노드 데이터 처리
  2. 왼쪽 서브 트리로 이동
  3. 오른쪽 서브 트리로 이동
- 중위 순회
  1. 왼쪽 서브 트리로 이동
  2. 현재 노드 데이터 처리
  3. 오른쪽 서브 트리로 이동
- 후위 순회
  1. 왼쪽 서브 트리로 이동
  2. 오른쪽 서브 트리로 이동
  3. 현재 노드 데이터 처리

[성균관대 문제해결과알고리즘 수업자료]  
https://withhamit.tistory.com/282

22.12.02
## Q. 거품 정렬, 퀵 정렬, 힙 정렬, 합병 정렬에 대하여 각각의 최선, 평균, 최악의 시간 복잡도에 대해 설명해주세요.(알고리즘)

A.  
|           |     최선     |     평균     | 최악         |
|:---------:|:------------:|:------------:|--------------|
| 거품 정렬 |  $O(N^2)$  |  $O(N^2)$  | $O(N^2)$   |
|  퀵 정렬  | $O(NlogN)$ | $O(NlogN)$ | $O(N^2)$   |
|  힙 정렬  | $O(NlogN)$ | $O(NlogN)$ | $O(NlogN)$ |
| 합병 정렬 | $O(NlogN)$ | $O(NlogN)$ | $O(NlogN)$ |

https://yabmoons.tistory.com/250

22.12.03
## Q. generative model과 discriminative model의 차이에 대해 설명해주세요.(머신러닝)

A.  
**generative model**  
- 데이터 X가 생성되는 과정을 두 개의 확률모형, 즉 $P(Y)$, $P(X|Y)$으로 정의하고, 베이즈룰을 사용해 $P(Y|X)$를 간접적으로 도출하는 모델
- 레이블 정보가 있어도 되고(지도학습기반의 generative model, 선형판별분석이 대표적 사례), 없어도 구축할 수 있다(비지도학습 기반의 generative model, 가우시안 믹스처 모델, 토픽모델링이 대표적 사례).

**discriminative model**  
- 데이터 X가 주어졌을 때 레이블 Y가 나타날 조건부확률 $P(X|Y)$를 직접적으로 반환하는 모델
- 레이블 정보가 있어야 하기 때문에 지도학습(supervised learning) 범주에 속하며 X의 레이블을 잘 구분하는 결정경계(decision boundary)를 학습하는 것이 목표
- generative model에 비해 가정이 단순하고, 학습데이터 양이 충분하다면 좋은 성능을 내는 것으로 알려져있음
- 선형회귀, 로지스틱회귀가 대표적인 예시

**차이점**  
![image](https://user-images.githubusercontent.com/71001479/205445141-e7cb44b2-451b-4319-8636-67cbbe29c1e1.png)  
- generative model은 사후확률을 간접적으로, discriminative model은 직접적으로 도출함  
![image](https://user-images.githubusercontent.com/71001479/205445202-fee6b867-4e72-48bd-a5b4-9947d92b6c06.png)  
- generative model은 데이터 범주의 분포를, discriminative model은 결정경계를 학습함  

https://ratsgo.github.io/generative%20model/2017/12/17/compare/

22.12.04
## Q. 트랜잭션의 연산 중 COMMIT의 개념을 간략히 설명해주세요.(데이터베이스)

A. **COMMIT**  
저장되지 않은 모든 데이터를 데이터베이스에 저장하고 현재의 트랜잭션을 종료하라는 명령(데이터베이스에서 트랜잭션이란 논리적인 일의 단위를 말함)

http://itnovice1.blogspot.com/2019/01/commit.html

22.12.05
## Q. IPv4 고갈로 생겨난 서브넷팅이란 무엇인가요?(네트워크)

A.  
- IPv4 주소 체계는 클래스를 나누어 IP를 할당하는데, 클래스를 할당한 후 호스트를 일부만 할당하면 나머지 호스트가 낭비되는 비효율성을 해결하기 위해 네트워크 장치들의 수에 따라 효율적 사용이 가능한 서브넷(subnet)이 등장함
- 서브넷은 IP 주소에서 네트워크 영역을 부분적으로 나눈 부분 네트워크를 뜻하는데, 서브넷을 만들 때 사용되는 것이 서브넷 마스크(subnet mask)
- 서브넷 마스크를 이용하면 원본 네트워크를 여러 개의 네트워크로 분리할 수 있는데, 이러한 과정을 서브넷팅(subneting)이라고 함
- 세브넷팅은 IP 주소 낭비를 방지하기 위해 원본 네트워크를 여러 개의 서브넷으로 분리하는 과정을 뜻하며, 서브넷 마스크의 bit 수를 증가시켜 할당할 수 있는 네트워크를 증가시키고 호스트 수를 감소시킴

https://code-lab1.tistory.com/34

22.12.06
## Q. 메모리 단편화(Memory Fragmentation)에 대해 설명해주세요.(운영체제)

A.  
**단편화**  
프로세스에 대한 메모리 할당과 해방을 반복함으로써 메모리의 분할부가 다수 생성되는 것. 사용할 수 있는 메모리가 프로세스가 요구하는 크기보다 작기 때문에 어떤 요구도 만족할 수 없고, 사용하지 않은 상태로 남아있는 상태.

**내부 단편화**  
프로세스에 필요한 공간보다 메모리가 더 많이 할당되었을 때, 프로세스 내부에서 발생되는 단편화.

**외부 단편화**  
메모리가 할당과 해제를 반복하면서 작은 공간의 메모리 영역이 생기게 되는데, 그 공간이 어떤 프로세스가 필요로 하는 크기보다 작은 경우 발생되는 단편화. 전체적으로 남는 메모리는 프로세스가 필요로 하는 공간보다 크지만, 각각의 분할부는 충족하지 못하는 상황.

[네이버 지식백과] 단편화 https://terms.naver.com/entry.naver?docId=823914&cid=42344&categoryId=42344  
https://kosaf04pyh.tistory.com/40

22.12.07
## Q. BFS(Breadth-First Search)와 DFS(Depth-First Search)에 대해 설명해주세요.(자료구조)

A. BFS(너비 우선 탐색)과 DFS(깊이 우선 탐색) 모두 그래프를 탐색하는 방법이다.

**DFS**  
- 루트 노드(혹은 다른 임의의 노드)에서 시작해서 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방식
- 현재 정점에서 갈 수 있는 점들까지 들어가면서 탐색
- 모든 노드를 방문하고자 하는 경우 이 방법을 선택함
- 스택 또는 재귀함수로 구현
- BFS보다 간단함
- BFS보다 검색 속도가 느림


**BFS**  
- 루트 노드(혹은 다른 임의의 노드)에서 시작해서 인접한 노드를 먼저 탐색하는 방법으로, 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져있는 정점을 나중에 방문하는 순회 방법
- 현재 정점에 연결된 가까운 점들부터 탐색
- 두 노드 사이의 최단 경로를 찾고 싶을 때 이 방법을 선택함
- 큐를 이용해서 구현
- DFS보다 복잡함
- DFS보다 검색 속도가 빠름

https://velog.io/@lucky-korma/DFS-BFS%EC%9D%98-%EC%84%A4%EB%AA%85-%EC%B0%A8%EC%9D%B4%EC%A0%90

22.12.08
## Q. 외판원 순회 문제(Travelling Salesman Problem)에 대해 설명하고 이를 해결하기 위한 알고리즘을 제시해주세요.(알고리즘)

A.  
- 임의의 한 도시에서 출발하여 다른 모든 도시를 1번씩만 방문하고 출발했던 도시로 돌아오는 여행 경로의 거리를 최소화하는 문제임
- 다양한 알고리즘으로 최적 해를 찾을 수 있으나 모두 지수 시간이 소요됨
- 도시 수가 많아지면 오랜 소요 시간으로 최적 해를 찾기 어려움
- TSP와 유사한 특성을 가진 최소 신장 트리를 통해 해결할 수 있음
- 알고리즘:
  1. 입력 그래프에서 MST T를 찾는다
  2. T의 시작점에서 트리의 간선을 따라 모든 점을 방문하고 다시 시작점으로 방문 순서를 찾는다
  3. 2에서 찾은 방문 순서에서 중복된 점들을 제거하여 TSP 경로를 만든다. 단, 마지막의 시작점은 제거하지 않는다

[성균관대 문제해결과알고리즘 수업자료]  
https://loosie.tistory.com/272

22.12.09
## Q. training set, validation set, test set의 차이에 대해 설명해주세요.(머신러닝)

A.  
**Training set**: 학습 과정에서 사용되는 예시 데이터 집합

**Validation set**: training set을 통해 학습을 한 여러 모델의 성능을 측정하기 위한 데이터 집합

**Test set**: validation set을 통해 결정된 모델의 성능을 측정하기 위한 데이터 집합

https://modern-manual.tistory.com/19  
https://davincilabs.ai/blog/?q=YToxOntzOjEyOiJrZXl3b3JkX3R5cGUiO3M6MzoiYWxsIjt9&bmode=view&idx=10640969&t=board

22.12.10
## Q. 데이터베이스 함수 종속 중 완전 함수 종속, 부분 함수 종속, 이행적 함수 종속에 대해서 설명해주세요.(데이터베이스)

A.  
**함수 종속성**  
- DB에서 속성들 간 종속 관계를 의미하며, 불필요한 데이터 중복을 줄이고 데이터 베이스를 더욱 논리적으로 만드는 정규화를 위해 필요한 개념
- 어떤 테이블 R에 존재하는 필드들의 부분 집합을 각각 X와 Y라고 할 때, X의 한 값이 Y에 속한 값에만 매핑될 경우는 Y는 X에 함수 종속적이라고 하며 X -> Y로 표기
- 이때 X를 결정자, Y를 종속자라고 부름

**완전 함수 종속(Full Functional Dependency)**  
- 기본키가 종속자이며 기본키가 여러 속성으로 구성되어 있을 경우 기본키를 구성하는 모든 속성이 포함된 부분 집합 또한 종속자일 경우

**부분 함수 종속(Partial Functional Dependency)**  
- 릴레이션에서 종속자가 기본키가 아닌 다른 속성에 종속되거나, 기본키를 구성하는 여러 속성들의 부분집합 중 일부분에만 종속되어 있는 경우

**이행적 종속(Transitive Dependency)**  
- X, Y, Z라는 3가지 부분집합을 가진 릴레이션에서 {X -> Y}이고 {Y -> Z}일 때 {Y -> Z}가 아니라면 암스트롱의 공리에 의해 {X -> Z}가 되는데 이 경우 X는 Z의 이행적 종속이라고 함

https://been2.tistory.com/40

22.12.11
## Q. 패킷교환방식과 회선교환방식의 차이에 대해 설명해주세요.(네트워크)

A.  
패킷교환방식  
- 전송하려는 데이터를 패킷이라는 단위로 나눠 네트워크망으로 뿌려주게 된다.
- 패킷에는 해당 데이터가 어떤 데이터의 몇 번째 데이터인지 정보와 최종 목적지에 대한 정보가 들어가있다.
- 위의 정보를 라우터가 보고 패킷을 최적경로를 향해 전달하게 된다.
- 이때 최적경로는 거리 뿐 아니라 망의 혼잡도(대역폭 사용률), 연결상태, 기타설정 등에 따라 달라질 수 있다.
- 특정한 데이터가 여러 개의 패킷으로 분해되어 전송되면, 패킷듣은 라우터에 의해 서로 다른 경로로 전송될 수 있고, 최종적으로 목적지에 모든 패킷이 전달되면 패킷의 순서를 통해 다시 원래의 데이터로 합지는 방식이다.

회선교환방식  
- 회선 독점을 통한 통신방식으로, 통신 회선을 설정하여 데이터를 교환하는 방식이다..
- 데이터 전송을 위한 전용선을 할당하고 해당 선로로 모든 데이터를 전송한다.
- 송신자의 모든 데이터는 동일한 경로로 전송된다.

https://youngq.tistory.com/72

22.12.12
## Q. 멀티 프로세스(Multi Process)와 멀티 쓰레드(Multi Thread)의 차이에 대해 설명해주세요.(운영체제)

A.  
**멀티 프로세스**  
- 두 개 이상 다수의 프로세서(CPU)가 협력적으로 하나 이상의 작업(Task)을 동시에 처리하는 것(병렬처리)
- 각 프로세스 간 메모리 구분이 필요하거나 독립된 주소 공간을 가져야 할 경우 사용

**멀티 쓰레드**  
- 하나의 프로세스에 여러 스레드로 자원을 공유하며 작업을 나누어 수행하는 것  

**차이점**  
- 멀티 스레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고 Context Switching이 빠른 장점이 있지만, 동기화 문제와 하나의 스레드 장애로 전체 스레드가 종료될 위험을 갖고 있음
- 멀티 프로세서는 하나의 프로세스가 죽더라도 다른 프로세스에 영향을 주지 않아 안정성이 높지만, 멀티 스레드보다 많은 메모리공간과 CPU 시간을 차지하는 단점이 있음
- 두 방법은 동시에 여러 작업을 수행하는 점에서 동일하지만, 각각의 장단이 있으므로 적용하는 시스템에 따라 적합한 동작 방식을 선택하고 적용해야 함

https://wooody92.github.io/os/%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9C/

22.12.13
## Q. 단일연결리스트와 이중연결리스트의 차이점에 대해 설명해주세요.(자료구조)

A.  
**단일연결리스트**  
- head 노드와 tail 노드를 제외한 각 노드는 데이터와 다음 노드의 주소를 가지고 있다.

**이중연결리스트**  
- head 노드와 tail 노드를 제외한 각 노드는 데이터와 이전 노드의 주소, 다음 노드의 주소를 가지고 있다.  

https://pstudio411.tistory.com/entry/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-Linked-List-Hash-Table

22.12.14
## Q. A* 알고리즘에 대해 설명해주세요.(알고리즘)

A.  
A*(A star) 알고리즘: 시작점과 목표점이 주어졌을 때 그 사이의 최단 경로를 찾아주는 길찾기 알고리즘의 하나. 주어진 탐색영역을 그리드로 나눠 2차원 배열로 단순화한 뒤, 시작점의 인접 사각형부터 시작하여 각 사각형에 경로 채점을 통해 최단 경로에 포함되는 사각형을 찾고 도착점에 도달하면 거꾸로 거슬러 올라가 경로를 저장한다.  

https://itmining.tistory.com/66

22.12.15
## Q. 가지치기(Pruning)에 대해 설명해주세요.(머신러닝)

A.  
- 의사결정나무 학습 알고리즘에서 과적합에 대응하기 위한 주요 수단
- 의사결정나무 학습에서 최대한 정확한 훈련 샘플의 분류를 위해 노드에 대한 분할과정이 지속적으로 반복되는데, 때로 과도한 반복은 가지 수를 지나치게 많이 만들어버림
- 이때 발생할 수 있는 문제는 훈련 샘플을 '너무 잘 학습하여 훈련 세트 자체의 어떤 특징들을 모든 데이터가 가지고 있는 일반적인 특성으로 착각하게 만드는' 과적합이며, 따라서 자발적으로 가지를 잘라 과적합 위험을 방지할 수 있도록 해야 함
- 가지치기: 의사결정나무에서 과적합을 방지하기 위해 적절한 수준에서 Terminal Node를 결합해주는 것

https://velog.io/@jhbale11/%EB%8B%A8%EB%8B%A8%ED%95%9C-%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D-4%EC%9E%A5-%EC%9D%98%EC%82%AC%EA%B2%B0%EC%A0%95%EB%82%98%EB%AC%B4

22.12.16
## Q. 데이터베이스에서 savepoint와 truncate에 대해 설명해주세요.(데이터베이스)

A.  
**DB 트랜잭션**  
- 데이터 처리의 한 단위
- DB는 데이터를 저장, 수정, 삭제하는 작업을 바로 물리적인 하드디스크에 저장된 데이터에 적용하지 않음(메모리단에서 적용됨)
- 이는 개발자가 실수로 잘못된 명령문을 입력했을 때 다시 원래 상태로 되돌리기 위한 안전 장치
- 개발자가 commit을 하기 전까지 입력한 명령문은 메모리에서만 동작하다가 커밋이 발생하면 그때 하드디스크에 반영
- 데이터에 대한 작업을 하기 위해 입력하는 명령문들의 시작부터 커밋까지가 하나의 트랜잭션

**ROLLBACK**  
- 데이터의 저장, 삭제, 수정 등의 작업을 하고 난 후 원래의 상태로 되돌리는 작업
- 커밋 이후에는 롤백을 해도 커밋 전으로 돌아갈 수 없음

**COMMIT**  
- 하나의 트랜잭션을 물리적인 데이터베이스에 적용하는 작업
- 커밋을 하면 롤백을 해도 되돌릴 수 없음

**SAVEPOINT**  
- savepoint를 지정하면 rollback 시 해당 지정위치로 복원이 가능
- savepoint 명령어로 지점을 지정하고 rollback 명령어로 복원

**TRUNCATE**  
- 지정된 테이블의 모든 데이터를 지움
- 커밋이 자동으로 되므로 rollback이 불가능
- delete문은 DB에 바로 반영하지 않고 메모리에 적용 후 커밋이 되어야 적용이 되므로 rollback이 가능
- 반면에 truncate는 수행하는 순간 바로 커밋을 날려서 DB에 반영하므로 rollback이 불가능

https://ws-pace.tistory.com/154

22.12.17
## Q. DNS 서버 구성방식 중 하나인 DNS Round Robin에 대해 설명해주세요.(네트워크)

A.  
Domain에 대한 IP 요청 쿼리 시 round robin 방식, 즉 프로세스들 사이에 우선순위를 두지 않고 순서에 따라 시간단위로 IP를 반환한다.

https://velog.io/@eu_nzi/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-DNS-round-robin%EC%9D%98-%EB%B0%A9%EC%8B%9D

22.12.18
## Q. RAM과 ROM의 차이에 대해 설명해주세요.(운영체제)

A.  
**RAM**  
- Random Access Memory의 약어
- 휘발성 메모리(Volatile Memory)로, 전원이 차단되면 데이터가 사라짐
- CPU에 비해 하드디스크는 너무 느리기 때문에, 하드디스크보다 빠른 메모리(RAM)를 CPU와 하드디스크 사이에 위치
- 자주 쓰는 데이터를 RAM에 위치시켜 CPU에서 고속으로 처리 가능

**ROM**  
- Read Only Memory의 약어
- 비휘발성 메모리(Non-Volatile Memory)로, 전원이 차단되어도 데이터가 사라지지 않음
- BIOS(컴퓨터를 켰을 때 처음으로 시작되는 프로그램) 소프트웨어가 설치되어 있음

https://information-factory.tistory.com/270

22.12.19
## Q. Array의 특징과 장단점을 시간복잡도와 연관지어 설명해주세요.(자료구조)

A.  
**Array(배열)**  
- 연속된 메모리 공간에 순차적으로 저장된 데이터 모음으로, 선형 자료구조  
- 배열을 구성하는 각각의 값을 요소(element)라고 하며, 배열에서 위치를 가리키는 숫자는 인덱스(index)라고 함  

**배열의 시간 복잡도**  
| Operation | average case | worst case |
|-----------|--------------|------------|
| read      | O(1)         | O(1)       |
| insert    | O(n)         | O(n)       |
| delete    | O(n)         | O(n)       |
| search    | O(n)         | O(n)       |  

**장점**  
- 인덱스를 이용한 접근이 가능하기 때문에 모든 요소에 빠르게(O(1)) 접근할 수 있다

**단점**  
- 메모리가 순차적으로 이어져 있어야 하기 때문에, 중간에 특정 요소를 삽입 및 삭제하는 경우 해당 요소로부터 위에 있는 모든 요소들을 이동시켜줘야 하므로 삽입 및 삭제에 시간이 많이 걸림(O(n))

https://yoongrammer.tistory.com/43

22.12.20
## Q. 비트마스크로 집합을 구현할 때에, 모든 부분 집합을 순회하는 방식을 비트 마스크 연산자와 연관지어 설명해주세요.(알고리즘)  

A.  
부분 집합 순회를 위해 필요한 비트마스크 연산은 AND 연산(&)과 Shift(<<, >>) 연산이다.  
AND 연산은 두 정수 변수를 한 비트씩 비교하며 해당 비트가 둘 모두 켜져있으면(1이면) 비트를 켠다(1로 표시).  
Shift 연산은 어떤 정수의 비트들을 왼쪽 또는 오른쪽으로 원하는 만큼 움직이고, 빈 자리는 0으로 채우는 연산이다.  
먼저 정수 1을 집합 원소의 개수(n) 만큼 Shift 연산하여(2의 n승을 곱하여) 부분집합의 개수를 만들어 루프(i)시킨다.  
그 다음으로 집합 원소의 개수만큼 루프(j)시킨다.  
그리고 i와 1<<j의 AND 연산을 하여, i의 j번째 비트가 1이면 j번째 원소를 포함하게 하면 된다.  

https://rebro.kr/63  
https://j-ungry.tistory.com/137

22.12.21  
## Q. 앙상블(Ensemble)에 대해 설명해주세요.(머신러닝)  

A.  
- 앙상블 학습(Ensemble Learning)은 여러 개의 분류기를 생성하고, 그 예측을 결합함으로써 보다 정확한 예측을 도출하는 기법을 말함
- 강력한 하나의 모델을 사용하는 대신 보다 약한 모델 여러 개를 조합하여 더 정확한 예측에 도움을 주는 방식
- 여러 개의 분류기가 투표를 통해 최종 예측 결과를 결정하는 보팅(Voting) 방식, 데이터 샘플링(Bootstrap)을 통해 모델을 학습시키고 결과를 집계(Aggregating)하는 배깅(Bootstrap AGGregatING, Bagging) 방식, 여러 개의 분류기가 순차적으로 학습을 수행하며 이전 분류기가 예측이 틀린 데이터에 대해서 올바르게 예측할 수 있도록 다음 분류기에게 가중치(weight)를 부여하면서 학습과 예측을 진행하는 부스팅(Boosting) 방식이 있음

http://www.dinnopartners.com/__trashed-4/

22.12.22  
## Q. 데이터베이스에서 트리거와 프로시저의 차이점을 설명해주세요.(데이터베이스)  

A.  
**트리거(Trigger)**  
- 데이터베이스 시스템에서 데이터의 입력, 갱신, 삭제 등의 이벤트(Event)가 발생할 때마다 자동적으로 수행되는 절차형 SQL을 의미
- 트리거(trigger)는 사전적으로 '방아쇠'를 의미하며, 방아쇠를 당기면 자동으로 총알이 나가듯이 트리거는 테이블에 이벤트가 발생하면 자동으로 실행됨
- DCL은 사용할 수 없고, DDL, DML은 사용할 수 있음

**프로시저(Procedure)**  
- 특정 기능을 수행하는 일종의 트랜잭션 언어로, 호출을 통해 실행되어 미리 저장해놓은 SQL작업을 수행함  
- 처리결과를 반환하지 않거나 한 개 이상의 값을 반환함
- 실행환경과 Stored Program 사이에 값을 전달하기 위해 IN, OUT, IN OUT 등의 파라미터를 사용함

https://hijjang2.tistory.com/392

22.12.23  
## Q. 자동 재전송 방식인 ARQ의 종류와 각 방식에 대해 설명해주세요.(네트워크)  

A.  
**ARQ**
- Automatic Repeat Request의 약자로, 자동 반복 요청을 의미. 에러가 발생한 경우 재전송을 요구하는 방식  

**Stop-and-Wait ARQ**  
- 수신측으로붜 ACK을 받을 때까지 대기하다가 전송하는 방법
- 반이중 방식으로 다른 ARQ 방식보다 전송 효율이 낮음
- 송신측은 프레임을 보냄과 동시에 타이머를 작동시킴, 수신측에서 보낸 ACK를 받으면 타이머가 멈춤
- 송신측은 전송한 프레임의 사본을 보관하고 있다가 타이머가 만료되면 해당 프레임을 다시 보냄 
- ACK이 오지 않은 경우 프레임이 손실, 중복, 순서 바뀜이 일어난 것으로 판단
- 수신자 쪽에서의 과정이 단순함

**Go-back-N ARQ**  
- 오류가 난 지점부터 전송한 지점까지 모두 재전송하는 기법
- 타이머가 만료되면 ACK가 오지 않은 프레임(sliding window의 첫 프레임)부터 재전송함
- ex) 6번 프레임을 보냈는데 3번 프레임의 타이머가 만료된 경우, 송신자는 뒤로 돌아가서 3, 4, 5, 6번 프레임을 다시 보냄

**Selective Repeat ARQ**  
- 오류가 난 부분만 재전송하는 기법
- NAK를 사용하여 개선할 수 있음
- NAK를 쓰게 되면 타이머가 만료되기 전에 해당 프레임을 재전송해야 한다는 것을 알 수 있으므로 빠른 재전송이 가능함
- 수신자 쪽에서의 과정이 복잡함

**Adaptive ARQ**  
- 전송 효율을 최대한 높이기 위해 데이터 프레임의 길이를 동적으로 변경하여 전송함
- 수신측이 송신측에게 수신한 데이터 프레임을 감지하고 오류 발생률을 판단하여 송신측에 오류 발생률을 통보하면 송신측은 통신회선의 오류 발생률이 낮으면 긴 프레임임을, 높으면 짧은 프레임을 전송함

https://www.uname.in/211

22.12.24  
## Q. 운영체제란 무엇인가요? 운영체제가 필요한 이유는 무엇이고 하는 역할은 무엇인가요?(운영체제)

A.  
**운영체제(OS, Operating System)**  
- 컴퓨터 시스템과 사용자 사이에서 중개자 역할을 하는 시스템 소프트웨어
- 사용자가 컴퓨터를 사용하는 데에 있어 대부분의 작업을 운영체제가 처리해줌
- 하드웨어와 사용자 사이의 인터페이스를 제공하고, 한정적인 시스템 자원을 보다 효율적으로 사용할 수 있도록 도와줌

**운영체제가 필요한 이유**
- 사용자의 요청에 대하여 빠르고 정확하게 시스템 자원을 제공하고 많은 양의 데이터를 처리해주기 위해
- 사용자 측면: 사용자가 편리하게 원하는 동작을 수행할 수 있도록 하기 위해
- 시스템 측면: 어떠한 동작을 최대한 효율적으로 무리없이 구동하기 위해
    - 처리능력: 같은 시간동안 처리할 수 있는 작업량
    - 응답시간: 사용자의 요청에 대한 결과를 산출하기까지 소요되는 시간
    - 신뢰성: 시스템이 산출한 결과의 정확성
    - 사용 가능성: 사용자의 요구에 시스템 자원을 지원 여부

**운영체제의 역할**
- 프로세스 관리
    - 프로세스의 생성, 제거, 중지, 재시작, 동기화
    - 프로세스간 통신
    - 교착상태 방지 기법 등을 제공
- 기억장치 관리
    - 주기억장치 이용 프로세스 파악
    - 주기억장치에 프로세스를 적재 및 회수 
- 입출력장치 관리
    - 입출력장치의 상태 파악
    - 입출력장치 스케줄링
- 정보 관리
    - 파일 생성 및 제거
    - 파일 & 디렉토리 관리

https://g0pher.tistory.com/343

22.12.25
## Q. 인접행렬과 인접리스트의 장단점에 대해 설명해주세요.(자료구조)  

A.  
**인접행렬**  
- Vertex * Vertex 크기의 행렬을 만들어서, 어느 두 개의 Vertex가 Edge로 연결되어 있다면 1을, 그렇지 않다면 0을 넣어 그래프를 표현하는 방식
- 장점: 구현이 간편하고, Vertex끼리 연결되어 있는지 확인하고 싶으면 graph[i][j]만 확인하면 되기 때문에 탐색(접근)이 빠르다
- 단점: 메모리가 많이 들고(N<sup>2</sup>), 노드에 비해 간선이 너무 적으면 비효율적이다

**인접리스트**  
- 각 노드(Vertex)에 대한 간선(Edge) 연결 정보를, Vertex 순서대로 자신이 연결된 Vertex 번호를 원소로 갖는 리스트로 표현하고, 이를 다시 리스트에 담아 그래프를 표현하는 방식
- 장점: 특정 노드에 연결된 노드(Vertex)를 찾기가 쉽고, 간선의 개수만큼만 메모리가 생성되기 때문에 메모리 측면에서 효율적이다
- 단점: 정점(Vertex) 간의 연결 관계를 알고 싶을 때 탐색이 느리고, 간선이 많으면 비효율적이다

https://dailymapins.tistory.com/29

22.12.26  
## Q. 비트마스크로 집합을 구현할 때, 원소의 포함 여부 확인 방식을 비트마스크 연산자와 연관지어 설명해주세요.(알고리즘)  

A.  
if(A & (1 << k))로 원소의 포함 여부를 확인할 수 있다. 여기서 A는 집합, k는 포함 여부를 확인하고 싶은 원소의 순서이다.  
1 << k는 1을 k만큼 shift 연산하는 것으로, n번째 원소의 비트를 나타낸다.  
&은 양쪽 모두 1이면 1, 둘 중 하나라도 0이면 0을 표시하는 연산이다.  
따라서 if(A & (1 << k))를 사용하여, A집합에 k번째 원소가 포함되어있다면 1(True)이, 포함되어있지 않다면 0(False)이 표시될 것이다.

https://rebro.kr/63

22.12.27  
## Q. 머신러닝과 데이터마이닝의 차이에 대해 설명해주세요.(머신러닝)  

A.  
**데이터마이닝(Data Mining)**  
- 다양한 관점에서 데이터를 분석해 의미를 도출(데이터의 특징을 알아내는 것이 중점)  
- 보유한 데이터를 다양한 관점에서 분석하고, 그 결과를 유용한 정보로 조합하는 일
- 방대한 데이터 속에 숨어있던 패턴과 상관성을 통계적 수법들로 식별하여 가치를 부여
- 숫자가 아닌 데이터도 처리한다는 점에서 통계처리와 구분
- 기법에는 일번적으로 연관(association), 회귀(regression) 및 분류(classification)라는 세 가지 유형이 있음

**머신러닝(Machine Learning)**  
- 데이터마이닝이나 기타 학습 알고리즘을 사용하여 지식을 추출하고 이를 경험기반으로 삼아 비슷한 상황의 미래 사건의 결과를 예측(현재 데이터를 가지고 학습한 뒤, 미래를 예측하는 것에 중점)  
- 인공지능의 한 분야
- 데이터의 패턴을 발견하는 핵심 알고리즘이 동일하지만, 머신러닝은 자체 학습 알고리즘을 사용하며 시간이 경과함에 따라 경험을 축적하면서 작업 성능이 향상됨
- 데이터를 모델링하는 알고리즘은 여러가지가 있지만, 크게 지도학습(Supervised Learning), 비지도학습(Unsupervised Learning), 강화학습(Reinforcemenet Learning)으로 분류됨

https://dalsacoo-log.tistory.com/entry/difference-in-terms-of-ai

22.12.28
## Q. Inner JOIN, Outer JOIN의 차이점에 대해서 설명해주세요.(데이터베이스)  

A.  
**Inner JOIN**(내부 조인)  
- 키 값이 있는 테이블의 컬럼 값을 비교 후 조건에 맞는 값을 가져오는 것. 간단히 말하면 서로 연관된 내용만 검색하는 조인 방법

**Outer JOIN**(외부 조인)  
- 조인하는 여러 테이블에서 한 쪽에는 데이터가 있고 한 쪽에는 데이터가 없는 경우, 데이터가 있는 쪽 테이블의 내용을 전부 출력하는 방법. 즉, 조인 조건에 만족하지 않아도 해당 행을 출력하고 싶을 때 사용할 수 있음  

https://clairdelunes.tistory.com/22

22.12.29
## Q. 전송계층의 프로토콜인 TCP와 UDP의 특징을 설명해주세요.(네트워크)  

A.  
**TCP**(Transmission Control Protocol)  
- 전송을 제어하는 프로토콜(규약)
- 인터넷상에서 데이터를 메시지 형태로 보내기 위해 IP와 함께 사용하는 프로토콜
- IP가 데이터의 배달을 처리한다면 TCP는 패킷을 추적 및 관리
- 연결 지향 방식
- 3-way handshaking 과정을 통해 연결을 설정하고 4-way handshaking을 통해 해제
- 흐름 제어 및 혼잡 제어
- 높은 신뢰성을 보장
- UDP보다 속도가 느림
- 전이중(Full-Duplex), 점대점(Point to Point) 방식

**UDP**(User Datagram Protocol)  
- 사용자 데이터그램 프로토콜(규약)
- 데이터를 데이터그램 단위로 처리하는 프로토콜
- TCP는 연결형 프로토콜이지만 UDP는 비연결형 프로토콜
- 연결을 위해 할당되는 논리적인 경로가 없기 때문에 각각의 패킷은 다른 경로로 전송되고, 이때 각각의 패킷과 데이터를 서로 다른 경로로 독립적으로 처리하는 프로토콜
- 비연결형 서비스로 데이터그램 방식을 제공
- 정보를 주고 받을 때 정보를 보내거나 받는다는 신호절차를 거치지 않음
- UDP헤더의 CheckSum 필드를 통해 최소한의 오류만 검출함
- 신뢰성이 낮음
- TCP보다 속도가 빠름

https://mangkyu.tistory.com/15

22.12.30  
## Q. 컴파일러와 인터프리터의 차이가 무엇인가요?(운영체제)  

A.  
**컴파일러**  
- 전체 소스코드를 보고 명령어를 수집하고 재구성함
- 컴파일링을 하는 동안 걸리는 시간은 다소 길지만 컴파일이 완료되면 실행속도는 빠름
- 고레벨 언어를 바로 기계어로 변환함
- 젠처 소스코드 변환 후 에러를 보고함

**인터프리터**  
- 소스코드의 각 행을 연속적으로 분석하며 실행함
- 인터프리팅 속도는 빠르지만 실행속도는 느림
- 고레벨 언어를 중간 코드로 변환하고 이를 각 행마다 실행함
- 각 행마다 실행하는 도중 에러가 보고되면 이후 작성된 코드를 보지 않아 보안 관점에서 도움이 됨

**장단점**  
|                 |                          컴파일러                         |                       인터프리터                       |
|:---------------:|:---------------------------------------------------------:|:------------------------------------------------------:|
|   개발 편의성   |    코드를 수정하고 실행하려면 컴파일을 다시 해야 한다.    |          코드를 수정하고 즉시 실행할 수 있다.          |
|    실행 속도    |                          빠르다.                          |                         느리다.                        |
|       보안      |             프로그램의 코드가 유출되지 않는다.            |            프로그램의 코드가 유출될 수 있다.           |
|    파일 용량    | 프로그램의 실행 파일 전체를 전송해야 하므로, 용량이 크다. | 프로그램의 코드만 전송하면 실행이 되므로, 용량이 작다. |
| 프로그래밍 언어 |           C, C++처럼 비교적 저수준에 가까운 언어          |      Python, Ruby처럼 비교적 고수준에 가까운 언어      |

https://velog.io/@jaeyunn_15/OS-Compiler-vs-Interpreter

22.12.31
## Q. 컨테이너 어댑터의 종류와 각각의 특징에 대해 설명해주세요.(자료구조)  

A.  
**스택**(stack)  
- vector 클래스의 인터페이스를 제한하여, 전형적인 스택 메모리 구조의 인터페이스를 제공함
- stack 헤더 파일에 정의되어 있음
- empty(), size(), top(), push(), pop() 등의 멤버 함수를 제공함
- 요소에 대한 임의 접근을 허용하지 않을 뿐만 아니라, 스택을 순회하는 반복자도 허용하지 않음

**큐**(queue)  
- deque 클래스의 인터페이스를 제한하여, 전형적인 큐 메모리 구조의 인터페이스를 제공함
- queue 헤더 파일에 정의되어 있음
- empty(), size(), front(), back(), push(), pop() 등의 멤버 함수를 제공함

**우선순위 큐**(priority_queue)  
- 큐의 맨 앞의 요소로 가장 먼저 저장된 요소가 아닌, 가장 큰 값을 지닌 요소가 위치하게 됨
- 큐가 deque 클래스를 기반으로 하는 것과는 달리, vector 클래스를 기반으로 함
- queue 헤더 파일에 정의되어 있음
- 큐 컨테이너와 같은 멤버 함수를 제공함

http://www.tcpschool.com/cpp/cpp_container_adapter

23.01.01
## Q. 비트마스크로 집합을 구현할 때에, 최소 원소를 찾는 방식을 비트마스크 연산자와 연관지어 설명해주세요.(알고리즘)  

A.  
**구현**
- A & (-A)  

**비트마스크 연산자**
- AND 연산(&)과 NOT 연산(~)을 통해 집합의 최소 원소를 찾을 수 있다  
- AND 연산은 비교하는 두 변수의 각 비트 자리가 둘 다 켜져 있는 경우(1인 경우) 해당 비트에 1을, 둘 중 하나라도 꺼져있는 경우 해당 비트에 0을 반환하는 연산이다
- NOT 연산은 정수 하나를 입력받아 켜져 있는 비트는 끄고 꺼져 있는 비트는 켠 결과를 반환하는 연산이다

**설명**  
- 집합 A에 포함된 가장 작은 원소(index가 가장 작은 원소), 즉 켜져있는 bit 중에서 가장 오른쪽에 있는 bit를 찾는 방법이다
- 컴퓨터는 2의 보수를 이용하여 음수를 표현하기 때문에 -A는 (~A + 1)을 이용한다
- A에서 가장 오른쪽에 켜진 bit의 인덱스를 k라고 한다면, k보다 오른쪽에 있는 모든 bit는 0이다
- 따라서 NOT 연산을 적용한 ~A의 k번째 bit는 0이고, k보다 오른쪽의 모든 bit는 1이다
- 여기에 1을 더하면 k는 1이 되고, k보다 오른쪽의 모든 bit는 0이 되고, k보다 왼쪽의 bit는 A에서 1이라면 0, A에서 0이라면 1이 된다
- 따라서 A와 (-A)를 AND 연산하게 되면 가장 k번째 bit만 켜진 상태가 되므로 최소 원소를 찾을 수 있다

https://rebro.kr/63

23.01.02  
## Q. 차원의 저주와 이를 해결하는 방법에 대해 설명해주세요.(머신러닝)  

A.  
**차원의 저주**  
- 차원이 증가하면서 학습데이터 수가 차원 숩다 적어져서 성능이 저하되는 현상
- 차원이 증가할수록 변수가 증가하고, 개별 차원 내에서 학습할 데이터 수가 적어짐
- 변수가 증가한다고 반드시 차원의 저주가 발생하는 것은 아니며, 관측치보다 변수 수가 많아지는 경우에 차원의 저주 문제가 발생함

**해결 방법**  
- 이론적으로는 훈련 샘플의 밀도가 충분히 높아질 때까지 데이터를 모아서 훈련 세트의 크기를 키우는 방법이 있음
- 그러나 일정 밀도에 도달하기 위해 필요한 훈련 샘플 수는 차원의 수가 커짐에 따라 기하급수적으로 늘어남
- 따라서 현실적으로는 PCA와 같은 차원축소 기법을 이용해서 해결함
- 특성 수를 크게 줄여 차원축소를 하면 훈련 속도가 빨라지고 시각화하기에도 좋음
- 다만 일부 정보가 유실되기 때문에 성능도 조금 나빠질 수 있으므로, 무작정 차원축소를 하기보다는 원본 데이터로 훈련해서 시간이 오래 걸리는지 확인하고 차원축소 여부를 결정할 필요가 있음

https://for-my-wealthy-life.tistory.com/40

23.01.03  
## Q. 트랜잭션의 각 격리 수준에 대해서 설명하고, 각 수준에서 일어날 수 있는 문제에 대해 설명해주세요.(데이터베이스)  

A.  
**트랜잭션 격리 수준(isolation level)**  
- 동시에 여러 트랜잭션이 처리될 때, 트랜잭션끼리 얼마나 서로 고립되어 있는지를 나타내는 것
- 특정 트랜잭션이 다른 트랜잭션에서 변경한 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것
- 크게 READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE의 4개로 나뉘고, 순서대로 트랜잭션 간 고립 정도가 높아지며 성능이 떨어지는 것이 일반적

**READ UNCOMMITTED**  
- 어떤 트랜잭션의 변경내용이 COMMIT이나 ROLLBACK과 상관없이 다른 트랜잭션에서 보임
- COMMIT 하지 않은 변경 내용이 다른 트랜잭션에서 조회되는(더티 리드, Dirty Read) 데이터 정합성 문제가 생길 수 있음

**READ COMMITTED**  
- 어떤 트랜잭션의 변경 내용이 COMMIT 되어야만 다른 트랜잭션에서 조회할 수 있음  
- 다른 트랜잭션에서, COMMIT 하기 전에 조회된 내용과 COMMIT 한 후의 조회된 내용이 달라지므로, 하나의 트랜잭션에서 똑같은 SELECT를 수행했을 경우 항상 같은 결과를 반환해야 한다는 REPEATABLE READ 정합성에 어긋나는 문제(REPEATABLE READ 부정합 문제)가 생길 수 있음

**REPEATABLE READ**  
- 트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회할 수 있음
- 자신의 트랜잭션보다 낮은 트랜잭션 번호에서 변경되고 COMMIT된 내용만 보임
- 한 트랜잭션이 실행되던 중 다음 트랜잭션에서 UPDATE를 하게 되면, 기존 트랜잭션에서 그 이후 실행하는 UPDATE가 실행되지 않는 UPDATE 부정합 문제가 생길 수 있음
- 한 트랜잭션 내에서 같은 쿼리를 두 번 실행했는데, 첫 번째 쿼리에서 없던 유령(Phantom) 레코드가 두 번째 쿼리에서 나타나는 Phantom READ 문제가 생길 수 있음

**SERIALIZABLE**  
- 가장 단순하고 가장 엄격한 격리수준
- 읽기 작업에도 공유 잠금을 설정하여, 동시에 다른 트랜잭션에서 이 레코드를 변경하지 못하게 됨
- 동시처리 능력이 다른 격리수준보다 떨어지고, 성능저하가 발생하는 문제가 생길 수 있음

https://joont92.github.io/db/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B2%A9%EB%A6%AC-%EC%88%98%EC%A4%80-isolation-level/

23.01.04  
## Q. TCP의 대표적인 3가지 제어에 대해 설명해주세요.(네트워크)  

A.  
**TCP의 제어 기능**
- 흐름 제어: 전송되는 데이터의 양을 조절
- 오류 제어: 데이터가 유실되거나 잘못된 데이터가 수신되었을 경우 대처
- 혼잡 제어: 네트워크 혼잡에 대처

**흐름 제어**
- 송신 측과 수신 측의 데이터 처리 속도는 서로 다를 수 있음
- 송신 측의 속도가 빠를 때 수신 측 버퍼가 넘치는 오버플로우 문제가 발생함
- 이러한 문제를 줄이기 위해 윈도우 크기로 송신 측의 데이터 전송량을 조절함
- 상대방에게 데이터를 보낸 후 잘 받았다는 응답이 올 때까지 기다리는 stop and wait 방식과, 송신 측이 수신 측에서 받은 윈도우 크기를 참고해서 데이터의 흐름을 제어하는 sliding window 방식이 있음

**오류 제어**
- TCP는 통신 중에 오류가 발생하면 해당 데이터를 재전송하는 재전송 기반 오류 제어(ARQ, Automatic Repeat reQuest)를 사용함
- 재전송은 비효율적이므로 적을수록 좋기에, 오류를 알 수 있는 효율적인 방법이 필요함
- ACK(긍정 응답)을 받고 나서 다음 데이터를 보내는 Stop and Wait 방식, 연속으로 데이터를 보내다가 오류가 발생한 지점부터 재전송하는 Go Back N 방식, 오류가 발생한 데이터만 재전송하는 Selective Repeat 방식 등이 있음

**혼잡 제어**
- 네트워크 내에 패킷의 수가 과도하게 증거하는 현상을 혼잡이라고 함
- 혼잡 제어는 혼잡 현상을 방지하고 제거하기 위한 기능임
- AIMD(Additive Increase / Multiplicative Decrease)
    - 처음에 패킷을 하나씩 보내고 문제가 발생하지 않으면 윈도우 크기를 1씩 증가시킴
    - 패킷 전송에 실패하거나 일정 시간을 넘으면 패킷 전송 속도를 절반으로 줄임
- Slow Start(느린 시작)
    - AIMD와 같이 패킷을 하나씩 보내고 문제가 발생하지 않으면 각 ACK 패킷마다 윈도우 크기를 1씩 늘려줌, 즉 한 주기가 지나면 윈도우 크기는 2배가 됨
    - AIMD와 달리 전송 속도를 지수 함수 꼴로 증가시켜서 윈도우 크기를 더 빠르게 증가시킴
    - 혼잡이 감지되면 윈도우 크기를 1로 줄임
- Fast Retransmit(빠른 재전송)
    - TCP는 지금까지 받은 데이터 중 연속되는 패킷의 마지막 순번 이후를 ACK 패킷에 실어서 보냄
    - timeout이 발생하기 전이라도 문제 되는 패킷을 재전송할 수 있으며, 혼잡한 상황이라고 판단되면 윈도우 크기를 줄임
- Fast Recovery(빠른 회복)
    - 혼잡한 상태가 되면 윈도우 크기를 1이 아니라 반으로 줄이고, 선형 증가시킴
    - 혼잡 상황을 한 번 겪은 이후로는 AIMD 방식으로 동작함

https://benlee73.tistory.com/186

23.01.05
## Q. context switching에 대해 설명해주세요.(운영체제)  

A.  
**Context Switching**
- CPU가 한 개의 Task(Process/Thread)를 실행하고 있는 상태에서 Interrupt 요청에 의해 다른 Task로 실행이 전환되는 과정에서 기존의 Task 상태 및 Register 값들에 대한 정보(Context)를 저장하고 새로운 Task의 Context 정보로 교체하는 작업
- Context란, CPU가 다루는 Task(Process/Thread)에 대한 정보로 대부분의 정보는 Register에 저장되며 PCB(Process Control Block)으로 관리됨
- Process와 Thread를 처리하는 Context Switching은 조금 다른데, PCB는 OS에 의해 스케줄링되는 Process Control Box이고, Thread의 경우 Process 내의 TCB(Task Control Box)라는 내부 구조를 통해 관리됨
- Context Switching 진행 시 CPU는 Cache를 초기화하고 Memory Mapping을 초기화하는 작업을 거치는 등 아무 Task도 수행하지 못하므로 잦은 Context Switching은 성능 저하를 가져옴

https://jins-dev.tistory.com/entry/%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%8A%A4%EC%9C%84%EC%B9%98Context-Switching-%EC%97%90-%EB%8C%80%ED%95%9C-%EC%A0%95%EB%A6%AC

23.01.07  
## Q. BFS(Breadth-First Search)와 DFS(Depth-First Search)에 대해 설명해주세요.(자료구조)  

**그래프의 탐색**  
- 그래프: 정점(node)과 그 정점을 연결하는 간선(edge)으로 이루어진 자료구조  
- 그래프 탐색: 하나의 정점으로부터 시작하여 차례대로 모든 정점들을 한 번씩 방문하는 것  

**BFS(Breadth-First Search, 너비 우선 탐색)**  
- 최대한 넓게 이동한 다음, 더이상 옆으로 갈 수 없을 때 아래로 이동  
- 루트 노드(혹은 다른 임의의 노드)에서 시작해서 인접한 노드를 먼저 탐색하는 방법
- 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져있는 정점을 나중에 방문하는 순회 방법
- 주로 두 노드 사이의 최단 경로를 찾고 싶을 때 이 방법을 선택함

**DFS(Depth-First Search, 깊이 우선 탐색)**  
- 최대한 깊이 내려간 뒤, 더이상 깊이 갈 수 없을 때 옆으로 이동
- 루트 노드(혹은 다른 임의의 노드)에서 시작해서 다음 분기(brach)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방식
- 모든 노드를 방문하고자 하는 경우에 이 방법을 선택함
 
**BFS와 DFS 비교**  
|            BFS(너비우선탐색)            |                 DFS(깊이우선탐색)                 |
|:---------------------------------------:|:-------------------------------------------------:|
| 현재 정점에 연결된 가까운 점들부터 탐색 | 현재 정점에서 갈 수 있는 점들까지 들어가면서 탐색 |
|            큐를 이용해서 구현           |             스택 또는 재귀함수로 구현             |

https://devuna.tistory.com/32

23.01.08
## Q. 비트마스크의 개념과 장점에 대해 설명해주세요.(알고리즘)  

A. **비트마스크(BitMask)**  
- 이진수를 사용하는 컴퓨터의 연산 방식을 이용하여, 정수의 이진수 표현을 자료 구조로 쓰는 기법
- 이진수는 0 또는 1을 이용하므로 하나의 비트(bit)가 표현할 수 있는 경우는 두 가지임
- 1을 "켜져 있다", 0을 "꺼져 있다"고 함

**비트마스크의 장점**  
- 연산의 수행 시간이 $O(1)$로 매우 빠름
- 다양한 집합 연산들을 반복문, 조건문에 비해 훨씬 짧고 간결하게 코드를 작성할 수 있음
- 매우 많은 경우의수를 비트로 표현할 수 있기 때문에 메모리 사용량이 훨씬 적고 효율적임

https://rebro.kr/63

23.01.09
## Q. 1종 오류와 2종 오류에 대해 예시를 들어 설명해주세요.(머신러닝)

A.  
**사건과 귀무가설**  
통계학에서는 아무일도 일어나지 않았음을 가정하는 귀무가설(Null Hypothesis)을 세운 뒤, 귀무가설을 채택하거나 기각함으로써 어떤 사건(Alternative Hypothesis)이 일어났는지를 검정함

**1종 오류(type I error)**  
- 귀무가설이 참인데 잘못 판단해 기각해버리는 오류
- 예) 아파트에 불이 나지 않았는데(아무일도 일어나지 않았다는 귀무가설이 참), 화재 경보가 울림(귀무가설을 기각함)

**2종 오류(type II error)**  
- 귀무가설이 거짓인데 잘못 판단해 기각하지 않는 오류
- 예) 아파트에 불이 났는데(아무일도 일어나지 않았다는 귀무가설이 거짓), 화재 경보가 울리지 않음(귀무가설을 기각하지 않음)

https://angeloyeo.github.io/2021/01/26/types_of_errors.html#disqus_thread

23.01.10
## Q. 데이터베이스의 반정규화의 정의와 그 종류에 대해서 간략하게 설명해주세요.(데이터베이스)

A.  
**반정규화(De-Normalization)**  
- 데이터베이스의 성능 향상을 위하여, 데이터 중복을 허용하고 조인을 줄이는 방법
- 조희(SELECT) 속도를 향상시키지만, 데이터 모델의 유언성은 낮아짐
 
**반정규화의 종류**  
- 테이블 통합: 두 개의 테이블이 조인되어 있는 경우 하나의 테이블로 합쳐 사용하는 방법
- 테이블 분할: 테이블을 수직 또는 수평으로 분할하는 방법
- 중복 테이블 추가: 여러 테이블에서 데이터를 추출해서 사용해야 하거나 다른 서버에 저장된 테이블을 이용해야 하는 경우 테이블을 추가하는 방법
- 중복 속성 추가: 조인해서 데이터를 처리할 때 데이터를 조회하는 경로를 단축하기 위해 자주 사용하는 속성을 추가하는 방법

https://velog.io/@yewon-july/De-Normalization  
https://lipcoder.tistory.com/337

23.01.11
## Q. DNS와 DHCP를 설명해주세요.(네트워크)  

A.  
**DNS(Domain Name System)**  
- 도메인 이름을 IP 주소로 매핑하는 시스템
- 인터넷상의 호스트 이름과 고유한 숫자 주소(논리적 주소)를 매핑하는 디렉토리 검색 서비스를 제공하는 매커니즘

**DHCP(Dynamic Host Configuration Protocol)**  
- 정적 또는 동적으로 네트워크의 호스트에 IP를 할당하는 프로토콜
- 호스트별 구성 매개 변수를 DHCP 서버에서 호스트로 전송하는 역할의 프로토콜과, 호스트 간에 네트워크 주소를 할당하는 역할의 매커니즘으로 구성되어 있음

**DNS와 DHCP의 차이점**  
- DNS는 호스트의 이름 또는 이름으로 주소를 확인하고 재귀적으로 확인하는 데 사용되는 반면 DHCP는 네트워크의 호스트에 동적 또는 정적으로 주소를 할당하는 데 사용됨
- DHCP는 포트 번호 53을 사용하는 반면 DHCP는 67 또는 68을 사용할 수 있음
- DNS 서버는 클라이언트를 통해 쿼르를 수락하고 결과와 함께 클라이언트에 응답하는 반면 DHCP 서버는 임대 시간 동안 클라이언트 시스템에 임시 주소를 할당한 다음 요구 사항에 따라 임대를 연장함
- DNS는 모든 도메인 이름을 한 곳에서 저장하지 않고 하위 도메인으로 분할한 다음 특정 정보를 특정 서버에 저장하는 특정 계층 구조를 따르므로 분권화되어있는 반면 DHCP 서버는 IP 주소 풀에서 클라이언트의 IP 주소를 구성하고 모든 작업을 중앙에서 처리하므로 DHCP 서버가 클라이언트에 직접 연결되어있지 않으면 라우터를 사용하여 DHCP 브로드 캐스트를 수신하고 릴레이함

https://ko.gadget-info.com/difference-between-dns

23.01.12  
## Q. 동기(Synchronous)와 비동기(Asynchronous), 블로킹(Blocking)과 논-블로킹(Non-blocking)에 대해 설명해주세요.(운영체제)

A.  
- I/O 작업은 user space에서 직접 수행할 수 없기 때문에 user process가 kernel에 I/O 작업을 '요청'하고 '응답'을 받는 구조
- 응답을 어떤 순서로 받는지(synchronous/asynchronous), 어떤 타이밍에 받는지(blocking/non-blocking)에 따라 여러 모델로 분류됨

**동기 작업(Synchronous)**  
- 작업이 한 번에 하나씩 수행되며 진행 중인 작업이 끝나기 전까지는 해당 작업 외의 다른 작업을 수행하지 못함
- 모든 I/O 요청-응답 작업이 일련의 순서를 따르므로 작업의 순서가 보장됨
- 작업 완료를 user space에서 판단하고 다음 작업을 언제 요청할지 결정함
- 일련의 Pipeline을 준수하는 구조에서 효율적임

**비동기 작업(Asynchronous)**  
- 한 번에 하나 이상의 작업이 수행될 수 있으므로 현재 작업을 진행 중이더라도 다른 작업을 수행할 수 있음
- 작업에 대한 결과를 바로 원하지 않음
- kernel에 I/O 작업을 요청해두고 다른 작업 처리가 가능하나, 작업의 순서는 보장되지 않음
- 작업 완료를 kernel space에서 통보해줌
- 각 작업들이 독립적이거나, 작업 별 지연이 큰 경우 효율적임

**블로킹(Blocking)**  
- 동기 작업 중에 I/O를 받아 오기 전까지 프로그램을 멈추어 비동기 수행을 할 수 있게 하는 것
- Blocking 시간에 다른 작업을 할 수 있게 됨
- Thread가 Blocking 된다는 것은 CPU가 점유되어 실행되지 못함을 의미함

**논-블로킹(Non-Blocking)**  
- Wait 하지 않고 작업이 그냥 수행됨
- 자신이 호출되었을 때 즉 System call을 받았을 때 제어권을 바로 자신을 호출한 쪽으로 넘겨 다른 작업을 할 수 있도록 하는 것을 의미
- Thread가 Waiting하지 않으므로 CPU 제어는 그대로임

https://luv-n-interest.tistory.com/1121

23.01.13
## Q. Array의 특징과 장단점을 시간복잡도와 연관지어 설명해주세요.(자료구조)

A.  
**Array(배열)**
- 데이터 간 순서 관계를 나타내는 선형 자료구조  
- 연속된 메모리 공간에 순차적으로 저장된 데이터 모음
- 배열을 구성하는 각각의 값을 요소(element), 배열에서 위치를 가리키는 숫자를 인덱스(index)라고 함

**특징**  
- 배열의 각 요소에 접근하는 시간은 $O(1)$으로 속도가 빠름
  - 기본위치(배열이 시작하는 지점) + 오프셋(요소크기 * 인덱스) 연산으로 모든 요소에 빠른 접근 가능
- 연속된 메모리에 단일 블록화하여 데이터를 저장함
  - 낭비되는 공간이 거의 없는 장점이 있지만 큰 배열의 경우 필요 메모리 할당이 불가능할 수 있음

**장점**  
- 모든 요소에 빠른 접근이 가능함( $O(1)$ )
- 기록 밀도가 1이므로 공간 낭비가 적음

**단점**  
- element를 삽입 및 삭제하는 경우 그 뒤의 모든 요소를 이동해야 하므로 시간이 오래 걸림( $O(n)$ )
- 특정 요소를 탐색하기 위해서도 시간이 오래 걸림( $O(n)$ )

https://yoongrammer.tistory.com/43

23.01.14
## Q. 최소 공통 조상 알고리즘의 동작 방식에 대해 설명해주세요.(알고리즘)

A.  
**최소 공통 조상 알고리즘(LCA, Lowest Common Ancestor)**  
두 노드의 공통된 조상 중에서 가장 가까운 조상을 찾는 알고리즘
1. 모든 노드에 대한 깊이를 계산함
2. 최소 공통 조상을 찾을 두 노드를 확인함
3. 먼저 두 노드의 깊이가 동일하도록 거슬러 올라감
4. 부모가 같아질 때까지 반복적으로 두 노드의 부모 방향으로 거슬러 올라감
5. 모든 LCA(a, b) 연산에 대해 3~4번의 과정을 반복함

https://velog.io/@shiningcastle/%EC%B5%9C%EC%86%8C-%EA%B3%B5%ED%86%B5-%EC%A1%B0%EC%83%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98

23.01.15
## Q. 서포트 벡터 머신(SVM)에 대해 설명해주세요.(머신러닝)

A.  
**서포트 벡터 머신(SVM, Support Vector Machine)**  
- 주어진 데이터가 어느 카테고리에 속할지 판단하는 이진 선형 분류 모델
- 선과 가장 가까운 포인트인 서포트 벡터(Support Vector)와 구분선의 거리를 의미하는 Margin을 최대화하게끔 구분선을 결정함
- 동시에 아웃라이어(outlier)의 영향을 받지 않는 robustness도 최대화함

https://bkshin.tistory.com/entry/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D-2%EC%84%9C%ED%8F%AC%ED%8A%B8-%EB%B2%A1%ED%84%B0-%EB%A8%B8%EC%8B%A0-SVM

23.01.16  
## Q. 대표적인 SQL종류 3가지에 대해서 설명하고, 종류별 명령어를 아는 만큼 나열해주세요.(데이터베이스)

A.  
DML(Data Manipulation Language)  
- 테이블의 데이터를 조작하는 명령어
- INSERT: 데이터베이스 객체에 데이터를 삽입
- DELETE: 데이터베이스 객체에서 데이터를 삭제
- UPDATE: 데이터베이스 객체 안의 데이터를 수정
- SELECT: 데이터베이스 객체 안의 데이터를 조회

DDL(Data Definition Language)
- 데이터베이스, 테이블의 스키마를 정의, 수정, 삭제하는 명령어
- CREATE: 데이터베이스 객체를 생성
- DROP: 데이터베이스 객체를 삭제
- ALTER: 기존에 존재하는 데이터베이스 객체를 다시 정의

DCL(Data Control Language)
- 데이터베이스, 테이블의 접근권한이나 CRUD 권한을 정의하는 명령어
- GRANT: 데이터베이스 객체에 권한을 부여
- REVOKE: 이미 부여된 데이터베이스 객체 권한을 취소

https://leejinseop.tistory.com/6


23.01.17
## Q. 브라우저에 접속하여 주소창에 특정 URL을 입력하면 어떤 일이 일어날까요?(네트워크)  

A.  
1. 브라우저에서는, 입력된 URL 값의 의미를 조사하여 의미에 따라 HTTP Request 메시지를 만들어 웹 서버로 전송한다.
2. 프로토콜 스택에서는 브라우저로부터 메시지를 받아 패킷 속에 저장 후 수신처 주소 등의 제어정보를 덧붙여 패킷을 LAN 어댑터에 넘긴다.
3. LAN 어댑터는 다음 Hop의 MAC주소를 붙인 프레임을 전기신호로 변환하여 LAN 케이블에 송출한다.
4. 프레임 신호가 스위칭 허브, 인터넷 접속용 라우터, 프로바이더(통신사) 등을 경유하여 인터넷으로 들어가게 된다.
5. 패킷은 액세스 회선에 의해 통신사용 라우터까지 운반되어 인터넷의 핵심부로 들어가고, 고속 라우터들 사이로 패킷이 목적지를 향해 흘러간다.
6. 패킷이 웹 서버측의 LAN에 도착하면, 방화벽이 검사를 하고, 캐시서버가 패킷이 웹 서버까지 가야 하는지 판단한다.
7. 패킷이 물리적인 웹 서버에 도착하면 프로토콜 스택이 패킷을 추출하여 메시지를 복원하고 애플리케이션에 넘기고, 요청 메시지에 따른 데이터를 응답 메시지에 넣어 클라이언트로 회송한다.
8. 왔던 방식대로 응답 메시지가 클라이언트에게 전달된다.

https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Network#%EC%9B%B9-%ED%86%B5%EC%8B%A0%EC%9D%98-%ED%81%B0-%ED%9D%90%EB%A6%84

23.01.18
## Q. 커널(kernel)의 종류에 대해 설명해주세요.(운영체제)  

A.  
**단일형 커널(Monolithic Kernel)**  
- 커널의 다양한 서비스 및 높은 수준의 하드웨어 추상화를 하나의 덩어리로 묶어 놓은 구조

**마이크로 커널(Micro Kernel)**  
- 하드웨어 추상화에 대한 간결한 작은 집합을 제공하고 더 많은 기능은 서버라고 불리는 응용 소프트웨어를 통해 제공됨

**혼합형 커널(Hybrid Kernel)**  
- 본질적으로는 마이크로 커널을 따르고 있으나, 비 본질적인 기능이더라도 사용자 레벨에서 수행될 때 성능상 느린 코드들을 커널 레벨에서 수행하도록 수정한 것

**엑소 커널(Exo Kernel)**  
- 낮은 수준의 하드웨어 접근을 위한 최소한의 추상화를 제공함

https://ljhblog.tistory.com/37

23.01.19
## Q. List, Set, Map의 차이점에 대해 설명해주세요.(자료구조)  

A.  
**List**  
- 데이터를 순서대로 저장하는 선형자료구조  
- 순서가 있고, 중복을 허용
- 길이가 가변적
- 원하는 데이터가 뒤쪽에 있을 때 탐색에 시간이 오래 걸림
- 즉, 시간복잡도가 $O(n)$임

**Set**  
- 순서가 없고 중복을 허용하지 않는, 말 그대로 집합
- 탐색 속도가 빠름, 시간복잡도 $O(1)$

**Map**  
- 키와 데이터를 같이 저장(key-value 쌍)  
- key와 value로 나눠서 데이터를 관리하며, 순서가 없고 키에 대해서 중복이 없음  
- 탐색 속도가 key의 탐색 속도에 의해 결정됨  

https://milkoon1.tistory.com/44

23.01.20
## Q. 최장 증가 수열 알고리즘의 동작 방식에 대해 설명해주세요.(알고리즘)  

A.  
**최장 증가 부분 수열(LIS, Longest Increasing Subsequence) 알고리즘**  
- 원소가 n개인 배열의 일부 원소를 골라내서 만든 부분 수열 중, 각 원소가 이전 원소보다 증가하면서 그 길이가 최대인 부분 수열을 최장 증가 부분 수열이라고 함
- 어떤 배열이 주어졌을 때, DP(Dynamic Programming)을 사용하여 최장 증가 부분 수열을 구할 수 있음
- 배열의 맨앞부터 인덱스를 한 칸씩 늘려가면서, 해당 인덱스를 그 전까지의 부분 수열의 마지막 값과 비교하여 부분 수열의 길이를 업데이트하는 방법( $O(n^2)$ )
- 이진 탐색을 사용하여 인덱스의 값이 들어갈 수 있는 부분 수열의 길이를 업데이트하는 방법( $O(nlog(n)$ )

https://seohyun0120.tistory.com/entry/%EA%B0%80%EC%9E%A5-%EA%B8%B4-%EC%A6%9D%EA%B0%80%ED%95%98%EB%8A%94-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4LIS-%EC%99%84%EC%A0%84-%EC%A0%95%EB%B3%B5-%EB%B0%B1%EC%A4%80-%ED%8C%8C%EC%9D%B4%EC%8D%AC

23.01.21
## Q. KNN과 K-means 알고리즘의 차이에 대해 설명해주세요.(머신러닝)  

A.  
**KNN(K-Nearest Neighbor)**  
- 분류 알고리즘(지도학습 - labeled data)
- K개의 최근접 이웃을 참조하여 자신의 클래스를 결정함  
- 보통 K를 홀수로 지정함  

**K-means**  
- 비지도학습 중 하나로, 데이터를 K개의 클러스터로 군집화하는 알고리즘(unlabeled data)
1. K를 정한다(k는 클러스터 개수)
2. K개의 초기 중심을 임의로 설정한다.
3. 각 데이터 포인트 ~ K개의 중심 거리를 계산하여 가장 가까운 중심점이 속한 클러스터로 이동한다.
4. 2, 3 단계를 반복하고 더이상 클러스터에 변화가 없으면 종료한다.

https://m.blog.naver.com/songsrr12/221664837491

23.01.22
## Q. 데이터베이스의 무결성 제약조건의 정의와 필요성에 대해 설명해주세요.(데이터베이스)  

A.  
데이터 무결성  
- 데이터베이스에 저장된 데이터의 일관성과 정확성을 지키는 것

데이터베이스의 무결성 제약조건  
- 데이터의 일관성과 정확성을 위해 지켜야 하는 규칙  

무결성 제약조건의 필요성  
- 스키마를 작성할 때 일관성 조건을 한 번만 명시하면 데이터베이스가 갱신될 때마다 DBMS가 자동으로 일관성 조건을 감시하므로 어플리케이션들은 일관성 조건을 일일히 검사할 필요가 없음
- 데이터를 실생활의 의미에 맞게 사용할 수 있음
- 응용 프로그램에서 직접 조건을 유지하는 경우보다 에러가 발생할 가능성이 더 낮음

무결성 제약조건의 종류  
- 도메인 무결성 제약조건(도메인 제약): 릴레이션 내의 튜플들이 각 속성의 도메인에 지정된 값만을 가져야 한다는 조건. 속성에 들어갈 수 있는 데이터 타입을 지정할 수 있고, 기본값을 지정할 수 있음. 저장되는 값들의 범위를 지정할 수 있으며 NULL 구문을 통해 속성 값으로 NULL을 허용/비허용 할 수 있음  
- 개체 무결성 제약조건(기본키 제약): 릴레이션은 기본키를 지정하고 그에 따른 무결성 원칙을 지켜야 한다는 조건. 기본키는 NULL값을 가져서는 안 되며 릴레이션 내에 오직 하나의 값만 존재해야 함
- 참조 무결성 제약조건(외래키 제약): 테이블 간의 참조 관계를 선언하는 조건. 외래키의 값은 NULL이거나 참조 릴레이션의 기본키 값과 동일해야 함.

https://velog.io/@zooneon/DB-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%AC%B4%EA%B2%B0%EC%84%B1-%EC%A0%9C%EC%95%BD%EC%A1%B0%EA%B1%B4

23.01.23
## Q. cors(Cross-Origin Resource Sharing)란 무엇일까요?(네트워크)  

A.  
브라우저에서는 보안적인 이유로 cross-origin HTTP 요청들을 제한하기에, cross-origin 요청을 하려면 서버의 동의가 필요함. 만약 서버가 동의한다면 브라우저에서는 요청을 허락하고, 동의하지 않는다면 브라우저에서 거절함  
이러한 허락을 구하고 거절하는 메커니즘은 HTTP-header를 이용해서 가능한데, 이를 CORS(Cross-Origin Resource Sharing)이라고 부름  

https://hannut91.github.io/blogs/infra/cors

23.01.24
## Q. 멀티 스레딩(Multi-threading)의 장점과 단점은 무엇인가요?(운영체제)

A.  
**멀티 스레딩(Multi-threading)**  
- 하나의 프로세스를 다수의 실행 단위로 구분하여 자원을 공유하고 자원의 생성과 관리의 중복성을 최소화하여 수행 능력을 향상시키는 것
- 하나의 프로그램에서 동시에 여러 개의 일을 수행할 수 있도록 해줌(사실 분산처리를 통해 동시에 실행되는 것처럼 보이는 것)  

**장점**  
1. 응답성: 프로그램의 일부분(스레드)이 중단되거나 긴 작업을 수행하더라도 프로그램의 수행이 계속되어 사용자에 대한 응답성이 증가한다.
2. 경제성: 프로세스 내 자원들과 메모리를 공유하기 때문에 메모리 공간과 시스템 자원 소모가 줄어든다. 스레드 간 통신이 필요한 경우에도 쉽게 데이터를 주고 받을 수 있으며, 프로세스의 context switching과 달리 스레드 간의 context switching은 캐시 메모리를 비울 필요가 없기 때문에 더 빠르다.
3. 멀티프로세서 활용: 다중 CPU 구조에서는 각각의 스레드가 다른 프로세서에서 병렬로 수행될 수 있으므로 벙렬성이 증가한다.

**단점**  
- 임계영역(Critical Section). 둘 이상의 스레드가 동시에 실행하면 문제를 일으키는 코드 블록. 공유하는 자원에 동시에 접근하는 경우, 프로세스와는 달리 스레드는 데이터와 힙 영역을 공유하기 때문에 어떤 스레드가 다른 스레드에서 사용 중인 변수나 자료구조에 접근하여 엉뚱한 값을 읽어오거나 수정할 수 있다. 따라서 동기화가 필요.
- 동기화를 통해 스레드의 작업 처리 순서와 공유 자원에 대한 접근을 컨트롤할 수 있다. 그러나 불필요한 부분까지 동기화하는 경우, 과도한 lock으로 인해 병목 현상을 발생시켜 성능이 저하될 가능성이 높기 때문에 주의해야 한다. 동기화 방법에는 뮤텍스와 세마포어가 있다.
- context switching, 동기화 등의 이유로 싱글 코어 멀티 스레딩은 스레드 생성 시간이 오히려 오버헤드로 작용해 단일 스레드보다 느리다.

https://eun-jeong.tistory.com/20

23.01.25  
# Q. Stack과 Queue의 차이점에 대해 설명해주세요.(자료구조)

A.  
Stack과 Queue 모두 데이터 간 순서 관계가 중요한 선형 추상 자료형이다.  
Stack은 접시를 쌓아놓을 때와 같이, 먼저 들어간 데이터가 가장 마지막으로 나오는 LIFO(Last In, First Out) 성질이 있다.  
Queue는 버스 줄을 설 때와 같이, 먼저 들어간 데이터가 먼저 나오는 FIFO(First In, First Out) 성질이 있다.  

https://velog.io/@humblechoi/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-Stack-Queue

23.01.26
# Q. 소수 판별 알고리즘인 에라토스테네스의 체에 대해 설명해주세요.(알고리즘)  

A.  
1. 소수를 판별하고 싶은 범위(n)를 설정한다.  
2. 소수도 합성수도 아닌 1을 지우고, 가장 작은 소수인 2부터 시작하여 2를 제외한 2의 배수인 4, 6, 8... 등을 n까지 범위 안에서 모두 지운다.
3. 남아있는 수 중, 2의 다음 숫자인 3이 2의 다음 소수이므로 3 자신을 제외한 3의 배수 9, 15, 21 등을 n까지 범위 안에서 모두 지운다(6, 12, 18 등은 2의 배수를 지울 때 이미 지워졌다).
4. 마찬가지 방법으로, x의 배수를 n의 범위 내에서 모두 지운 다음 남아있는 수 중 x 다음 숫자 자신을 제외한 그 배수를 지우는 과정을 반복한다.
5. n까지 범위 안에서 모두 이루어졌다면, 남아있는 숫자들이 n 이내의 소수가 된다.

https://blog.naver.com/PostView.naver?blogId=ndb796&logNo=221233595886&redirect=Dlog&widgetTypeCall=true&directAccess=false

23.01.27
## Q. 커널 트릭에 대해 설명해주세요.(머신러닝)  

A.  
input space가 있을 때 샘플을 선형 모델로 분류할 수 없는 경우, 비선형 모델을 만드는 대신 선형 모델로 해결할 수 있는 feature space를 만드는 방법(feature map)이 있다.  
그러나 feature map을 찾는 것은 매우 어렵고, 합수로 feature space를 만드는 연산량과 내적 연산량이 너무 많다는 문제점이 있다.  
커널(kernel)은 이러한 문제점을 해결하기 위해 고안된 것으로, 커널이 일정 조건(Mercer's Theorem)을 만족하면 문제를 해결하기 위한 커널 함수가 존재하게 된다.  
이때 이 함수들을 이용한 linear technique를 Kernel Trick(커널 트릭)이라고 한다.

https://sonsnotation.blogspot.com/2020/11/11-1-kernel.html

23.01.28
## Q. 데이터베이스 정규화와 그 종류에 대해서 설명해주세요.(데이터베이스)  

A.  
**데이터베이스 정규화(Normalization)**  
- 정규화: 관계형 데이터베이스의 설계에서 중복을 최소화하게 데이터를 구조화하는 프로세스
- 목표: 관련이 없는 함수 종속성은 별개의 릴레이션으로 표현하는 것
- 장점: 이상 현상의 발생 가능성을 줄임
- 단점: 연산 시간이 증가함

**정규형**
- 정규화된 결과
- 기본 정규형, 고급 정규형으로 나뉨
- 기본 정규형: 제1정규형, 제2정규형, 제3정규형, BCNF(보이스/코드 정규형)
- 고급 정규형: 제4정규형, 제5정규형

**제1정규형**
- 릴레이션에 속한 모든 속성의 도메인이 더이상 분해되지 않는 원자값으로만 구성된 정규형

**제2정규형**
- 릴레이션이 제1정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속되는 정규형

**제3정규형**
- 릴레이션이 제2정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속이 되지 않는 정규형

**BCNF**
- 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키인 정규형

**제4정규형**
- 릴레이션이 BCNF를 만족하면서, 함수 종속이 아닌 다치 종속을 제거한 정규형

**제5정규형**
- 릴레이션이 제4정규형을 만족하면서 후보키를 통하지 않는 조인 종속을 제거한 정규형

https://hongcoding.tistory.com/147

23.01.29
## Q. http의 문제점이 무엇이라고 생각하시나요?(네트워크)  

A.  
- HTTP는 평문 통신이기 때문에 도청이 가능하다.
- 통신 상대를 확인하지 않기 때문에 위장이 가능하다.
- 완전성을 증명할 수 없기 때문에 변조가 가능하다.

https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Network#http%EC%9D%98-get%EA%B3%BC-post-%EB%B9%84%EA%B5%90

23.01.30
## Q. 페이지 교체 알고리즘에 대해 아는대로 설명해주세요.(운영체제)  

A.  
- 가상 메모리는 요구 페이지 기버을 통해 필요한 페이지만 메모리에 적재하고 사용하지 않는 부분은 그대로 둠
- 하지만 필요한 페이지만 올려도 메모리는 결국 가득 차게 되고, 올라와있던 페이지가 사용이 다 된 후에도 자리만 차지하고 있을 수 있음
- 따라서 메모리가 가득 차면, 추가로 페이지를 가져오기 위해서 안 쓰는 페이지는 out하고, 해당 공간에 현재 필요한 페이지를 in 시켜야 함
- 여기서 어떤 페이지를 out 시켜야 할지 정해야 함(이때 out 되는 페이지를 victim page라고 부름).
- 기왕이면 수정이 되지 않는 페이지를 선택해야 좋음(만약 수정되면 메인 메모리에서 내보낼 때, 하드디스크에서 또 수정을 진행해야 하므로 시간이 오래 걸림)
- FIFO 알고리즘: 메모리에 가장 먼저 올라온 페이지를 out시키는 방법
- OPT 알고리즘: 앞으로 가장 사용하지 않을 페이지를 out시키는 방법
- LRU 알고리즘: 최근에 사용하지 않은 페이지를 out시키는 방법
- 교체 방식: 메모리 상의 모든 프로세스 페이지에 대해 교체하는 Global 방식, 메모리 상의 프로세스 페이지에서만 교체하는 Local 방식

https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/Page%20Replacement%20Algorithm.md

23.01.31
## Q. Array와 ArrayList의 차이점에 대해 설명해주세요.(자료구조)  

A.  
Array: 고정 길이이므로, 정해진 길이의 배열을 모두 채우면, 새로운 데이터를 추가하고 싶을 경우 새로운 배열을 만들어주어야 함  
ArrayList: 가변 길이이므로, 정해진 길이의 배열을 모두 채우면, 추가로 공간을 만들어 저장할 수 있음

https://velog.io/@humblechoi/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-Array-vs-ArrayList

23.02.01
## Q. 포드-폴커슨(Ford-Fuljerson) 알고리즘에 대해 설명해주세요.(알고리즘)  

A.  
- 각 간선이 '용량' 개념을 갖는 그래프에서 두 정점 사이에 얼마나 많은 '흐름' 또는 '유량'을 보낼 수 있는지 계산하는 **네트워크 유량(network flow)** 문제를 해결하기 위한 알고리즘  
- 유량 네트워크의 모든 간선의 유량을 0으로 두고 시작
- 출발점인 소스에서 도착점인 싱크로 유량을 더 보낼 수 있는 경로를 찾아 유량을 보내기를 반복함

https://loosie.tistory.com/633

23.02.02  
## Q. 의사결정나무(Decision Tree)의 프로세스에 대해 설명해주세요.(머신러닝)  

A.  
**의사결정나무(Decision Tree)**
- 분류(Classification)와 회귀(Regression) 모두 가능한 지도 학습 모델 중 하나  
- 스무고개 하듯이 예/아니오 질문을 이어가며 학습함  
- 특정 기준(질문)에 따라 데이터를 구분하는 모델을 결정 트리 모델이라고 함
- 데이터를 가장 잘 구분할 수 있는 질문을 기준으로 나눔
- 나뉜 각 범주에서 또 다시 데이터를 가장 잘 구분할 수 있는 질문을 기준으로 나눔
- 이를 지나치게 많이 하면 오버피팅이 됨
- 오버피팅을 막기 위한 전략으로 가지치기(Pruning)가 있음  
- 가자치기는 최대 깊이나 터미널 노드의 최대 개수, 혹은 한 노드가 분할하기 위한 최소 데이터 수를 제한함

https://bkshin.tistory.com/entry/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D-4-%EA%B2%B0%EC%A0%95-%ED%8A%B8%EB%A6%ACDecision-Tree

23.02.03
## Q. 트랜잭션에서의 데드락이란 무엇이고 그 해결방법을 설명해주세요.(데이터베이스)  

A.  
**트랜잭션 데드락(Deak Lock, 교착상태)**  
- 두 개 이상의 트랜잭션이 특정 자원(테이블 또는 행)의 Lock을 획득한 채 다른 트랜잭션이 소유하고 있는 잠금을 요구하면 아무리 기다려도 상황이 바뀌지 않는 상황

**해결 방법**
- 데드락을 감지하면 한 쪽 트랜잭션을 풀어버린다.
- 트랜잭션 A의 마지막 UPDATE 내용에 오류가 발생되고 COMMIT을 먼저 하도록 유도한다.
- 트랜잭션 B는 아직 WAITING 상태로 남아있고, 트랜잭션 A의 COMMIT을 기다리게 된다.

https://velog.io/@yrkim/Database-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-deadlock

23.02.04
## Q. 왜 TCP연결 시에는 3way handshake고 해제 시에는 4way handshake일까요?(네트워크)  

A.  
**3 way handshake - 연결 성립**  
TCP는 정확한 전송을 보장해야 하므로 통신하기에 앞서 논리적인 접속을 성립하기 위해 3 way handshake 과정을 진행함  
1. 클라이언트가 서버에게 SYN 패킷을 보냄(sequence: x)
2. 서버가 SYN(x)을 받고, 클라이언트로 받았다는 신호인 ACK와 SYN 패킷을 보냄(sequence: y, ACK: x + 1)
3. 클라이언트는 서버의 응답은 ACK(x + 1)와 SYN(y) 패킷을 받고, ACK(y + 1)를 서버로 보냄

이렇게 3번의 통신의 완료로 연결이 성립되기에 3 way handshake이다.

**4 way handshake - 연결 해제**  
연결 성립 후, 모든 통신이 끝났다면 해제해야 함
1. 클라이언트는 서버에게 연결을 종료한다는 FIN 플래그를 보냄
2. 서버는 FIN을 받고, 확인했다는 ACK를 클라이언트에게 보냄(이때 모든 데이터를 보내기 위해 CLOSE_WAIT 상태가 됨)
3. 데이터를 모두 보냈다면, 연결이 종료되었다는 FIN 플래그를 클라이언트에게 보냄
4. 클라이언트는 FIN을 받고, 확인했다는 ACK를 서버에게 보냄(아직 서버로부터 받지 못한 데이터가 있을 수 있으므로 TIME_WAIT을 통해 기다림
    - 서버는 ACK를 받은 이후 소켓을 닫음(CLOSED)
    - TIME_WAIT 시간이 끝나면 클라이언트도 닫음(CLOSED)

이렇게 4번의 통신의 완료로 연결이 해제되기에 4 way handshake이다.

https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Network/TCP%203%20way%20handshake%20%26%204%20way%20handshake.md

23.02.05
## Q. 세마포어(Semaphore)와 뮤텍스(Mutex)의 차이점에 대해 설명해주세요.(운영체제)  

A.  
**세마포어(Semaphore)**  
- 멀티프로그래밍 환경에서 공유 자원에 대한 접근을 제한하는 방법
- 공유된 자원에 여러 프로세스가 동시에 접근하면 문제가 발생할 수 있기에, 공유된 자원의 데이터는 한 번에 하나의 프로세스만 접근할 수 있도록 제한을 두기 위함
- 여러 프로세스가 데이터를 공유하며 수행될 때, 각 프로세스에서 공유 데이터를 접근하는 프로그램 코드 부분인 임계 구역을 이용하여 제한

**뮤텍스(Mutex)**  
- 임계 구역을 가진 스레드들의 실행시간이 서로 겹치지 않고 각각 단독으로 실행되게 하는 기술
- 상호 배제(**Mut**ual **Ex**clusion)의 약자
- 해당 접근을 조율하기 위해 lock과 unlock을 사용함
- 상태가 0, 1로 이진 세마포어로 부르기도 함

https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/Semaphore%20%26%20Mutex.md

23.02.06
## Q. 그래프와 트리의 차이점에 대해 설명해주세요.(자료구조)

A.  
**트리**  
- 계층적 관계를 나타내는 자료구조
- root 노드부터 leaf 노드까지 상하 관계, 순서가 있다
- 사이클을 허용하지 않는다

**그래프**  
- 연결 관계를 나타내는 자료구조
- 모든 노드는 동등한 위치이고 순서나 상하 관계가 없다
- 사이클이 생길 수 있다

https://bigsong.tistory.com/33

23.02.07  
## Q. Minimum Cut에 대해 설명하고 Maximum Flow와 동일한 이유에 대해 설명해주세요.(알고리즘)  

A.  
노드들이 서로 연결돼있는 그래프를 2개의 서로 다른 집합으로 나누는 것을 Cut이라고 한다.  
Minimum Cut은 최소 비용으로 Cut하는 것을 의미한다.  
그래프에 가중치가 없다면 간선의 개수를 가장 적게 자르는 것이,  
가중치가 있다면 간선의 가중치의 합을 가장 적게 자르는 것이 Minimum Cut이다.  

네트워크 플로우에서 Maximum Flow는 최대 유량 문제이다.  
즉, 네트워크 그래프에서 유량을 최대화하는 방법이다.  
이때, 그래프에서 Minimum Cut을 하는 것이 네트워크 유량을 최대화하는 것과 같다.  

https://www.crocus.co.kr/755

23.02.08
## Q. 편향(Bias)과 분산(Variance)에 대해 tradeoff와 연관지어 설명해주세요.(머신러닝)  

A.  
**편향(Bias)**  
- 예측값들과 정답이 대체로 멀리 떨어져 있으면 결과의 편향(bias)이 높다고 말함

**분산(Variance)**  
- 예측값들이 자기들끼리 대체로 멀리 흩어져 있으면 결과의 분산(Variance)이 높다고 말함

**Bias-variance tradeoff**  
- bias를 높임으로 variance를 낮출 수 있고, 반대의 경우도 가능하다
- 즉, bias와 variance는 한 가지를 선택하면 한 가지를 다소 포기해야 한다

https://opentutorials.org/module/3653/22071  
https://en.wikipedia.org/wiki/Bias%E2%80%93variance_tradeoff

23.02.09
## Q. 데이터베이스의 이상현상의 종류와 각각의 정의를 설명해주세요.(데이터베이스)

**이상**
- 릴레이션에서 일부 속성들의 종속이나 데이터의 중복으로 인해 데이터 조작시 불일치가 발생하는 것
- 테이블을 설계할 때 잘못 설계하여 데이터를 삭제, 수정, 삽입할 때 논리적으로 오류가 생기는 것
- 이를 제거하는 과정이 정규화

1. 삽입 이상: 자료를 삽입할 때 의도하지 않은 자료까지 삽입해야만 자료를 테이블에 추가가 가능한 이상
2. 갱신 이상: 중복된 데이터 중 일부만 수정되어 데이터 모순이 일어나는 이상
3. 삭제 이상: 어떤 정보를 삭제하면, 유용한 다른 정보까지 삭제되어버리는 이상

https://kosaf04pyh.tistory.com/294

23.02.10
## Q. 로드 밸런싱과 로드 밸런서에 대해 연관지어 설명해주세요.(네트워크)  

A.  
**로드 밸런싱(Load Balancing)**  
- 둘 이상의 CPU 또는 저장장치와 같은 컴퓨터 자원들에게 작업을 나누는 것
- 여러 서버에 균등하게 트래픽을 분산시켜주는 것
- 분산식 웹 서비스로, 여러 서버에 부하(Load)를 나누어주는 역할
- 로드 밸런서(Load Balancer)를 클라이언트와 서버 사이에 두고, 부하가 일어나지 않도록 여러 서버에 분산시켜주는 방식

https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Network/%EB%A1%9C%EB%93%9C%20%EB%B0%B8%EB%9F%B0%EC%8B%B1(Load%20Balancing).md

23.02.11
## Q. HTTP 응답 상태 코드 종류를 설명해주세요.(네트워크)

A.  
**202 Accepted**
- 요청을 수신하였지만 그에 응하여 행동할 수 없습니다. 이 응답은 요청 처리에 대한 결과를 이후에 HTTP로 비동기 응답을 보내는 것에 대해서 명확하게 명시하지 않습니다. 이것은 다른 프로세스에서 처리 또는 서버가 요청을 다루고 있거나 배치 프로세스를 하고 있는 경우를 위해 만들어졌습니다.

**301 Moved Permanently**
- 이 응답 코드는 요청한 리소스의 URI가 변경되었음을 의미합니다. 새로운 URI가 응답에서 아마도 주어질 수 있습니다.

**404 Not Found**
- HTTP 404 Not Found 클라이언트 오류 응답 코드는 서버가 요청받은 리소스를 찾을 수 없다는 것을 의미합니다. 404 페이지를 띄우는 링크는 대체로 브로큰 링크(broken link) 또는 데드 링크(dead link)라고 부르며, link rot 대상일 수도 있습니다.

**500 Internal Server Error**
- 하이퍼텍스트 전송 프로토콜 (HTTP) 500 Internal Server Error 서버 에러 응답 코드는 요청을 처리하는 과정에서 서버가 예상하지 못한 상황에 놓였다는 것을 나타냅니다.
- 이 에러 응답은 "서버 에러를 총칭하는"(catch-all) 구체적이지 않은 응답입니다. 종종, 서버 관리자들은 미래에 같은 에러를 발생하는 것을 방지하기 위해 500 상태 코드 같은 에러 응답들에 더 많은 자세한 내용을 남겨 둡니다.

https://developer.mozilla.org/ko/docs/Web/HTTP/Status/202

## Q. Code, Data, Stack, Heap에 대해 설명해주세요.(운영체제)

A.  
프로세스가 차지하고 있는 메모리 영역은 Code, Data, Heap, Stack의 영역으로 나누어져 있고, 이들을 각각 Segment라고 부름

정적 세그먼트  
1. **Code**
- 메모리 맵의 제일 아래 text 부분
- 작성한 코드가 들어가는 부분(기계어도 포함)
- read only 영역이라 쓰기 작업이 들어오면 access violation이 발생
- 프로세스가 종료될 때까지 계속 유지됨  

2. **Data**  
- 전역변수(global), 정적변수(static), 배열(array), 구조체(structure) 등이 저장됨  

동적 세그먼트  

3. **Heap**  
- 프로그래머가 동적으로 사용하는 영역
- malloc, free, new, delete에 의하여 할당 또는 반환되는 영역  

4. **Stack**  
- 지역변수, 매개변수, 복귀 번지 등이 저장되어있는 프로그램이 자동으로 사용하는 임시 메모리
- 함수 호출 시 생성되고, 종료 시 반환됨
- LIFO 정책 사용함
- 다른 세그먼트들은 하위 영역으로부터 할당되지만 Stack 세그먼트는 상위 영역부터 할당됨

https://adevspoon.com/?code=-MCclhOrqxWhGB9ImkuH8FuEbOMTPZw3uGmhU1TA6mVgB32ex20ZL-T5ggUjwXBdGCemKQopyNgAAAGGQJaOxA

23.02.12
## Q. O(n)의 시간복잡도로 힙을 구성하는 방법에 대해 설명해주세요.(자료구조)  

A.  
**Sift Down Operation**  
- 주어진 노드의 child nodes 중 key가 큰 값(or 작은 값)과 비교연산을 수행해 property를 만족하거나, 그렇지 않으면 leaf에 도달할 때까지 swap하는 과정
1. data set에 주어졌을 때, 앞에서부터 순차적으로 완전이진트리를 만든다
2. leaf 노드를 제외한 노드들을 자식 노드들과 비교연산을 수행하여 swap을 한다
3. 힙 속성을 만족할 때까지 2를 반복한다

https://leeminju531.tistory.com/33

23.02.13  
## Q. Segmented Least Squares에 대해 설명하고 이를 해결하는 알고리즘을 제시하세요.(알고리즘)

A.  
- 데이터를 근사하는 모형을 찾는 과정에서 데이터 분포가 하나의 직선으로 표현하기 어려운 경우, 선형 모형 여러 개를 결합하여 데이터를 표현할 수 있는데, 이처럼 복잡한 형태를 쪼개어 직선 여러 개로 표현하는 기법
1. 주어진 모든 점을 (x_n, y_n)으로 표시하고, x 순서대로 정렬한 뒤, 부분집합에 대한 근사오차와 분할에 대한 패널티 값을 더한 합을 전제 오차로 계산한다
2. 동적 프로그래밍(DP)를 활용하여, 분할하는 각 구간에 대해서 전체 오차를 계산하여 가장 작은 값(최소 오차)을 구한다

https://bab2min.tistory.com/629

23.02.14
## Q. MLE와 MAP의 차이에 대해 설명해주세요.(머신러닝)

A.  
Bayes's Rule  
### $p(θ|x) = \frac{p(\theta) f(x|\theta)}{p(x)}$   

Posterior, Prior, Likelihood
- Posterior: $p(\theta|x)$, 즉 위 수식의 좌변. 관측치 $x$가 주어졌을 때 $\theta$를 가지는 확률. 관측치가 주여진(변수가 존재하는) 확률모형
- Prior: $p(\theta)$, $\theta$로 구성된 확률모형. 관측치 $x$를 통해 특정하고자 하는 함수
- Likelihood: $p(x|\theta)$, parms이 주어졌을 때 $x$ 관측치를 얻을 확률모형  

MLE(Maximum Likelihood Estimation)
- Likelihood를 Maximize시켜 추정치를 얻는 방법

MAP(Maximum A Posteriori)
- Posteriori를 Maximize시켜 추정치를 얻는 방법

https://niceguy1575.medium.com/mle%EC%99%80-map%EC%9D%98-%EC%B0%A8%EC%9D%B4-7d2cc0bee9c

23.02.15  
## Q. 데이터베이스의 트랜잭션에 대해서 설명해주세요.(데이터베이스)

A.  
**트랜잭션(Transaction)**  
- 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미

**특징**  
- 데이터베이스 시스템에서 병행 제어 및 회복 작업 시 처리되는 작업의 논리적 단위
- 사용자가 시스템에 대한 서비스 요구 시 시스템에 응답하기 위한 상태 변환 과정의 작업 단위
- 하나의 트랜잭션은 Commit되거나 Rollback 됨

**성질**  
- Atomicity(원자성)
- Consistency(일관성)
- Isolation(독립성, 격리성)
- Durability(영속성, 지속성)

**연산**
- Commit
- Rollback

**상태**
- 활동(Active)
- 실패(Failed)
- 철회(Aborted)
- 부분 완료(Partially Committed)
- 완료(Committed)

https://coding-factory.tistory.com/226

23.02.16
## Q. 사설IP와 공공IP를 차이점을 중심으로 설명해주세요.(네트워크)  

A.  
공공 IP(Public IP)
- 인터넷 사용자의 로컬 네트워크를 식별하기 위해 ISP(인터넷 서비스 공급자)가 제공하는 IP주소

사설 IP(Private IP)
- 일반 가정이나 회사 내 등에 할당된 네트워크의 IP 주소

차이점  
|           |      공인 IP (Public IP)      |     사설 IP (Private IP)    |
|:---------:|:-----------------------------:|:---------------------------:|
| 할당 주체 |   ISP(인터넷 서비스 공급자)   |        라우터(공유기)       |
| 할당 대상 | 개인 또는 회사의 서버(라우터) |    개인 또는 회사의 기기    |
|   고유성  |   인터넷 상에서 유일한 주소   | 하나의 네트워크 안에서 유일 |
| 공개 여부 |       내/외부 접근 가능       |       외부 접근 불가능      |

https://velog.io/@hidaehyunlee/%EA%B3%B5%EC%9D%B8Public-%EC%82%AC%EC%84%A4Private-IP%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90

23.02.17
## Q. 데드락이 무엇인지 설명하고 데드락의 4가지 조건에 대해 각각 설명해주세요.(운영체제)

A.  
데드락(DeadLock, 교착 상태)  
- 두 개 이상의 프로세스나 스레드가 서로 자원을 얻지 못해서 다음 처리를 하지 못하는 상태
- 무한히 다음 자원을 기다리게 되는 상태
- 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생함

발생 조건
- 데드락은 다음 4가지 조건을 모두 만족해야 발생
1. 상호 배제(Mutual Exclusion)
    - 자원은 한 번에 한 프로세스만 사용할 수 있음
2. 점유 대기(Hold and Wait)
    - 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재햐아 함
3. 비선점(No Preemption)
    - 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음
4. 순환 대기(Circuit Wait)
    - 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 함

https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/DeadLock.md

23.02.18
## Q. 해시 함수의 특징과 좋은 해시 함수의 조건에 대해 예시와 함께 설명해주세요.(자료구조)

A.  
해시 함수의 특징
1. 어떤 입력값에도 항상 고정된 길이의 해시값을 출력(동일한 값이 입력되면 언제나 동일한 출력값을 보장)
2. 눈사태 효과: 입력값의 아주 일부만 변경되어도 전혀 다른 결괏값을 출력
3. 비가역적: 출력된 결괏값을 토대로 입력값을 유추할 수 없음

좋은 해시 함수의 조건
1. 해시 충돌(서로 다른 입력값에 대해 같은 결괏값이 나오는 경우)이 적어야 함
2. 해시 함숫값이 해시 테이블의 주소 영역 내에서 고르게 분포되어야 함
3. 계산이 빨라야 함

https://j3sung.tistory.com/759

23.02.19
## Q. 이분 매칭(Bipartite Matching)문제를 포드-폴커슨(Ford-Fulkerson) 알고리즘을 통해 해결하는 방식을 제안해주세요.(알고리즘)

A.  
그래프에 Sink와 Target을 정한 후, sink에서 지원자A로 가는 edge weight = 무한, 직업에서 Target으로의 edge weight은 1로 설정하고 더이상 target으로 가는 residual graph가 없을 때까지 dfs또는 bfs로 탐색하면 된다.

https://adevspoon.com/?code=RJ-ZeDk_KCvV37KV7UsFJvgqAgDgP63oAPWu6IQBAYwJyngbxW1akaR1q0lRhV9NvUejVAo9cxcAAAGGZ4_g1w

23.02.20
## Q. 엔트로피(Entropy)와 크로스 엔트로피(Corss-Entropy)에 대해 설명해주세요.(머신러닝)  

A.  
**엔트로피(Entropy)**  
- 불확실성의 척도. 엔트로피가 높을수록 정보가 많고, 확률이 낮다는 것을ㅇ ㅢ미
- 어떤 데이터가 나올지 예측하기 어려운 정도

**크로스 엔트로피(Corss-Entropy)**  
- 실제 분포 q에 대하여 알지 못하는 상태에서, 모델링을 통하여 구한 분포인 p를 통하여 q를 예측하는 것
- 실제값과 예측값의 차이를 줄이기 위한 엔트로피

https://melonicedlatte.com/machinelearning/2019/12/20/204900.html

23.02.21
## Q. 데이터베이스의 인덱스를 사용할 때의 장점과 단점을 설명해주세요.(데이터베이스)

A.  
**장점**
- 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있음
- 전반적인 시스템의 부하를 줄일 수 있음

**단점**
- 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요함
- 인덱스를 관리하기 위해 추가 작업이 필요함
- 인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생할 수 있음

https://mangkyu.tistory.com/96

23.02.22
## Q. REST API에 대해 설명해주세요.(네트워크)

A.  
**REST API(Represnatational State Trnasfer API)**

**구성**  
- 자원(Resource) - URI
- 행위(Verb) - HTTP METHOD
- 표현(Representations)

**특징**  
- Uniform(유니폼 인터페이스)
- Stateless(무상태성)
- Cacheable(캐시 가능)
- Self-descriptiveness(자체 표현 구조)
- Client - Server 구조
- 계층형 구조

https://meetup.nhncloud.com/posts/92

23.02.23
## Q. 프로세스와 스레드의 차이점에 대해 설명해주세요.(운영체제)  

A.  
프로세스  
- 운영체제로부터 자원을 할당받은 작업의 단위

스레드  
- 프로세스가 할당받은 자원을 이용하는 실행 흐름의 단위

https://velog.io/@raejoonee/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4

23.02.24
## Q. 블룸 필터(Bloom filter)에 대해 설명해주세요.(자료구조)

A.  
- 원소가 집합에 속하는지 여부를 검사하는 데 사용하는 확률적 자료구조
- set, bitmap, hash 함수 등을 이용하여 Encoding과 Decoding 과정을 거쳐 어떤 원소가 집합에 포함되는지 판별할 수 있음

https://jeongchul.tistory.com/605

23.02.25
## Q. 배낭 문제(knapsack Problem)에 대해 설명하고 이를 해결하는 알고리즘을 제시하세요.(알고리즘)

A.  
**배낭 문제**
- 일정 무게를 담을 수 있는 배낭에, 각각 고유의 무게와 가격을 가지고 있는 여러 물건들을 담을 때, 가격을 극대화하여 얼마까지 담을 수 있는지 구하는 문제
- 이차원배열을 통해, 각 아이템을 배낭에 넣었을 경우 담긴 가격의 합을 그 전 아이템까지의 합과 비교해가며 최대값을 찾는 DP의 메모이제이션 기법으로 해결할 수 있다

https://propercoding.tistory.com/50

23.02.26
## Q. K-fold Cross Validation에 대해 설명해주세요.(머신러닝)

A.  
**K-fold Cross Validation**
- K개의 fold를 만들어서 진행하는 교차검증
- 총 데이터 개수가 적은 데이터 셋에 대하여 정확도를 향상시킬 수 있음
- 기존에 Training/Validation/Test 세 개의 집단으로 분류하는 것보다, Training과 Test로만 분류할 때 학습 데이터 셋이 더 많기 때문
- 데이터 수가 적은데 검증과 테스트에 데이터를 더 뺏기면 underfitting 등 성능이 미달되는 모델이 학습됨

23.02.27
## Q. 주장(assertion)에 대해서 설명해주세요.(데이터베이스)

A.
**주장**
- 제약조건을 위반하는 연산이 수행되지 않도록 주장의 조건이 그 조건을 위배할 가능성이 있는 각 이벤트문들마다 검사됨
- 데이터베이스가 항상 만족하기를 바라는 조건을 직접적으로 표현한 것으로, 보통 두 개 이상의 테이블에 영향을 미치는 제약조건을 명시하기 위해 사용됨

https://libertegrace.tistory.com/entry/Database-%EB%AC%B4%EA%B2%B0%EC%84%B1-%EC%A0%9C%EC%95%BD%EC%A1%B0%EA%B1%B4

23.02.28
## Q. http 상태코드(status code)의 의미를 설명해주세요.(네트워크)

A.  
**HTTP 상태 코드(Status Code)**
- 클라이언트가 보낸 HTTP 요청에 대한 서버의 응답 코드로, 상태 코드에 따라 요청의 성공/실패 여부를 판단함  

**분류**  
- 1xx(Informational): 조건부 응답
- 2xx(Successful): 성공
- 3xx(Redirection): 리다이렉션 완료
- 4xx(Client Error): 요청 오류
- 5xx(Server Error): 서버 오류

https://developer.mozilla.org/ko/docs/Web/HTTP/Status  
https://velog.io/@sangyeon217/http-status-code

23.03.01  
## Q. 디스크 캐시와 메모리(램) 캐시의 차이점에 대해 설명해주세요.(운영체제)

A.  
**디스크 캐시**  
- 하드디스크에 접근하는 시간을 개선하기 위해 RAM에 저장하는 기법
- 하드디스크에 접근하는 것보다 RAM에 접근하는 것이 더 빠르기 때문

**캐시 메모리**  
- 램에 접근하지 않고 더 빠른 시간으로 접근할 수 있는 CPU 칩 안에 있는 작지만 빠른 메모리(L1, L2, L3)

23.03.02
## Q. 해시 충돌을 해결하는 방법에 대해 설명해주세요.(자료구조)

A.  
1. 체이닝
- 버킷 내에 연결리스트를 할당하여 버킷에 데이터를 삽입
- 해시 충돌이 발생하면 연결리스트로 데이터들을 연결

2. 개방 주소법
- 해시 충돌이 발생하면 다른 버킷에 데이터를 삽입

3. 리사이징
- 배열의 크기(버킷의 개수)를 늘려 해시 충돌을 방지

https://j3sung.tistory.com/759

23.03.03
## Q. 허프만 코딩(Huffman Coding)에 대해 이진 탐색 트리와 함께 설명해주세요.(알고리즘)

A.  
**허프만 코딩(Huffman Coding)**  
- 입력 파일의 문자 빈도 수를 가지고 최소힙을 이용하여 파일을 압축하는 과정  
- 압축할 파일을 스캔하여 각 문자의 빈도 수를 계산한 뒤, 빈도 수를 우선순위로하여 이진 트리를 만들어 압축

https://velog.io/@junhok82/%ED%97%88%ED%94%84%EB%A7%8C-%EC%BD%94%EB%94%A9Huffman-coding#%ED%97%88%ED%94%84%EB%A7%8C-%EC%BD%94%EB%94%A9%EC%9D%B4%EB%9E%80

23.03.04
## Q. Accuracy, Recall, Precision의 차이에 대해 설명해주세요.(머신러닝)

A.  
Accuracy, Recall, Precision은 머신 러닝과 데이터 분석에서 사용되는 성능 지표입니다. 각각의 지표는 모델이 얼마나 정확하게 예측하고 있는지를 측정하는 데 사용됩니다.

- Accuracy (정확도): 모델이 예측한 값 중에서 실제 값과 일치하는 비율입니다. 즉, 모델이 정확하게 예측한 샘플 수를 전체 샘플 수로 나눈 것입니다. 정확도는 전체적인 모델의 성능을 나타내며, 데이터셋이 클래스 간 균형이 있을 때 유용합니다.

- Recall (재현율): 실제 양성 샘플 중에서 모델이 양성이라고 정확하게 예측한 비율입니다. 즉, 모델이 실제 양성인 샘플을 얼마나 잘 찾아내는지를 나타냅니다. Recall은 거짓 음성(FN)을 최소화하는 데 중점을 둡니다. 예를 들어, 암 진단에서 암 환자를 정확하게 예측하는 것이 중요한 경우 Recall을 사용합니다.

- Precision (정밀도): 모델이 양성이라고 예측한 샘플 중에서 실제 양성인 비율입니다. 즉, 모델이 양성으로 예측한 샘플 중에서 실제 양성인 샘플의 비율을 나타냅니다. Precision은 거짓 양성(FP)을 최소화하는 데 중점을 둡니다. 예를 들어, 스팸 필터링에서 실제로 스팸이 아닌 이메일을 스팸으로 분류하는 것을 방지하는 데 Precision을 사용합니다.

이 세 가지 성능 지표는 서로 보완적이므로, 문제에 따라 적절한 지표를 선택해야 합니다. 예를 들어, 암 진단에서는 Recall이 중요하지만, 스팸 필터링에서는 Precision이 더 중요할 수 있습니다.

[출처] ChatGPT

23.03.05
## Q. RDB과 nosql의 차이점을 설명해주세요.(데이터베이스)

A.  
RDB(Realational DataBase)
- 관계형 데이터베이스. 관계형 데이터 모델을 기초로 두고 모든 데이터를 2차원 테이블 형태로 표현하는 데이터베이스
- 테이블 간 관계를 맺고 모여있는 집합체로, foreign key를 이용해 join을 할 수 있다
- 정해진 스키마에 따라 데이터를 저장해야 하므로 명확한 데이터 구조를 보장함

NoSQL(Not Only SQL(Structured Query Language))
- RDB 형태의 관계형 데이터베이스가 아닌, 다른 형태의 데이터 저장 기술
- 테이블 간 관계를 저장하지 않으며, 테이블 간 join이 불가능함
- 스키마가 없기 때문에 유연하며 자유로운 데이터 구조를 가질 수 있음

https://khj93.tistory.com/entry/Database-RDBMS%EC%99%80-NOSQL-%EC%B0%A8%EC%9D%B4%EC%A0%90#:~:text=NoSQL%EC%9D%B4%EB%9E%80(Not%20Only%20SQL,%EA%B4%80%EA%B3%84%EB%A5%BC%20%EC%A0%95%EC%9D%98%ED%95%98%EC%A7%80%20%EC%95%8A%EC%8A%B5%EB%8B%88%EB%8B%A4.

23.03.06
## Q. CDN에 대해서 설명해주세요.(네트워크)

A.  
**CDN(콘텐츠 전송 네트워크)**  
- 지리적으로 분산된 여러 개의 서버
- 웹 페이지, 이미지, 비디오 등의 콘텐츠를 사용자의 물리적 위치와 가까운 프록시 서버에 캐싱하여 전송함으로써 전송 속도를 높임

https://www.akamai.com/ko/our-thinking/cdn/what-is-a-cdn

23.03.07
## Q. 메모리와 스토리지의 차이점은 무엇인가요?(운영체제)

A.  
**메모리**  
- 컴퓨터에서 단기적으로 데이터에 엑세스 할 수 있게 해주는 구성품
- 문서 편집, 응용 프로그램 로딩, 인터넷 검색 등 작업 수행할 때 단기 메모리에 저장된 데이터에 엑세스함
- 책상과 서류 캐비닛 중 책상과 같이 즉시 사용할 필요가 있는 용품은 책상 위에 두고 쉽게 엑세스할 수 있지만, 크기가 제한되어 많은 용품을 올려둘 수 없음

**스토리지**  
- 컴퓨터에서 장기적으로 데이터를 저장하고 엑세스 할 수 있게 해주는 구성품
- 무기한으로 어플리케이션, 운영 시스템 및 파일을 저장
- 책상과 서류 캐비닛 중 서류 캐비닛과 같이 즉각적인 엑세스가 불필요한 항목이 저장되어 있으며 크기가 크기 때문에 많은 것을 저장할 수 있음

**차이점**  
- 메모리의 데이터는 컴퓨터가 꺼지면 모두 지워지는 반면 스토리지의 데이터는 컴퓨터가 꺼지는 횟수에 관계없이 손상되지 않은 채로 유지됨

https://www.kingston.com/kr/blog/pc-performance/difference-between-memory-storage

23.03.08
## Q. B-Tree에 대해 설명해주세요.(자료구조)

A.  
**B-Tree**
- 이진트리에서 발전되어 모든 리프노드들이 같은 레벨을 가질 수 있도록 자동으로 밸런스를 맞추는 트리
- 정렬된 순서를 보장하고, 멀티레벨 인덱싱을 통한 빠른 검색을 할 수 있음
- M차 B트리는 노드 당 최대 M개의 자식을 가질 수 있음
- 각 노드는 key와, 자식 노드들을 가리키는 포인트를 가짐
- key들은 노드 안에서 항상 정렬된 값을 가지며, 이진탐색트리처럼 왼쪽 자식들은 key보다 작은 값을, 오른쪽 자식들은 key보다 큰 값을 가짐

https://velog.io/@emplam27/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-B-Tree

23.03.09
## Q. 이분 매칭(Bipartite Matching)에 대해 설명해주세요.(알고리즘)

A.  
**그래프의 매칭**
- 어떤 집합에서 특정한 관계에 따른 두 원소 쌍을 최대한 많이 만들려고 한다
- 이때 각 원소를 노드(정점)로 하는 그래프를 만든 뒤, 쌍을 만들고자 하는 노드들을 엣지(간선)로 연결한다
- 서로 짝을 이룬 노드들을 연결한 엣지들을 모아보면, 이들은 끝점(엣지에 연결된 노드)을 공유하지 않은 엣지의 집합이 된다
- 이런 엣지의 집합을 그래프의 매칭(matching)이라고 부른다

**이분 그래프**
- 노드(정점)를 두 그룹으로 나눠서 모든 엣지(간선)가 서로 다른 그룹의 노드들을 연결하도록 하는 그래프를 이분 그래프라고 함

**이분 매칭**
- 이분 그래프에서 최대 매칭을 찾는 문제

https://loosie.tistory.com/643

23.03.10
## Q. Probability와 Likelihood의 차이에 대해 설명해주세요.(머신러닝)

A.  
**Probability(확률)**
- 주어진 확률분포에서 관측값 혹은 관측 구간이 어느 정도의 확률로 존재하는지 나타내는 값
- 확률분포를 고정하고 그때의 관측 X에 대한 확률을 구한다

**Likelihood(가능도)**
- 어떤 값이 관측되었을 때, 이것이 어떤 확률 분포에서 왔을지에 대한 확률
- 관측값을 고정하고 그때의 확률분포에 대한 확률을 구한다

https://jjangjjong.tistory.com/41

23.03.11
## Q. 트랜잭션의 각 격리 수준에 대해서 설명하고, 각 수준에서 일어날 수 있는 문제에 대해 설명해주세요.(데이터베이스)

A.  
[23.01.03 질문 및 답변](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/CS%20Q%26A%20a%20Day/Notes.md#q-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98-%EA%B0%81-%EA%B2%A9%EB%A6%AC-%EC%88%98%EC%A4%80%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%84%A4%EB%AA%85%ED%95%98%EA%B3%A0-%EA%B0%81-%EC%88%98%EC%A4%80%EC%97%90%EC%84%9C-%EC%9D%BC%EC%96%B4%EB%82%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EB%AC%B8%EC%A0%9C%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4)

23.03.12
## Q. IaaS, PaaS, SaaS에 대해서 설명해주세요.(네트워크)  

A.  
IaaS(Infrastructure as a Service)
- 서비스형 인프라. 비즈니스 운영에 필요한 스토리지, 네트워킹 및 컴퓨팅 리소스를 제공함

PaaS(Platform as a Service)
- 서비스형 플랫폼. 애플리케이션 및 서비스를 구축할 수 있는 플랫폼을 제공함

SaaS(Software as a Service)
- 서비스형 소프트웨어. 특정 앱 또는 웹 포털을 통해 액세스하는 서비스로, 클라이언트 조직의 최종 사용자에게 제공되는 완전한 소프트웨어 솔루션

https://www.freshworks.com/ko/freshdesk/kblogs/iaas-paas-saas/

23.03.13
## Q. 임계 영역(critical section)에 대해 설명해주세요.(운영체제)

A.  
교착 상태(Dead Lock)
- 둘 이상의 프로세스가 다른 프로세스가 점유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황

공유 자원(Shared Resource)
- 시스템 안에서 각 프로세스, 스레드가 함께 접근할 수 있는 자원이나 변수 등을 의미함
- 이 공유 자원을 두 개 이상의 프로세스가 동시에 읽거나 쓰는 상황을 경쟁 상태(race condition)라고 함
- 동시에 접근을 시도할 때 접근의 타이밍이나 순서 등이 결괏값에 영향을 줄 수 있는 상태

임계 영역(Critical Section)
- 한 순간에는 반드시 프로세스 하나만 진입해야 하는데, 프로그램에서 임계 자원을 이용하는 부분으로 공유 자원의 독점을 보장하는 코드 영역을 의미
- 임계 구역은 지정된 시간이 지난 후 종료됨

https://velog.io/@lovi0714/%EC%9E%84%EA%B3%84-%EC%98%81%EC%97%AD-Critical-Section

23.03.14
## Q. Hash Table에 대해 설명해주세요.(자료구조)  

A.  
해시 함수  
- 입력값을 원하는 범위의 자연수로 바꿔주는 함수

해시 테이블(Hash Table)
- 해시 함수와 배열을 같이 사용하는 자료구조
- key를 바로 인덱스로 하지 않고, 해시 함수에 넣어 return된 값을 인덱스로 사용

https://github.com/jaehyun-dev/Today-I-Learned/blob/main/Data%20Structure/1%20Basic%20Data%20Structures/5%20Hash%20Table/Note.md#03-%ED%95%B4%EC%8B%9C-%ED%85%8C%EC%9D%B4%EB%B8%94-%EA%B0%9C%EB%85%90  
https://ablue-1.tistory.com/68

23.03.15
## Q. Interval Partitioning 문제에 대해 설명하고 이를 해결하기 위한 알고리즘을 제시해주세요.(알고리즘)

A.  
Interval Partitioning
- 각각 정해진 시간 동안 공간을 점유하는 여러 interval을 한 공간에 대해 서로 겹치지 않게 분배하려고 할 때 준비해야 하는 최소한의 공간을 구하는 문제
- 예) n개의 강의에 대해서 모든 수업을 시간과 강의실이 겹치지 않도록 최소한의 강의실을 배정하려면 몇 개의 강의실이 있어야 하는가?

Greedy Algorithm
- 각 interval i에는 시작하는 시각 s_i와 끝나는 시각 f_i가 있다.
- 모든 interval을 s에 대해 정렬한다
- 1번 interval부터 마지막 interval까지, 준비된 공간 중 하나에 들어가면 순차적으로 할당하고, 그렇지 않다면 새로운 공간을 준비한다

https://velog.io/@claude_ssim/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Greedy-Algorithm-Interval-Partitioning

23.03.16
## Q. Cost Function, Loss Function, Object Function에 대해 설명하고 각각의 종류에 대해 설명해주세요.(머신러닝)

A.  
Cost Function, Loss Function, Object Function은 머신 러닝 모델 학습에서 사용되는 함수  
각각의 함수는 모델이 예측하는 값과 실제 값 사이의 차이를 계산하는 데 사용됨

Cost Function (비용 함수)
- 모델의 매개변수를 조정하여 예측 값과 실제 값 사이의 차이를 최소화하는 데 사용되는 함수
- 모델이 예측한 값과 실제 값의 차이를 계산하여 평균화함
- 비용 함수는 전체 데이터셋에 대해 계산되므로, 비용 함수를 최소화하는 것은 모델이 더 정확한 예측을 하도록 학습하는 것을 의미함
- 종류:
    - 평균 제곱 오차 (Mean Squared Error, MSE)
    - 평균 절대 오차 (Mean Absolute Error, MAE)
    - 평균 제곱근 오차 (Root Mean Squared Error, RMSE)

Loss Function (손실 함수)
- 모델이 한 샘플에 대해 예측한 값과 실제 값 사이의 차이를 계산하는 함수
- 모델의 예측이 얼마나 잘못되었는지를 측정함
- 일반적으로 모델의 학습 과정에서 각 샘플마다 손실 함수의 값이 계산되고, 이 값은 비용 함수를 계산하는 데 사용됨
- 종류
    - 이진 교차 엔트로피 (Binary Cross-Entropy)
    - 다중 클래스 교차 엔트로피 (Categorical Cross-Entropy)
    - 로그 손실 (Log Loss)

Objective Function (목적 함수)
- 비용 함수와 손실 함수를 모두 포함하는 함수
- 모델의 매개변수를 조정하여 예측 값과 실제 값 사이의 차이를 최소화하는 데 사용됨
- 일반적으로 모델의 학습 과정에서 목적 함수를 최소화하는 것이 목표
- 종류:
    - 평균 제곱 오차 (Mean Squared Error, MSE)
    - 교차 엔트로피 (Cross-Entropy)
    - 로그 우도 (Log Likelihood)

[출처]
ChatGPT

https://velog.io/@regista/%EB%B9%84%EC%9A%A9%ED%95%A8%EC%88%98Cost-Function-%EC%86%90%EC%8B%A4%ED%95%A8%EC%88%98Loss-function-%EB%AA%A9%EC%A0%81%ED%95%A8%EC%88%98Objective-Function-Ai-tech

23.03.17
## Q. Read Committed와 Repeatable Read 수준의 차이를 설명해주세요.(데이터베이스)

A.  
Read Committed와 Repeatable Read는 모두 데이터베이스에서 사용되는 트랜잭션 격리 수준 중 일부

Read Committed (RC)
- 다른 트랜잭션에서 변경한 데이터를 볼 수 없는 격리 수준
- 다른 트랜잭션이 커밋하기 전까지는 변경 내용이 적용되지 않음
- Dirty Read 문제는 발생하지 않지만, Non-Repeatable Read와 Phantom Read 문제가 발생할 수 있음

Repeatable Read (RR)
- 동일한 쿼리를 실행할 때 결과가 항상 일관된 격리 수준
- 한 번 읽은 데이터를 다시 읽을 때, 항상 같은 값을 반환함
- 다른 트랜잭션에서 새로운 데이터를 추가하는 것은 허용하지만, 기존 데이터를 수정하거나 삭제하는 것은 허용하지 않음
- Dirty Read와 Non-Repeatable Read 문제가 발생하지 않지만, Phantom Read 문제가 발생할 수 있습니다.

Read Committed와 Repeatable Read는 데이터의 일관성과 동시성 처리에 관련된 문제를 해결하기 위해 사용됨  
두 격리 수준은 각각 Dirty Read, Non-Repeatable Read, Phantom Read 문제를 다르게 해결하고 있으며, 애플리케이션에 따라 적합한 격리 수준을 선택해야 함

[출처] ChatGPT

https://tillog.netlify.app/posts/transaction

23.03.18
## Q. 클라우드 컴퓨팅이란 무엇이고 어떤 장점이 있을까요?(네트워크)

A.  
클라우드 컴퓨팅(Cloud Computing)
- 인터넷을 통해 서비스를 제공하는 컴퓨팅 기술
- 인터넷을 통해 서버, 스토리지, 데이터베이스, 네트워크 등의 IT 인프라와 애플리케이션을 사용자에게 제공하는 기술

장점
- 유연성과 확장성
    - 사용자가 필요한 만큼의 IT 리소스를 쉽게 확장하거나 축소할 수 있도록 제공하므로 비즈니스의 요구에 맞게 유연하게 대처할 수 있음
- 경제성
    - 클라우드 컴퓨팅은 기업이 자체적으로 IT 인프라를 구축하는 것보다 비용이 저렴하므로 기업은 자본비용을 줄이고 운영비용을 절감할 수 있음
- 높은 가용성과 신뢰성
    - 클라우드 서비스 제공 업체는 대부분 다양한 지리적 위치와 다중 데이터 센터를 보유하고 있으므로 장애나 문제가 발생했을 때에도 데이터와 서비스에 대한 가용성과 신뢰성을 높일 수 있음
- 높은 보안성
    - 클라우드 서비스 제공 업체는 보안 위험에 대응하기 위한 다양한 보안 기술과 방어 체계를 보유하고 있으므로 기업은 자체적으로 보안을 유지하며 운영하는 것보다 높은 수준의 보안성을 제공받을 수 있음
- 쉬운 관리
    - 클라우드 서비스 제공 업체는 IT 인프라의 관리와 유지보수를 대신 수행하므로 기업은 인프라 운영에 집중하지 않고 비즈니스에 집중할 수 있음

[출처] ChatGPT

https://aws.amazon.com/ko/what-is-cloud-computing/

23.03.19
## Q. 커널 수준의 스레드와 사용자 수준의 스레드의 차이점에 대해 설명해주세요.(운영체제)

A.  
- 스케줄링
    - 커널: 스케줄링을 운영체제 커널에서 처리하므로 스레드 간의 우선순위, 스케줄링 알고리즘 등을 이용해 효율적인 스케줄링을 수행할 수 있음
    - 사용자: 스케줄링을 스레드 라이브러리에서 처리하기 때문에, 운영체제의 스케줄링과는 독립적으로 작동함

- 동기화
    - 커널: 커널 수준의 동기화 메커니즘을 사용하여 스레드 간의 동기화 문제를 해결할 수 있음
    - 사용자: 사용자 수준의 동기화 메커니즘만 사용할 수 있기 떄문에 공유자원에 대한 접근 시 동기화 문제를 처리하기 어려울 수 있음

- 오버헤드
    - 커널: 운영체제 커널에 의존하므로, 커널과 사용자 간의 모드 전환이 발생하므로 컨텍스트 전환 오버헤드가 발생할 수 있음
    - 사용자: 라이브러리에서 관리하므로, 스레드 간의 컨텍스트 전환 오버헤드가 적음

- 확장성
    - 커널: 운영체제 커널에서 처리하기 때문에, 커널이 지원하는 만큼 많은 수의 스레드를 생성할 수 있음
    - 사용자: 스레드 라이브러리에서 처리하기 때문에, 스레드의 개수가 제한될 수 있음

[출처] ChatGPT

https://helloinyong.tistory.com/m/293

23.03.20
## Q. B+Tree에 대해 설명해주세요.(자료구조)

A.  
B+Tree
- 데이터베이스에서 매우 널리 사용되는 트리 구조 자료구조 중 하나
- Balanced Tree의 일종으로, 노드의 수가 적어지거나 늘어나는 것을 최소한으로 유지하면서 효율적인 데이터 검색과 삽입, 삭제를 가능하게 함

특징
1. 노드의 구성
    - B+Tree는 내부 노드와 리프 노드로 구성됨
    - 리프 노드는 데이터를 저장하는 역할을 하고, 내부 노드는 리프 노드를 연결하고, 데이터 검색에 필요한 키 값을 저장함
    - 리프 노드는 각각의 키 값에 대한 데이터를 저장하며, 정렬된 순서로 이어져 있음
2. 균형 잡힌 트리 구조
    - B+Tree는 균형 잡힌 트리 구조로, 모든 리프 노드가 같은 레벨에 위치함
    - 이를 통해 데이터 검색에 필요한 시간을 최소화함
3. 효율적인 검색
    - B+Tree는 내부 노드에 저장된 키 값들을 이용하여 검색 범위를 좁힐 수 있어서 매우 빠른 검색 속도를 제공함
4. 효율적인 삽입과 삭제
    - B+Tree는 노드의 수를 최소한으로 유지하면서 효율적인 데이터 삽입과 삭제를 가능하게 함
5. 다중 버전 동시성 제어(MVCC) 지원
    - B+Tree는 다중 버전 동시성 제어(MVCC)를 지원하여 여러 사용자가 동시에 데이터를 읽거나 쓸 수 있도록 함

- B+Tree는 대용량 데이터베이스의 인덱싱에 매우 적합한 자료구조
- B+Tree는 자동으로 균형이 맞춰지므로, 데이터 삽입과 삭제가 빈번하게 일어나는 상황에서도 매우 빠른 검색 속도를 유지할 수 있음
- 또한, 다중 버전 동시성 제어(MVCC)를 지원하여 여러 사용자가 동시에 데이터를 읽거나 쓸 수 있도록 하기 때문에 데이터베이스의 병목 현상을 최소화할 수 있음

[출처] ChatGPT

https://velog.io/@emplam27/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-B-Plus-Tree

23.03.21
## Q. 최근접 접쌍 찾기 알고리즘(Closest Pair of Points)의 동작 방식을 시간복잡도와 함께 설명해주세요.(알고리즘)

A.  
최근접 접쌍 찾기 알고리즘(Closest Pair of Points)
- 평면 상의 점들 중에서 가장 가까운 두 점의 쌍을 찾는 알고리즘

알고리즘의 동작 방식
1. 입력으로 주어진 점들을 x좌표를 기준으로 정렬
2. 정렬된 점들을 반으로 나누어 왼쪽과 오른쪽으로 분할
3. 분할된 영역에 점이 3개 이하가 될 때까지 각 영역을 재귀적으로 왼쪽과 오른쪽으로 분할
4. 분할된 영역에 속한 점들 중에서 가장 가까운 두 점의 쌍과 오른쪽 부분에 속한 점들 중에서 가장 가까운 두 점의 쌍을 각각 재귀적으로 찾기
5. 왼쪽 부분과 오른쪽 부분에서 찾은 가장 가까운 두 점의 쌍 중에서 더 가까운 쌍을 선택
6. 더 가까운 쌍을 기준으로 중심선을 그리고, 중심선을 넘어가지 않는 점들 중에서 가장 가까운 두 점의 쌍을 찾기. 이때, 이전에 찾은 가장 가까운 쌍보다 더 가까운 쌍이 있는지 확인
7. 최종적으로 찾은 가장 가까운 두 점의 쌍을 반환

시간복잡도
- O(nlogn)

[출처] ChatGPT

https://bblackscene21.tistory.com/11

23.03.22
## Q. L1, L2 정규화에 대해 설명해주세요.(머신러닝)

A.  
딥러닝 모델 과적합을 막는 방법에는 세 가지가 있음
- batch normalization(배치 정규화)
- weigt regularization(정규화)
- dropout(학습 당시 랜덤으로 절반의 뉴런만 사용하기)

이중 weight regularization에 해당하는 것이 L1, L2 정규화

학습을 진행할 때, 학습 데이터에 따라 특정 weight의 값이 커지게 될 수 있음  
그러면 과적합이 일어날 가능성이 아주 높은데, 이를 방지하기 위해 L1, L2 정규화를 사용함  

L1 정규화  
![image](https://user-images.githubusercontent.com/71001479/226781170-fa5c0ca5-1c18-422c-9dc5-12afbb57bf20.png)

cost function에 가중치의 절댓값을 더하여 중요한 가중치만 남김

L2 정규화  
![image](https://user-images.githubusercontent.com/71001479/226781434-6c5c061a-0ff5-4236-aced-c70ecd869ae3.png)

cost function에 제곱한 가중치 값을 더하여 cost와 가중치가 줄어드는 방식으로 학습하여 특정 가중치가 비이상적으로 커지는 상황을 방지함

https://huidea.tistory.com/154

23.03.23

## Q. Dirty Read 현상과 이 현상이 발생하는 레벨에 대해서 설명해주세요.(데이터베이스)

A.  
Dirty Read  
- 다른 트랜잭션이 아직 Commit 되지 않은 데이터를 읽어들이고, Rollback 후의 값을 다시 읽어 최종 결괏값이 달라지는 현상
- 4가지 격리 수준 중 첫 번째 단계인 Read Uncommitted 레벨에서 발생함

http://blog.skby.net/dirty-read/

23.03.24
## Q. 캐시 교체 알고리즘에 대해 설명해주세요.(네트워크)

A.  
캐시  
- 데이터나 값을 미리 복사해놓는 임시 장소
- 자주 쓰는 데이터를 캐시에 복사해두면, 빠른 속도로 접근이 가능하다
- 용량 크기에 제한이 있기 때문에, 새로운 캐시를 넣기 위해서는 기존의 데이터를 삭제해야 함

케시 교체 알고리즘
- 새로운 캐시를 저장하기 위해 어떤 데이터 파일을 캐시에서 삭제할지 결정하는 알고리즘

종류
- FIFO(First In First Out): 가장 먼저 들어간 캐시를 교체
- LFU(Least Frequently Used): 사용 횟수가 가장 적은 캐시를 교체
- LRU(Least Recently Used): 가장 오랫동안 사용되지 않은 캐시를 교체

https://gengmi.tistory.com/entry/Cache-%EC%BA%90%EC%8B%9C-%EB%8F%99%EC%9E%91%EA%B3%BC-%EC%BA%90%EC%8B%9C-%EA%B5%90%EC%B2%B4-%EC%A0%95%EC%B1%85

23.03.25
## Q. 메모리 단편화를 해결하는 방법에 대해 설명해주세요.(운영체제)

A.  
1. 압축: 여러곳에 분산되어 있는 단편화된 메모리 공간을 합쳐 사용할 수 있는 하나의 큰 공간을 만드는 방법(디스크 조각모음)
2. 통합: 단편화가 발생된 공간에서 인접해있는 다른 단편화 공간들을 하나로 합쳐 큰 공간을 만드는 방법
3. 페이징: 프로그램을 페이지 단위로 나누고, 실제 메모리 공간을 프레임 단위로 나눠, 페이지의 논리적 주소를 프레임의 물리적 주소에 매핑하는 방법
4. 세그멘테이션: 가상 메모리를 서로 크기가 다른 논리적 단위인 세그먼트로 분할해서 메모리를 할당하여 실제 메모리 주소로 변환하는 방법

https://kosaf04pyh.tistory.com/40

23.03.26
## Q. 이진 탐색 트리(Binary Search Tree)에 대해 설명해주세요.(자료구조)

A.  
이진 탐색 트리(Binary Search Tree)  
- 이진 트리이면서, 왼쪽의 모든 노드는 부모 노드보다 작아야 하고, 오른쪽의 모든 노드는 부모 노드보다 큰 속성을 만족하는 트리
- 이진 탐색과 링크드리스트의 장점을 결합하여 효율적인 탐색과 입력 및 삭제가 가능함  
- 중위 순회를 하면 값을 정렬된 순서로 읽을 수 있음

https://ratsgo.github.io/data%20structure&algorithm/2017/10/22/bst/
