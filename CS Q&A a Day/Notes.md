22.09.12  
## Q. 라우터의 라우팅 기술인 정적라우팅과 동적라우팅에 대해 설명해주세요.  

A. 정적 라우팅(Static Routing)은 송수신 호스트 사이에서 패킷 전송이 이루어지기 전에 경로 정보를 라우터에 미리 저장하여 중개하는 방식이다. 패킷을 중개하기 위한 최적의 경로 정보는 개별 라우터별로 저장하여 관리하는데, 운용 중인 네트워크 구성에 변화가 생기면 이에 적절하게 대처할 수 없다는 문제점이 있다. 즉, 라우터에 보관된 경로 정보가 고정되어 변화된 정보를 갱신하기가 용이하지 않으며, 특히 네트워크 내부의 혼잡도를 반영할 수 없다.  
  
동적 라우팅(Dynamic Routing)은 라우터에서 사용하는 경로 정보를 네트워크 상황에 따라 적절하게 변경하는 방식으로, 경로 정보의 변경 주기에 따라 계속 보완할 수 있다. 따라서 현재의 네트워크 상황을 고려해 최적 경로 정보를 선택할 수 있지만, 경로 정보를 수집하고 관리하는 등의 복잡한 작업이 추가로 필요하다. 이는 네트워크에 새로운 부하를 가해 성능에 부정적인 영향을 미친다.
  
동적 라우팅 방식을 사용하려면 현재의 네트워크 링크 상태를 점검해 이를 새로운 경로 배정 시 적용해야 한다. 각 라우터에서는 주변 라우터의 존재 유무와 전송 지연 시간 등을 확인할 수 있어야 한다. 또한 각 라우터가 획득한 경로 정보를 다른 라우터에 통보함으로써, 네트워크의 최신 경로 정보를 신속하게 공유하고 갱신해야 한다.
  
[네이버 지식백과] 라우팅

https://m.blog.naver.com/dreamxpeed/221671848467

22.09.13
## Q. 전송계층의 기능 중 멀티플렉싱과 디멀티플렉싱 기술에 대해 설명해주세요.

A. 멀티플렉싱(다중화)은 데이터 전송에서 두 개 이상의 데이터 송신 장치가 각각의 통신로를 갖도록 한 개의 전송 매체를 공유시키는 기능이다. 디멀티플렉싱(역다중화)은 원래의 독립 신호 또는 이들 신호의 군(群)을 복원시키기 위해 다중화된 복합 신호를 분리하여, 원래의 신호 또는 신호의 군으로 복원하는 과정이다.

[네이버 지식백과] 다중화, 역다중화  

https://m.blog.naver.com/kiseop91/221554095982

22.09.14
## Q. 고정IP와 유동IP에 대해서 설명해주세요.

A. **고정 IP 주소**  
공인 IP 주소든 가상 IP 주소든 컴퓨터 등에 IP 주소를 설정하려면, 누군가(주로 서버 시스템)가 IP 주소를 컴퓨터에 배급, 할당해 줘야 한다. 공인 IP 주소라면 해당 인터넷 서비스 업체의 주소 할당 서비스가, 가상 IP 주소라면 인터넷 공유기가 이 역할을 수행한다. 이때 IP 주소를 할당 받는 컴퓨터 등은 이를 자동으로 설정할지, 아니면 수동으로 설정할지를 선택할 수 있다. 고정 IP 주소는 사용자가 직접 IP 주소를 입력해 주소를 설정하는 방식을 말한다. IP 주소가 변경되면 안 되는 컴퓨터(파일 공유 서버 등) 등에 적합한 것으로 일반적으로 특별한 경우 외에는 사용할 기회가 거의 없다. 윈도우의 네트워크 연결 속성 페이지에서 '다음 IP 주소 사용' 옵션을 선택하고, 원하는 IP 주소를 4개 마디에 맞게 입력하면 된다(각 마디는 255를 넘을 수 없다).

**유동 IP 주소**  
IP 주소를 할당하는 특정 서버가 보내 주는 정보 그대로 컴퓨터에 자동 설정되는 방식이다. 이를 'DHCP(Dynamic Host Configuration Protocol)' 서비스라 하는데, 컴퓨터가 부팅하면 DHCP 서버에 IP 주소 할당을 요청하고, 이를 수신한 DHCP 서버가 해당 컴퓨터에 IP 주소 등의 네트워크 정보를 전달하면, 컴퓨터에서는 이를 자동으로 등록, 설정하게 된다. 이 DHCP 서비스는 컴퓨터 수가 많은 환경에서 특히 간편하고 유용하다. 이론적으로 컴퓨터가 매번 부팅할 때마다(즉 IP 할당 요청이 발생할 때마다) IP 주소는 변경되지만, 이전에 할당 받았던 IP 주소 그대로 재할당 받는 경우가 더 많다. 인터넷 공유기는 가상 IP 주소를 생성(NAT 서비스)하여 각 컴퓨터 등에 자동 할당(DHCP 서비스)하는 역할을 동시에 수행하는 것이다.

1. 컴퓨터가 부팅되며 DHCP 서버가 존재함을 탐지한다
2. DHCP 서버는 컴퓨터에 IP 주소 등이 할당되어 있는지 확인한다
3. 컴퓨터가 DHCP 서버에 IP 주소 할당을 요청한다
4. DHCP 서버는 IP 주소 할당 현황에 따라 IP 주소 등의 정보를 컴퓨터에 할당한다

물론 DHCP 서비스를 적용했어도 특정 컴퓨터에 고정 IP 주소를 할당해야 한다면, (앞서 설명한 대로) 윈도우 네트워크 속성 페이지에서 '다음 IP 주소 사용' 설정을 이용하면 된다. 그럼 그 컴퓨터는 IP 주소 자동 할당 목록에서 제외된다.

[네이버 지식백과] IP 주소 - 컴퓨터 네트워크의 전화번호 (용어로 보는 IT, 이문규, IT 동아)

https://yoo11052.tistory.com/32?category=945084

22.09.16
## Q. 버퍼링(Buffering)에 대해서 설명해주세요.

A. 컴퓨터 시스템에서의 처리를 어떤 장치로부터 다른 장치로 데이터를 일방통행으로 전송할 때 양자의 속도차를 수정하기 위하여 중간에서 데이터를 일시적으로 기억 장소에 축적하는 수법. 이 방식에 의하면 고속 중앙 처리 장치(CPU)와 저속 입출력 장치의 작동 속도를 조정할 수 있으며, 컴퓨터 시스템 전체의 처리 능력이 향상된다. 현재 거의 모든 컴퓨터 시스템에서 채용하고 있다.

[네이버 지식백과] 완충(buffering)

https://m.blog.naver.com/jk130694/220677902462

22.09.17
## Q. 선점 스케줄링과 비선점 스케줄링의 차이점에 대해서 설명해주세요.

A. 선점 스케줄링(preemptive scheduling)은 한 프로세스가 중앙 처리 장치(CPU)를 점유했을 때 또 다른 프로세스가 그 CPU를 점유할 수 있도록 하는 것이다. 선점 스케줄링은 높은 우선 순위의 프로세스들이 긴급을 요할 때 유용하며, 대화식 시분할 시스템에서 빠른 응답 시간을 유지하는 데 대단히 중요하다.

비선점 스케줄링(non-preemptive scheduling)은 작업이 프로세스로 생성되어 CPU를 할당받으면 프로세스가 종료되거나 입출력 조작을 위해 자발적으로 중지될 때까지 계속 실행되도록 보장하는 스케줄링 정책이다. 한 프로세스가 일단 CPU를 할당받으면 다른 프로세스가 CPU를 강제로 뺏을 수 없는 방식이다. 비선점 스케줄링은 프로세스 간의 오버헤드(overhead)가 적어 효율적이나, 대화식 시분할 시스템에는 적합하지 않고, 긴 작업이 짧은 작업을 오랫동안 기다리게 되는 경우가 발생되는 단점이 있다.

[네이버 지식백과] 선점 스케줄링, 비선점 스케줄링

https://www.uname.in/m/252

22.09.18
## Q. 데이터베이스의 차수와 카디널리티에 대해서 설명해주세요.

A. **차수**  
하나의 릴레이션에서 속성의 전체 개수를 릴레이션의 차수(degree)라고 한다. 모든 릴레이션은 최소 1 이상의 차수를 유지해야 한다. 릴레이션의 차수는 일반적으로 자주 변하지 않는다는 정적인 특징이 있다.

**카디널리티**  
하나의 릴레이션에서 투플의 전체 개수를 릴레이션의 카디널리티(cardinality)라고 한다. 투플이 없는 릴레이션이 존재할 수도 있다. 새로운 투플이 계속 삽입되거나 기존 투플이 삭제될 수 있으므로 릴레이션의 카디널리티는 일반적으로 자주 변한다는 동적인 특징이 있다.

[네이버 지식백과] 차수, 카디널리티

https://jhnyang.tistory.com/108

22.09.19
## Q. 후보키, 기본키, 대체키의 상관관계에 대해서 설명해주세요.

A. **후보키**(candidate key)는 유일성과 최소성을 만족하는 속성 또는 속성들의 집합이다. 최소성(minimality)은 키를 구성하고 있는 여러 속성 중에서 하나라도 없으면 투플을 유일하게 구별할 수 없는, 꼭 필요한 최소한의 속성들로만 키를 구성하는 특성이다. 그러므로 하나의 속성으로 구성된 키는 당연히 최소성을 만족한다.

릴레이션에서 투플을 구별하기 위해 여러 개의 후보키를 모두 사용할 필요는 없다. 데이터베이스 설계자나 관리자는 여러 후보키 중에서 기본적으로 사용할 키를 반드시 선택해야 하는데 이것이 **기본키**(primary key)다. 만약 후보키가 한 개만 존재하면 당연히 해당 후보키를 기본키로 선택해야 하겠지만 여러 개일 경우에는 데이터베이스 사용 환경을 고려하여 적합한 것을 기본키로 선택하면 된다.

**대체키**(alternate key)는 기본키로 선택되지 못한 후보키들이다. 이름에서 알 수 있듯이 대체키는 기본키를 대신할 수 있지만 기본키가 되지 못하고 탈락한 이유가 있을 수 있다. 따라서 기본키로 선택되지 못한 속성 집합이 대체키가 된다.

![image](https://dbscthumb-phinf.pstatic.net/4515_000_1/20160715112620819_1D1GTA96B.jpg/ka26_87_i1.jpg?type=w406_fst_n&wm=Y)

[네이버 지식백과] 후보키, 기본키, 대체키

https://computer-science-student.tistory.com/195

22.09.20
## Q. 도메인 제약조건에 대해서 설명해주세요.

A.
<li>각 애트리뷰트 값이 반드시 <b>원자값</b>이어야 함</li>
<li>애트리뷰트 값의 디폴트 값, 가능한 값들의 범위 등을 지정할 수 있음</li>
<li>데이터 형식을 통해 값들의 유형을 제한하고, CHECK 제약 조건을 통해 값들의 범위를 제한할 수 있음</li>
<li>SQL2는 도메인을 명시적으로 정의하는 것을 허용하지만, 오라클은 지원하지 않음</li>
<br>
  
https://rainbow97.tistory.com/entry/Database-02-4-%EB%AC%B4%EA%B2%B0%EC%84%B1-%EC%A0%9C%EC%95%BD%EC%A1%B0%EA%B1%B4

22.09.21
## Q. 물리적 데이터베이스의 히프파일과 순차파일에 대해서 설명해주세요.

A. **히프 파일**(Heap File)  
- 삽입된 순서대로 레코드를 파일 내에 배치하는 것으로서 파일의 마지막에 새로운 레코드를 삽입한다.

**순서 파일**Sequential File)  
- 레코드 필드들 중에서 순서 필드라고 하는 한 필드 값의 순서대로 디스크에 물리적으로 정렬할 수 있다.

https://swin9333.tistory.com/65

22.09.22
## Q. 트랜잭션의 원자성에 대해서 예를 들어 설명해주세요.

A. 트랜잭션의 **원자성**(atomicity)은 트랜잭션을 구성하는 연산들이 모두 정상적으로 실행되거나 하나도 실행되지 않아야 한다는 all-or-nothing 방식을 의미한다. 만약 트랜잭션을 수행하다가 장애가 발생하여 작업을 완료하지 못했다면, 지금까지 실행한 연산들 모두 처리를 취소하고 데이터베이스를 트랜잭션 작업 전의 상태로 되돌려 트랜잭션의 원자성을 보장해야 한다. 트랜잭션의 원자성을 보장하면 트랜잭션을 구성하는 연산 중 일부만 처리한 결과를 데이터베이스에 반영하는 일이 없게 된다.

[네이버 지식백과] 원자성

https://hanamon.kr/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98-acid-%EC%84%B1%EC%A7%88/

22.09.23  
## Q. SQL조건절에 사용되는 ANY / ALL 의 차이를 설명해주세요.

A. **ANY 연산자**는 주로 서브쿼리에 사용되며 하나라도 만족하는 값이 있다면 true를 반환한다.

**ALL 연산자**는 전체 만족해야 true를 반환하는 특징을 가지고 있다.

https://lhoris.tistory.com/136 

22.09.25
## Q. 현재 레코드에 공유로크가 걸려있는 경우 해당 레코드에 공유로크와 독점로크를 요청했을 때 결과를 설명해주세요.

A. 공유로크가 걸려있는 경우, 공유로크를 요청하면 허용하게 되고, 독점로크를 요청하면 대기하게 된다.

https://velog.io/@chez_kwak/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-9.-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98

22.09.26
## Q. WAL이 무엇이고 왜 필요한지 설명해주세요.

A. **WAL**(Write-Ahead-Logging)
- WAL이란 Write-Ahead Logging의 약자로 로그 선행 기입
- WAL을 사용하는 시스템에서 모든 수정은 적용을 하기 전에 먼저 로그에 기록된다.
- 트랜잭션 발생시 로그에 일단 기입하여 기록을 남기고, 특정 데이터가 쌓이면 이를 flush 해 DB의 disk에 DATA BLOCK 형태로 write하게 된다.
- 일단 Log에 적히게 되면 누가 조회를 하던간에 같은 데이터를 보여주는 일관성 (Consistency)을 보장하게 되고 서버가 다운되도 이미 Log에 기입되어 있기 때문에 원자성 (Atomicity)도 보장할 수 있다.
- REDO 및 UNDO 정보를 모두 로그에 기록하며, buffer를 비우기 전에 로그파일에 기록

https://nays111.tistory.com/12

22.09.27
## Q. 멀티프로그래밍과 멀티태스킹의 차이점에 대해 설명해주세요.

A. **멀티 프로그래밍** (Multi-programming)  
초기의 컴퓨터에서는 하나의 프로그램이 메모리에 올라가면 하나의 프로그램만 CPU가 처리를 진행할 수 있었다. 이 과정에서 프로세서의 처리 속도와 입출력 속도 간의 차이로 인해, 입출력이 완료될 때까지 프로세서는 idle한 상태가 된다. 따라서 이는 프로세서의 자원 낭비로 이루어진다.  
프로세서가 입출력 작업의 종료를 대기할 동안 하나의 프로세서에서 다른 프로그램을 수행할 수 있도록 하는 것이 멀티프로그래밍이다.

**멀티 태스킹** (Multi-tasking)  
Task란 운영체제에서 처리하는 작업의 단위 또는 정해진 일을 수행하기 위한 명령어 집합을 뜻하는데 (process 보다 확장된 개념), 멀티 태스킹은 task를 OS의 스케쥴링에 의해 task를 번갈아가며 수행하는 것을 의미한다.  
여러개의 task를 자주 번갈아가며 수행하다보니 사용자는 동시에 여러 task가 수행되고 있다고 느끼게 된다.

https://velog.io/@chy0428/OS-%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EC%84%B8%EC%8B%B1

22.09.28
## Q. 다섯 가지 점근 표기법에 대해 설명해주세요.

A.  
| 표기법 |         대략적 의미        |
|:------:|:--------------------------:|
| f=ω(g) |     f는 g보다 크다, f>g    |
| f=Ω(g) | f는 g보다 크거나 같다, f≥g |
| f=Θ(g) |   f는 g와 대략 같다, f=g   |
| f=O(g) | f는 g보다 작거나 같다, f≤g |
| f=o(g) |     f는 g보다 작다, f<g    |

https://ratsgo.github.io/data%20structure&algorithm/2017/09/13/asymptotic/

22.09.29
## Q. 데드락(Deadlock) 회피 기법인 은행원 알고리즘에 대해 설명해주세요.

A. **데드락**(교착상태) 회피는 데드락이 빠질 가능성이 있는지 없는지 운영체제가 검사하고 빠질 가능성이 없을 경우에만 자원을 할당함으로써 문제 발생을 피하는 방법이다.

데드락 회피 기법 중 하나인 **은행원 알고리즘**은, 교착상태에 빠질 가능성이 있는지 판단하기 위해 상태를 '안전상태(safe state)'와 '불안전상태(unsafe state)'로 나누고, 안전상태를 유지할 수 있는 요구만을 수락하고 불안전 상태를 초래할 사용자의 요구는 나중에 만족될 수 있을 때까지 계속 거절하는 알고리즘이다.

https://jhnyang.tistory.com/102

22.09.30
## Q. 인터럽트(interrupt)의 정의와 종류에 대해 설명해주세요.

A.  
정의: 프로그램을 실행하는 도중에 예기치 않은 상황이 발생할 경우 현재 실행 중인 작업을 즉시 중단하고, 발생된 상황에 대한 우선 처리가 필요함을 CPU에게 알리는 것.  
지금 수행 중인 일보다 더 중요한 일(ex. 입출력, 우선 순위 연산 등)이 발생하면 그 일을 먼저 처리하고 나서 하던 일을 계속해야 한다.

종류: 외부 인터럽트, 내부 인터럽트, 소프트웨어 인터럽트

https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/Interrupt.md

22.10.01
## Q. 2단계 로킹 프로토콜에 대해서 설명해주세요.

A. 기본 로킹 규약의 문제를 해결하고 트랜잭션의 직렬 가능성을 보장하기 위해 lock과 unlock 연산의 수행 시점에 대한 새로운 규약을 추가한 것이 **2단계 로킹 규약**(2PLP;2 Phase Locking Protocol)이다. 트랜잭션 스케줄의 모든 트랜잭션이 2단계 로킹 규약을 준수하면 해당 스케줄은 직렬 가능성이 보장된다.

[네이버 지식백과] 2단계 로킹 규약

https://noil0816.tistory.com/153

22.10.02
## Q. 컨테이너의 종류와 각각의 특징에 대해 아는대로 모두 설명해주세요.

A.
- 시퀀스 컨테이너: 데이터를 선형적으로 저장하고 삽입된 요소의 순서가 그대로 유지된다.
- 연관 컨테이너: 관련있는 데이터를 하나의 쌍으로 저장하는 컨테이너로 보통 균형 이진 트리나 해시 테이블을 사용하여 구현된다.
- 어댑터 컨테이너: 기존 커너테이너의 인터페이스를 제한하거나 변형하여 만든 컨테이너로 반복자를 지원하지 않아 STL 알고리즘을 이요할 수 없다.

https://techbless.github.io/2020/11/04/C-STL-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EC%9A%94%EC%95%BD-%EC%A0%95%EB%A6%AC/

22.10.04
## Q. 거품 정렬(Bubble Sort)의 구현 방식, 시간복잡도, 공간복잡도, 장단점에 대해 설명해주세요.

A.  
구현 방식:
1. 1회전에 첫 번째 원소와 두 번째 원소를, 두 번째 원소와 세 번째 원소를, 세 번째 원소와 네 번째 원소를, … 이런 식으로 (마지막-1)번째 원소와 마지막 원소를 비교하여 조건에 맞지 않는다면 서로 교환한다.
2. 1회전을 수행하고 나면 가장 큰 원소가 맨 뒤로 이동하므로 2회전에서는 맨 끝에 있는 원소는 정렬에서 제외되고, 2회전을 수행하고 나면 끝에서 두 번째 원소까지는 정렬에서 제외된다. 이렇게 정렬을 1회전 수행할 때마다 정렬에서 제외되는 데이터가 하나씩 늘어난다.

시간복잡도: O(n^2)

공간복잡도: O(n)

장점:  
- 구현이 매우 간단하고, 소스코드가 직관적이다.
- 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않다. => 제자리 정렬(in-place sorting)
- 안정 정렬(Stable Sort) 이다.

단점:  
- 시간복잡도가 최악, 최선, 평균 모두 O(n^2)으로, 굉장히 비효율적이다.
- 정렬 돼있지 않은 원소가 정렬 됐을때의 자리로 가기 위해서, 교환 연산(swap)이 많이 일어나게 된다.

https://gyoogle.dev/blog/algorithm/Bubble%20Sort.html

22.10.05
## Q. 단일 연결리스트에서 중간 삽입과 삭제를 O(n)이 아니라 $\Theta$(1)로 만들 수 있는 이유에 대해 설명해주세요.

A. 삽입 시에는 새로운 노드를 만들고 앞 노드의 주소칸만 수정하면 되고, 삭제 시에는 원하는 노드를 삭제하고 앞 노드의 주소칸만 수정하면 되기 때문이다.

https://gusdnd852.tistory.com/100

22.10.06
## Q. 파일접근 방식인 순차접근과 임의접근에 대해 설명해주세요.

A. **순차 접근(Sequential Access)**  
원하는 레코드를 찾기 위해 파일의 현재 위치에서 차례대로 탐색을 실시하는 접근 방법이다. 특별한 구현이 없다면, 레코드를 접근할 때마다 디스크를 물리적으로 움직여야하기 때문에 매우 비효율적이다.

**임의 접근(Random Access)**  
시스템이나 프로그래머가 원하는 위치부터 파일을 읽는 접근 방법이다. 5번 레코드를 접근하기 위해 1, 2, 3, 4, 5 레코드를 모두 접근하는 것이 아니라 5번 레코드를 바로 접근하기 때문에 직접 접근(direct access)라고도 한다. 단 한번의 디스크 접근을 통해 레코드에 접근하기 때문에 항상 순차 접근보다 성능이 좋거나 같다.

https://untitledtblog.tistory.com/64

22.10.07
## Q. 퀵 정렬(Quick Sort)의 구현 방식, 시간복잡도, 공간복잡도, 장단점에 대해 설명해주세요.

A.
구현 방식:  
1. 배열 가운데서 하나의 원소를 고른다. 이렇게 고른 원소를 피벗(pivot) 이라고 한다.
2. 피벗 앞에는 피벗보다 값이 작은 모든 원소들이 오고, 피벗 뒤에는 피벗보다 값이 큰 모든 원소들이 오도록 피벗을 기준으로 배열을 둘로 나눈다. 이렇게 배열을 둘로 나누는 것을 분할(Divide) 이라고 한다. 분할을 마친 뒤에 피벗은 더 이상 움직이지 않는다.
3. 분할된 두 개의 작은 배열에 대해 재귀(Recursion)적으로 이 과정을 반복한다.

시간복잡도: 평균 O(nlog₂n), 최악의 경우 O( $n^2$ )

공간복잡도: O(n)

장점:
- 불필요한 데이터의 이동을 줄이고 먼 거리의 데이터를 교환할 뿐만 아니라, 한 번 결정된 피벗들이 추후 연산에서 제외되는 특성 때문에, 시간 복잡도가 O(nlog₂n)를 가지는 다른 정렬 알고리즘과 비교했을 때도 가장 빠르다.
- 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않는다.

단점:
- 불안정 정렬(Unstable Sort) 이다.
- 정렬된 배열에 대해서는 Quick Sort의 불균형 분할에 의해 오히려 수행시간이 더 많이 걸린다.

https://www.google.com/search?q=quick+sort+time+complexity&oq=quick+sort+time+&sourceid=chrome&ie=UTF-8


22.10.08
## Q. List, Set, Map의 차이점에 대해 설명해주세요.

A.
1. List: 저장공간이 필요에 의해 자동으로 늘어난다(순서가 있는 저장공간)
- 특징: 순서가 있고, 중복을 허용(배열과 유사)
- 장점: 가변적인 배열(배열이 자동으로 늘어남)
- 단점: 원하는 데이터가 뒤쪽에 위치하는 경우 속도가 느림
- 방식: equals()를 이용한 데이터 검색

2. Set: 집합. 순서가 없다. 집합이므로 중복된 데이터가 들어갈 수 없다. 중복되지 않는 숫자(데이터)를 구할 때 사용하면 유용하다.
- 특징: 순서가 없고, 중복을 허용하지 않는다.
- 장점: 빠른 속도
- 단점: 단순 집합의 개념으로 정렬하려면 별도의 처리가 필요하다.

3. Map: 키와 데이터를 같이 저장
- 특징: Key(키)와 Value(값)으로 나눠서 데이터 관리. 순서는 없으며, 키에 대한 중복은 없음
- 장점: 빠른 속도
- 단점: Key의 검색 속도에 의해 속도가 좌우

https://milkoon1.tistory.com/44

22.10.09
## Q. 기아상태를 설명하는 식사하는 철학자 문제에 대해 설명해주세요.(운영체제)

A. 식사하는 철학자들 문제는 전산학에서 동시성과 교착 상태를 설명하는 예시로, 여러 프로세스가 동시에 돌아갈 때 교착 상태가 나타나는 원인을 직관적으로 알 수 있다.  
다섯 명의 철학자가 원탁에 앉아 있고, 각자의 앞에는 스파게티가 있고 양옆에 젓가락이 한 짝씩 있다. 그리고 각각의 철학자는 다른 철학자에게 말을 할 수 없다. 이때 철학자가 스파게티를 먹기 위해서는 양 옆의 젓가락 짝을 동시에 들고 있어야 한다. 이때 각각의 철학자가 왼쪽의 젓가락 짝을 들고 그 다음 오른쪽의 젓가락 짝을 들어서 스파게티를 먹는 알고리즘을 가지고 있으면, 다섯 철학자가 동시에 왼쪽의 젓가락 짝을 든 다음 오른쪽의 젓가락 짝을 들 때까지 무한정 기다리는 교착 상태에 빠지게 될 수 있다.  
또한 어떤 경우에는 동시에 젓가락 양짝을 집을 수 없어 식사를 하지 못하는 기아 상태가 발생할 수도 있고, 몇몇 철학자가 다른 철학자보다 식사를 적게 하는 경우가 발생하기도 한다.

https://starbirds.tistory.com/68

22.10.10
## Q. 삽입 정렬(Insertion Sort)의 구현 방식, 시간복잡도, 공간복잡도, 장단점에 대해 설명해주세요.

A.  
- 구현 방식  
1. 정렬은 2번째 위치(index)의 값을 temp에 저장한다.
2. temp와 이전에 있는 원소들과 비교하여 삽입해나간다.
3. '1'번으로 돌아가 다음 위치(index)의 값을 temp에 저장하고, 반복한다.
- 시간복잡도: 최선의 경우 O(n), 평균과 최악의 경우 O( $n^2$ )
- 공간복잡도: O(n)
- 장점:
  - 알고리즘이 단순하다.
  - 대부분의 원소가 이미 정렬되어 있는 경우, 매우 효율적일 수 있다.
  - 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않는다. → 제자리 정렬(in-place sorting)
  - 안정 정렬(Stable Sort)이다.
  - Selection Sort나 Bubble Sort과 같은 O( $n^2$ ) 알고리즘에 비교하여 상대적으로 빠르다.
- 단점:
  - 평균과 최악의 시간복잡도가 O( $n^2$ )으로 비효율적이다.
  - Bubble Sort와 Selection Sort와 마찬가지로, 배열의 길이가 길어질수록 비효율적이다.  

https://gyoogle.dev/blog/algorithm/Insertion%20Sort.html

22.10.11
## Q. 단일 연결리스트와 원형 연결리스트를 구별하는 방법에 대해 설명해주세요.

A.  
- 단순 연결 리스트와 다르게 원형 연결 리스트는 꼬리가 머리를 가리키는 구조
- 단순 연결 리스트에서 꼬리가 머리를 가리키게만 하면 됨
  - 단순 연결 리스트의 마지막 노드는 NULL을 가리킴
  - 원형 연결 리스트의 마지막 노드는 첫 번째 노드를 가리킴

https://seongkyun.github.io/data_structure/2019/03/20/data_structure/

22.10.12
## Q. IPC(Inter-Process Communication)가 무엇인가요?

A. 프로세스들 사이의 통신 기법으로서 크게 공유 기억 장치 기법과 메시지 시스템 기법이 있다. 공유 기억 장치 기법은 통신하는 프로세스들 사이에 어떤 변수를 공유하고 이 공유 변수를 이용해서 정보를 교환하도록 한다. 메시지 시스템 방법은 통신을 제공하는 책임을 운영 체제가 가지고 프로세스가 메시지를 교환할 수 있게 한다.  

[네이버 지식백과] 프로세서 간 통신(interprocessor communication)

https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/IPC(Inter%20Process%20Communication).md

22.10.13
## Q. 합병 정렬(Merge Sort)의 구현 방식, 시간복잡도, 공간복잡도, 장단점에 대해 설명해주세요.(알고리즘)

A. 병합 정렬이라고도 부르며, 분할 정복 방법을 통해 구현. 빠른 정렬로 분류되며, 퀵소트와 함께 많이 언급되는 정렬 방식이다.  
구현 방식:
1. 리스트를 반으로 나눈다
2. 왼쪽 리스트와 오른쪽 리스트를 각각 정렬한다
3. 정렬된 두 리스트를 하나의 정렬된 리스트로 합병한다.  

시간복잡도: 평균 Θ(nlogn), 최악 O(nlogn)  
공간복잡도: O(n)  
장점: 길이가 긴 리스트에서 다른 정렬 방식보다 빠르게 동작한다.  
단점: 이미 정렬이 되어있어도 전체 과정을 진행해야 한다.

https://gyoogle.dev/blog/algorithm/Merge%20Sort.html

22.10.14
## Q. 큐에 비해 원형큐가 가지는 장단점을 설명해주세요.(자료구조)

A. 장점: 데이터를 출력한 영역을 재사용할 수 없다는 선형큐의 단점을 해결할 수 있다.  
단점: 큐의 길이만큼의 원소를 저장할 수 있기 때문에, 원형큐의 사이즈를 미리 알고 있어야 한다.

https://reakwon.tistory.com/30

22.10.15
## Q. 삽입 정렬(Insertion Sort)의 구현 방식, 시간복잡도, 공간복잡도, 장단점에 대해 설명해주세요.(알고리즘)

A.  
구현 방식: 2번째 원소부터 시작하여 그 앞(왼쪽)의 원소들과 비교하여 삽입할 위치를 지정한 후, 원소를 뒤로 옮기고 지정된 자리에 자료를 삽입하여 정렬하는 알고리즘.
1. 정렬은 2번째 위치(index)의 값을 temp에 저장한다.
2. temp와 이전에 있는 원소들과 비교하며 삽입해나간다.
3. '1'번으로 돌아가 다음 위치(index)의 값을 temp에 저장하고, 반복한다.

시간복잡도: O( $n^2$ )

공간복잡도: O(n)

장점:
- 알고리즘이 단순하다.
- 대부분의 원소가 이미 정렬되어 있는 경우, 매우 효율적일 수 있다.
- 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않는다. -> 제자리 정렬(in-place sorting)
- 안정 정렬(stable sort)이다.
- Selection Sort나 Bubble Sort과 같은 O( $n^2$ ) 알고리즘에 비교하여 상대적으로 빠르다.

단점:
- 평균과 최악의 시간복잡도가 O( $n^2$ )으로 비효율적이다.
- Bubble Sort와 Selection Sort와 마찬가지로, 배열의 길이가 길어질수록 비효율적이다.

https://gyoogle.dev/blog/algorithm/Insertion%20Sort.html

22.10.17
## Q. 최소 스패닝 트리(Minimum Spanning Tree)의 개념과 특징, 사용 사례에 대해 설명해주세요.(알고리즘)

A. 한 그래프의 스패닝 트리들 중에서 가중값의 합이 가장 작은 것.  
모든 꼭지점을 연결하면서 사이클이 생기지 않는 모든 가능한 스패닝 트리 중에서 간선의 가중치 합이 최소가 된다.  
통신 회사에서 케이블을 매설하려고 할 때, 집을 꼭짓점으로, 케이블을 간선으로, 케이블 매설 비용을 가중치로 하는 그래프를 생각하면, 최소 스패닝 트리가 통신 회사 입장에서 가장 경제적인 방법이 된다.

[네이버 지식백과] 최소 스패닝 트리  
[Wikipedia] Minimun spanning tree

22.10.18
## Q. Race Condition이란 무엇인가요?(운영체제)

A. 두 개 이상의 프로세스가 공통 자원을 병행적으로(concurrently) 읽거나 쓸 때, 공용 데이터에 대한 접근이 어떤 순서에 이루어졌는지에 따라 그 실행 결과가 달라지는 상황.

https://drehzr.tistory.com/m/87

22.10.19
## Q. 힙 정렬(Heap Sort)의 구현 방식, 시간복잡도, 공간복잡도, 장단점에 대해 설명해주세요.(알고리즘)

A. 구현 방식:  
1. 완전이진 트리로 정렬할 원소들을 최대 힙 트리로 구성한다.
2. 원소 하나씩 추출(삭제)하여 배열의 뒤부터 저장한다.
3. 최댓값부터 삭제되며, 삭제되는 순서로 정렬된다.

시간복잡도: O(nlogn)

공간복잡도: O(nlogn)

장점: 항상 O(nlogn)이라는 시간 복잡도를 가져 효율적이다.

단점: 불안정 정렬이다. 이상적일 경우에 퀵정렬보다 느리다. 데이터 상태에 따라 다른 정렬에 비해 느린 편이다.

[네이버 지식백과] 힙 정렬

https://velog.io/@jaeyunn_15/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B0%81-%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B9%84%EA%B5%90

https://gyoogle.dev/blog/algorithm/Heap%20Sort.html

22.10.20
## Q. 모바일 기기용 주소록에 BST와 HashTable 중 어떤 자료구조를 사용하는 것이 좋은가요? 이유와 함께 설명해주세요.(자료구조)

A. 모바일 기기용 주소록을 위해서는 이진 탐색 트리(Binary Search Tree, BST)를 사용하는 것이 해시 테이블(Hash Table)을 사용하는 것보다 좋다. 해시 테이블은 서로 다른 두 개의 키값이 해시 함수에 의해 같은 해시값으로 변환되는 해시 충돌이 일어날 수 있다. 이진 탐색 트리는 범위 기반 쿼리가 가능하다. 또한 메모리 효율 측면에서도 이진 탐색 트리가 더 유리하다.

https://algorfati.tistory.com/123

https://adevspoon.com/?code=CraoR_VdQ88QEcGkHil4mvWlchcI-MEvvCJHnyFcBLjvVPro7wvnxFb3iVtr3XPQrmViMAo9dJkAAAGD9Zmmqw

22.10.21
## Q. 내부 단편화와 외부 단편화의 차이점에 대해 설명해주세요.

A.  
내부 단편화: 기억 장치가 의도된 바 없이 할당될 때 일어난다. 공간이 낭비된다. "내부"라는 용어는 필요 없는 기억 자료가 할당된 영역 안에 있지만 쓰이지 않는 것을 말한다. 운영체제의 메모리 관리기법 중 페이징을 이용할 때 발생할 수 있다. 일정 크기의 페이지에 프로세스 할당시, 프로세스의 크기가 페이지보다 작을 경우 내부 단편화가 발생한다.  
외부 단편화: 여유 공간이 여러 조각으로 나뉘는 현상을 말한다. 프로그램이 다양한 크기의 기억 장소의 남은 영역을 할당하고 할당을 해제할 때 일어나며, 할당 알고리즘이 약화된다. 비록 남은 기억 공간을 사용할 수 있지만, 조각이 너무 작게 나 있어서 응용 프로그램의 성능을 뒷받쳐 주지 못하기 때문에 효과적으로 사용하지 못하게 된다. "외부"라는 용어는 사용할 수 없는 기억 장소가 할당된 영역 밖에 있다는 것을 뜻한다.

[위키백과] 단편화  

https://m.blog.naver.com/rbdi3222/220623825770

22.10.22
## Q. 크루스칼 알고리즘(Kruskal's Algorithm)에 대해 설명해주세요.(알고리즘)

A. 그래프 내의 모든 정점들을 가장 적은 비용으로 연결하기 위해 사용되는 최소 신장 트리 알고리즘. 그래프 간선들을 가중치의 오름차순으로 정렬해 놓은 뒤, 사이클을 형성하지 않는 선에서 정렬된 순서대로 간선을 선택한다.

https://chanhuiseok.github.io/posts/algo-33/

22.10.23
## Q. Red-Black Tree에 대해 설명해주세요.(자료구조)

A. 레드-블랙 트리(Red-Black Tree)는 이진 트리의 특수한 형태로서, 컴퓨터 공학 분야에서 숫자 등의 비교 가능한 자료를 정리하는 데 쓰이는 자료구조이다. 레드-블랙 트리에서는 리프 노드들은 비어있고, 자료를 가지고 있지 않다. 레드-블랙 트리는 각각의 노드가 레드나 블랙인 색상 속성을 가지고 있다. 이진 탐색 트리가 가지고 있는 일반적인 조건에 다음과 같은 추가적인 조건을 만족하면 레드-블랙 트리가 된다.

1. 노드는 레드 혹은 블랙 중의 하나이다.
2. 루프 노드는 블랙이다.
3. 모든 리프 노드들(NIL)은 블랙이다.
4. 레드 노드의 자식노드 양쪽은 언제나 블랙이다. (즉, 레드 노드는 연달아 나타날 수 없으며, 블랙 노드만이 레드 노드의 부모 노드가 될 수 있다.)
5. 어떤 노드로부터 시작되어 그에 속한 하위 리프 노드에 도달하는 모든 경로에는 리프 노드를 제외하면 모두 같은 개수의 블랙 노드가 있다.

위 조건들을 만족하게 되면, 레드-블랙 트리는 가장 중요한 특성을 나타내게 된다: 루트 노드부터 가장 먼 잎노드 경로까지의 거리가, 가장 가까운 잎노드 경로까지의 거리의 두 배보다 항상 작다. 다시 말해서 레드-블랙 트리는 개략적으로 균형이 잡혀 있다. 따라서 삽입, 삭제, 검색 시 최악의 경우에서의 시간복잡도가 트리의 높이에 따라 결정되기 때문에 보통의 이진 탐색 트리에 비해 효율적이라고 할 수 있다.

[위키백과] 레드-블랙 트리

https://blogshine.tistory.com/102

22.10.24
## Q. RDBMS와 Nospl의 차이점을 설명해주세요.(데이터베이스)

A.  
관계형 데이터베이스(RDBMS)는 정해진 스키마에 따라 데이터를 저장해야 하므로 명확한 데이터 구조를 보장한다는 장점이 있는 반면, 테이블 간 관계를 맺고 있어 시스템이 커질 경우 JOIN문이 많은 복잡한 쿼리가 만들어질 수 있고, 성능 향상을 위해서는 서버의 성능을 향상시키는 Scale-up만을 지원하기에 비용이 기하급수적으로 늘어날 수 있으며, 스키마로 인해 데이터가 유연하지 못하고 스키마가 변경될 경우 번거롭고 어렵다는 단점이 있다.  
Nosql(Not Only SQL)은 스키마가 없기 때문에 유연하고 자유로운 데이터 구조를 가질 수 있으므로 언제든 저장된 데이터를 조정하고 새로운 필드를 추가할 수 있으며, 데이터 분산이 용이하며 성능 향상을 위한 Scale-up 뿐만이 아닌 Scale-out 또한 가능하다는 장점이 있는 반면, 데이터 중복이 발생할 수 있으며 중복된 데이터가 변경될 경우 수정을 모든 컬렉션에서 수행해야 하고, 스키마가 존재하지 않기에 명확한 데이터 구조를 보장하지 않으며 데이터 구조 결정이 어려울 수 있다는 단점이 있다.

https://khj93.tistory.com/entry/Database-RDBMS%EC%99%80-NOSQL-%EC%B0%A8%EC%9D%B4%EC%A0%90#:~:text=NoSQL%EC%9D%B4%EB%9E%80(Not%20Only%20SQL,%EA%B4%80%EA%B3%84%EB%A5%BC%20%EC%A0%95%EC%9D%98%ED%95%98%EC%A7%80%20%EC%95%8A%EC%8A%B5%EB%8B%88%EB%8B%A4.

22.10.25
## Q. 선택 정렬(Selection Sort)의 구현 방식, 시간복잡도, 공간복잡도, 장단점에 대해 설명해주세요.(알고리즘)

A.  
구현 방식:
1. 주어진 배열 중에 최솟값을 찾는다.
2. 그 값을 맨 앞에 위치한 값과 교체한다.
3. 맨 처음 위치를 뺀 나머지 배열을 같은 방법으로 교체한다.

시간복잡도: O( $n^2$ )

공간복잡도: O(n)

장점: 알고리즘이 단순하다, 많은 교환이 일어나야 하는 자료상태에서 비교적 효율적이다, 다른 메모리 공간을 필요로 하지 않는다.

단점: 시간복잡도 측면에서 비효율적이다, 불안정 정렬이다.

https://gyoogle.dev/blog/algorithm/Selection%20Sort.html

22.10.26
## Q. 기아상태와 교착상태의 차이점에 대해 설명해주세요.(운영체제)

A. 교착 상태는 프로세스가 실행을 위해 진행되지 않고 각 프로세스가 다른 프로세스에 의해 획득된 리소스를 기다리는 조건인 반면 기아 상태에서는 우선순위가 높은 프로세스가 우선순위가 낮은 프로세스를 방지하는 리소스를 지속적으로 사용하여 리소스를 확보한다.

https://ko.gadget-info.com/difference-between-deadlock

22.10.27
## Q. 연관 컨테이너의 종류와 각각의 특징에 대해 설명해주세요.(자료구조)

A.  
**연관 컨테이너**(associate container)는 키(key)와 값(value)처럼 관련있는 데이터를 하나의 쌍으로 저장하는 컨테이너이다. 키와 값을 이용한 연관 컨테이너는 요소들에 대한 빠른 접근을 제공해준다. 하지만 연관 컨테이너는 삽입되는 요소의 위치를 지정할 수는 없다. 이러한 연관 컨테이너는 보통 균형 잡힌 이진 탐색 트리(balanced binary search tree)나 해시 테이블(hash table)을 이용하여 구현한다.  

종류:
1. set: 집합(set) 컨테이너는 저장하는 데이터 그 자체를 키로 사용하는 가장 단순한 연관 컨테이너이다. 검색 속도가 매우 빠르다. 키의 중복을 허용하지 않는다.
2. multiset: 키의 중복을 허용하므로, 같은 값을 여러 번 저장할 수 있다.
3. map: 맵(map) 컨테이너는 키와 값의 쌍으로 데이터를 관리하는 진정한 연관 컨테이너이다. 검색 속도가 매우 빠르다. 키의 중복을 허용하지 않는다.
4. multimap: 값의 중복을 허용하므로, 하나의 키가 여러 개의 값과 연관될 수 있다.

http://www.tcpschool.com/cpp/cpp_container_associate
