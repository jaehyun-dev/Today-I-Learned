# 2 힙

23.01.18  

## 01. 힙이란?  

### 힙
두 개의 조건을 만족하는 트리  
1. 형태 속성: 힙은 완전 이진 트리이다(높이: $O(lg(n))$  
2. 힙 속성: 모든 노드의 데이터는 자식 노드들의 데이터보다 크거나 같다  

힙을 활용하는 두 가지 방법  
1. 정렬 문제 해결  
2. 우선순위 큐 구현

<br/><br/>

## 02. 정렬 문제  

### 정렬
- 여러 개의 데이터 요소들을 특정 순서로 배치하는 것  
- 예시)
```python
[4, 1, 6, 2, 8, 5]

[1, 2, 4, 5, 6, 8]  # 오름차순 정렬

[8, 6, 5, 4, 2, 1]  # 내림차순 정렬
```

### 정렬 알고리즘: 데이터를 재배치하는 구체적인 방법  
- 삽입 정렬
- 선택 정렬
- 퀵 정렬
- 합병 정렬
등

### 힙 정렬  
힙을 사용한 정렬 알고리즘  

<br/><br/>

## 03. 배열로 구현한 힙  

### 힙 구현하기

완전 이진 트리는 동적 배열, 파이썬에서는 리스트를 이용해 나타낼 수 있음  
힙도 완전 이진 트리이기 때문에 동적 배열로 나타냄  
![image](https://user-images.githubusercontent.com/71001479/213174986-07cfcb37-cdf3-4482-b383-26e77817ea88.png)

왼쪽 자식 인덱스: 인덱스 * 2  
오른쪽 자식 인덱스: 인덱스 * 2 + 1  

<br/><br/>

## 04. 힙 만들기 I  

![image](https://user-images.githubusercontent.com/71001479/213175569-e65f6921-16f2-4ce9-b738-bd6dc293dce4.png)

이 트리가 힙 속성을 지키려면 어떻게 해야 할까?  

1. 노드2의 데이터 5와 자식 노드들의 데이터 14, 9를 비교한다  
2. 왼쪽 자식의 데이터 14가 제일 크니 5와 바꿔준다
3. 부모 노드의 데이터가 14가 됐고, 자식 노드들은 부모 노드보다 작아졌다  
4. 그 다음으로 위치를 바꿔준 5가 힙 속성을 지키고 있는지 확인한다  
5. 5와 자식 노드들을 비교해서 가장 큰 11을 5와 바꿔준다  
6. 이렇게 힙 속성을 지키지 않는 노드가 있을 때마다 그 노드가 맞는 위치를 찾을 때까지 재배치한다  

이런 방법을 **heapify**라고 함  
일반화해서, heapify는 파라미터로 노드 하나를 받음  
부모 노드, 왼쪽 자식, 오른쪽 자식 중에 가장 큰 것을 고름  
가장 큰 노드가 부모 노드가 아니라면 가장 큰 노드를 부모 노드와 바꿔줌  
부모 노드가 가장 크면 아무것도 안 해도 됨  
기존의 부모 노드가 밑으로 갔는데, 그 노드가 또 힙 속성을 어길 수 있음  
힙 속성이 충족될 때까지 반복함  

#### 시간 복잡도
최악의 경우: 루트 노드가 가장 작아서, 계속 밑으로 내려가서 leaf 노드까지 내려가는 경우  
이 경우 노드는 트리의 높이만큼 데이터를 비교하고 재배치한다  
힙은 완전 이진 트리이기 때문에 높이가 $O(lg(n))$이기 때문에 최악의 경우 시간 복잡도도 마찬가지로 $O(lg(n))$  

<br/><br/>

## 05. heapify 함수 구현

### 실습 설명
이번 과제에서는 heapify() 함수를 직접 구현해 볼게요. 혹시 heapify() 함수가 무슨 작업을 하는지 정확히 이해가 안 되신 분은 이전 영상을 다시 보고 오세요.

heapify() 함수는 아래 세 가지 파라미터를 받습니다.
- 완전 이진 트리를 나타내는 리스트, tree
- heapify 하려는 노드의 인덱스, index
- 트리로 사용하는 리스트의 길이, tree_size (배열의 0번째 인덱스는 None으로 설정했기 때문에 실제로 총 노드 수보다 1이 큽니다.)

그리고 파라미터로 받은 tree의 index번째 노드가, 힙 속성을 유지하도록 트리 안의 노드들을 재배치합니다. (앞으로 “index" 번째 노드는 그냥 줄여서 “노드 index"라고 하겠습니다.)

heapify() 함수가 이런 기능을 하려면 아래와 같은 상세 작업을 순서대로 해야 합니다.

1. 부모 노드(heapify하려는 현재 노드), 왼쪽 자식 노드, 오른쪽 자식 노드, 이 3가지 노드 중에서 가장 큰 값을 가진 노드가 무엇인지 파악합니다.
2. (1)가장 큰 값을 가진 노드가 부모 노드라면 그 상태 그대로 둡니다. (2)가장 큰 값을 가진 노드가 자식 노드 중에 있다면 그 자식 노드와 부모 노드의 위치를 바꿔 줍니다.
3. 기존의 부모 노드가 자식 노드로 내려갔을 때, 다시 힙 속성을 어길 수도 있습니다. 힙 속성이 충족될 때까지 1~2 단계를 반복합니다.

이때 단계 2-(2)를 보면 heapify() 함수 내에는 두 노드의 위치를 바꿀 수 있는 기능이 필요하다는 걸 알 수 있습니다. 이런 기능을 하는 swap() 이라는 함수를 미리 작성해 뒀는데요. swap() 함수는 아래 두 가지 파라미터를 받습니다.
- 리스트로 구현한 완전 이진 트리, tree
- 두 인덱스, index_1과 index_2

그리고 트리 내에서 두 인덱스에 해당하는 두 노드의 위치를 바꿔주죠. heapify() 함수의 내부 코드를 작성할 때 swap() 함수를 사용해 보세요.

### 실습 결과
```
[None, 15, 14, 12, 11, 9, 10, 6, 2, 5, 1]
```

<br/><br/>

### 해설
먼저 heapify()의 첫 번째 단계를 어떻게 할 수 있을지 생각해 봅시다.

1. 부모 노드(heapify하려는 현재 노드), 왼쪽 자식 노드, 오른쪽 자식 노드, 이 3가지 노드 중에서 가장 큰 값을 가진 노드가 무엇인지 파악합니다.

```python
largest = index  # 일단 부모 노드의 값이 가장 크다고 설정

# 왼쪽 자식 노드의 값과 비교
if 0 < left_child_index < tree_size and tree[largest] < tree[left_child_index]:
    largest = left_child_index
```

largest 변수에는 3가지 노드 중 가장 큰 값을 가진 노드의 인덱스를 저장할 건데요. 일단은 부모 노드의 데이터가 가장 크다고 설정합니다.

그래서 처음에 largest 변수에는 부모 노드의 인덱스가 저장돼 있습니다.

그 다음 부모 노드의 값을 왼쪽 자식 노드의 값과 비교합니다. 여기서 아래 내용들을 확인합니다.

1. 먼저 왼쪽 자식 노드가 있는지, 없는지부터 확인한다.(왼쪽 자식 노드의 인덱스가 유효한 범위 내에 있는지 확인) 0 < left_child_index < tree_size
2. 왼쪽 자식 노드의 값이 부모 노드의 값보다 큰지 확인한다. tree[largest] < tree[left_child_index]
3. 왼쪽 자식 노드의 값이 더 큰 경우에는 largest 변수에 왼쪽 자식 노드의 인덱스를 저장한다.

그 다음, 같은 방식으로 largest의 값과 오른쪽 자식 노드의 값을 비교합니다.
```python
# 오른쪽 자식 노드의 값과 비교
if 0 < right_child_index < tree_size and tree[largest] < tree[right_child_index]:
    largest = right_child_index
```

이 과정을 거치고 나면 이제 largest 변수에는 아래 세 가지 노드 중 최댓값을 가진 노드의 인덱스를 갖게 됩니다.
- 부모 노드(heapify하려는 현재 노드)
- 왼쪽 자식 노드
- 오른쪽 자식 노드

이때 최댓값을 가진 노드가 부모 노드라면 아무런 작업을 하지 않아도 됩니다. 이미 힙 속성을 만족하고 있으니까요. 하지만 최댓값을 가진 노드가 왼쪽 자식 노드이거나 오른쪽 자식 노드라면 아래 코드를 수행해야 합니다.
```python
if largest != index: # 부모 노드의 값이 자식 노드의 값보다 작으면
    swap(tree, index, largest)  # 부모 노드와 최댓값을 가진 자식 노드의 위치를 바꿔준다
    heapify(tree, largest, tree_size)  # 자리가 바뀌어 자식 노드가 된 기존의 부모 노드를 대상으로 또 heapify 함수를 호출한다
```
위의 코드를 해석하면 다음과 같습니다.
  (1) 부모 노드와 최댓값을 가진 노드의 위치를 바꿔 준다.
  (2) 자리가 바뀌어 자식 노드가 된 기존의 부모 노드를 대상으로 또 heapify() 함수를 호출한다.

즉, heapify() 함수는 재귀 함수인 겁니다. 이렇게 하면 heapify하려고 했던 최초의 부모 노드는 힙 속성을 만족할 때까지 그 위치가 변경되어 갈 겁니다.

### 모범 답안
코드를 정리하면 이렇게 되겠죠?
```python
def heapify(tree, index, tree_size):
    """heapify 함수"""

    # 왼쪽 자식 노드의 인덱스와 오른쪽 자식 노드의 인덱스를 계산
    left_child_index = 2 * index
    right_child_index = 2 * index + 1

    largest = index  # 일단 부모 노드의 값이 가장 크다고 설정

    # 왼쪽 자식 노드의 값과 비교
    if 0 < left_child_index < tree_size and tree[largest] < tree[left_child_index]:
        largest = left_child_index

    # 오른쪽 자식 노드의 값과 비교
    if 0 < right_child_index < tree_size and tree[largest] < tree[right_child_index]:
        largest = right_child_index
    
    if largest != index: # 부모 노드의 값이 자식 노드의 값보다 작으면
        swap(tree, index, largest)  # 부모 노드와 최댓값을 가진 자식 노드의 위치를 바꿔준다
        heapify(tree, largest, tree_size)  # 자리가 바뀌어 자식 노드가 된 기존의 부모 노드를대상으로 또 heapify 함수를 호출한다
```

### 테스트 코드
코드가 제대로 작동하는지 확인해 봅시다.
```python
tree = [None, 15, 5, 12, 14, 9, 10, 6, 2, 11, 1]  # heapify하려고 하는 완전 이진 트리
heapify(tree, 2, len(tree))  # 노드 2에 heapify 호출
print(tree)
```

### 실습 결과
```
[None, 15, 14, 12, 11, 9, 10, 6, 2, 5, 1]
```

완전 이진 트리의 노드 2(값이 5인 노드)의 위치가 힙 속성을 만족하는 곳으로 잘 바뀝니다.

[main2_05.py](https://github.com/jaehyun-dev/Today-I-Learned/blob/1bdd680ae6e7db6016292be940f99f80a65dfbac/Data%20Structure/2%20Tree/2%20Heap/main2_05.py) 참고

<br/><br/>

23.01.20

## 06. 힙 만들기 II

### heapify
heapify 함수에 어떤 노드를 넣어주면 어떻게 될까?  
파라미터로 넘기는 노드가 힙 속성을 지킬 수 있도록 힙에서 위치를 찾아간다  
(leaf 노드는 heapify 해도 자식 노드가 없기 때문에 위치가 바뀌지 않음)  

마지막 노드부터 루트 노드까지 heapify를 차례로 적용하면, 위쪽 노드를 heapify할 때 그 노드를 루트 노드로 하는 부분 트리는 힙 속성 이미 지키고있음(heapify 이미 했기 때문)  

완전 이진 트리가 파이썬 리스트로 구현되어 있을 때, 마지막 인덱스부터 첫 인덱스까지 차례로 heapify를 호출하면, heap으로 만들 수 있음.  

heapify의 시간 복잡도는 $O(lg(n))$, 트리의 노드 개수 $(n)$만큼 반복, 따라서

### 힙을 만드는 데 걸리는 시간: $O(nlg(n))$  

<br/><br/>

## 07. 힙 정렬

### 힙 정렬
- 힙을 이용한 정렬 알고리즘!  
- 힙을 만든다
- root와 마지막 노드를 바꿔준다
- (바꾼 노드는 없는 노드 취급한다)
- 새로운 노드가 힙 속성을 지킬 수 있게 heapify 호출
- 모든 인덱스를 돌 때까지 반복
- Q. 내림 차순으로 정렬하고 싶으면?
- A. 힙 속성을 반대로 바꾸고 똑같은 알고리즘을 적용하면 된다!

<br/><br/>

## 08. 힙 정렬 구현하기

### 실습 설명
이번 과제에서는 영상에서 본 힙 정렬을 직접 구현해 볼게요.

어떤 리스트 하나가 있다고 합시다. 이때 그 리스트를 힙 정렬하려면 아래 과정들을 거치면 됩니다.
1. 먼저 리스트를 힙으로 만듭니다.
2. root 노드와 마지막 노드의 위치를 바꿉니다. 마지막 위치로 간 기존의 root 노드는 이제 힙에서 없다고 가정합니다.
3. 새로운 root 노드가 힙 속성을 지킬 수 있게 heapify합니다.
4. 힙에 남아있는 노드가 없도록 단계 2 ~ 3을 반복합니다.

힙 정렬을 하기위해 heapsort()라는 함수를 구현해 볼게요. heapsort() 함수는 정렬할 리스트를 tree라는 파라미터로 받아서 힙 정렬합니다. 이때 저번 과제에서 완성한 heapify() 함수를 사용할게요.

### 실습 결과
```
[None, 1, 1, 1, 2, 3, 4, 4, 5, 5, 6, 7, 7, 8, 10]
```

<br/><br/>

### 해설

#### 힙 만들기

힙 정렬을 하려면 파라미터로 받은 리스트, tree를 먼저 힙으로 만들어야 합니다.  
힙을 만드는 방법, 생각나시나요? 가장 마지막 위치의 노드부터 root 노드까지 역순으로 heapify해 주면 됩니다. (왜 그래야 하는지 기억이 안 나시면 이전 영상 힙 만들기 II 를 다시 보고 오세요)  

이것을 코드로 작성하면 아래와 같습니다.
```python
# 마지막 노드부터 root 노드까지 heapify를 해준다 
for index in range(tree_size-1, 0, -1):
    heapify(tree, index, tree_size)
```
이 코드가 실행되고 나면 리스트 tree는 힙이 됩니다.

#### 힙 정렬
그 다음에는 힙 정렬을 위한 아래의 나머지 단계들을 수행하면 됩니다.
1. root 노드와 마지막 노드의 위치를 바꿉니다. 마지막 위치로 간 기존의 root 노드는 이제 힙에서 없다고 가정합니다.
2. 새로운 root 노드가 힙 속성을 지킬 수 있게 heapify합니다.
3. 힙에 남아있는 노드가 없도록 단계 2 ~ 3을 반복합니다.  

먼저 2 단계는 아래와 같이 코드를 쓰면 됩니다.
```python
for i in range(tree_size-1, 0, -1):
    swap(tree, 1, i)  # root 노드와 마지막 인덱스를 바꿔준 후
    # 여기에 코드를 작성하세요
```
root 노드와 가장 마지막 노드의 위치를 계속 swap() 함수로 바꿔줍니다. 마지막 위치로 간 root 노드는 힙에서 없는 것으로 간주됩니다. 따라서 마지막 노드의 인덱스는 매번 1씩 줄어들게 됩니다.

root 노드와 가장 마지막 노드의 위치를 한번 바꾸고 난 후에는 남은 리스트가 다시 힙이 되도록 새로운 root 노드를 heapify해야 합니다. 이때 이미 맨 뒤에 있는 노드를 하나씩 무시하고, 나머지만 가지고 heapify를 하려면 어떻게 해야 할까요?

heapify() 함수의 파라미터 tree_size의 역할에 대해서 잘 생각해 보세요.
```python
def heapify(tree, index, tree_size):
```
tree_size는 현재 트리에 들어있는 노드의 수를 나타냅니다. heapify() 함수의 내용 일부를 다시 잠깐 볼까요?
```python
# 왼쪽 자식 노드의 값과 비교
if 0 < left_child_index < tree_size and tree[largest] < tree[left_child_index]:
    largest = left_child_index

# 오른쪽 자식 노드의 값과 비교
if 0 < right_child_index < tree_size and tree[largest] < tree[right_child_index]:
    largest = right_child_index
```
tree_size는 해당 인덱스가 유효한지, 그러니까 해당 인덱스에 노드가 존재하는지를 판단하는 기준으로 사용됩니다. 즉, 리스트에 아무리 많은 노드들이 있다고 해도 결국 heapify의 대상은 tree_size 값을 통해 결정됩니다. 이 사실을 잘 활용하면 될 것 같은데, 어떻게 하면 좋을까요?

매번 heapify()를 호출할 때, 파라미터 tree_size도 1씩 줄여가면 됩니다. 그럼 힙 맨 뒤 노드들을 하나씩 무시해가면서 heapify를 할 수 있습니다.

정리하면 아래 코드처럼 heapify() 함수를 호출하면 됩니다.
```python
# 마지막 인덱스부터 처음 인덱스까지
for i in range(tree_size-1, 0, -1):
    swap(tree, 1, i)  # root 노드와 마지막 인덱스를 바꿔준 후
    heapify(tree, 1, i)  # root 노드에 heapify를 호출한다
```
현재 i는 tree_size - 1부터 시작해서 계속 1씩 감소하는데요. 이 i를 heapify() 함수의 파라미터 tree_size로 넘겨주면 heapify() 함수가 인식하는 리스트의 크기가 매번 줄어듭니다. 즉, tree라는 전체 리스트의 사이즈는 그대로지만 실제로 heapify의 대상이 되는 리스트의 크기는 하나씩 줄어들게 되는 겁니다. 이렇게 하면 힙 맨 뒤 노드들은 하나씩 무시하고, 점점 더 작게 인식되는 리스트에서, 매번 새로운 root 노드를 heapify할 수 있겠죠?

### 모범 답안
작성한 코드를 정리해 볼게요.
```python
def heapsort(tree):
    """힙 정렬 함수"""
    tree_size = len(tree)

    # 마지막 인덱스부터 처음 인덱스까지 heapify를 호출한다 
    for index in range(tree_size-1, 0, -1):
        heapify(tree, index, tree_size)

    # 마지막 인덱스부터 처음 인덱스까지
    for i in range(tree_size-1, 0, -1):
        swap(tree, 1, i)  # root 노드와 마지막 인덱스를 바꿔준 후
        heapify(tree, 1, i)  # root 노드에 heapify를 호출한다
```

### 테스트 코드
힙 정렬 코드를 제대로 작성했는지 봅시다.
```python
# 실행 코드
data_to_sort = [None, 6, 1, 4, 7, 10, 3, 8, 5, 1, 5, 7, 4, 2, 1]
heapsort(data_to_sort)
print(data_to_sort)
```

### 실습 결과
```
[None, 1, 1, 1, 2, 3, 4, 4, 5, 5, 6, 7, 7, 8, 10]
```
노드가 오름차순으로 정렬됩니다. 실제로 힙 정렬을 구현해보니 뿌듯하죠?

[main2_08.py](https://github.com/jaehyun-dev/Today-I-Learned/blob/0dea9764ca328b9bbc683dfe4f408202cc915d8c/Data%20Structure/2%20Tree/2%20Heap/main2_08.py) 참고
