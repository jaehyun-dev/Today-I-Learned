# 1 트리란?

23.01.16  

## 01. 계층적 관계  

### 트리
- 데이터의 상-하 관계를 저장하는 자료 구조

상하관계 = 계층적 관계  
예시) 회사 임직원 데이터, 컴퓨터 폴더 구조, 클래스 상속 관계 등  

계층적 데이터 저장하려면?  
배열, 링크드 리스트 등은 선형적 자료 구조  
해시 테이블도 데이터 관계를 저장하기에는 적합하지 않음  

이런 계층적 관계의 자료를 저장하는 트리 자료구조에 대해서 배워볼 것

<br/><br/>

## 02. 트리란?  

링크드 리스트는 여러 개의 데이터를 순서대로 저장하는 선형 자료구조  
노드라는 기본 단위에 데이터를 담음  
하나의 노드는 저장하려는 데이터와 다음 순서를 가르키는 레퍼런스를 가짐
각 노드가 다음 노드에 대한 레퍼런스를 갖기 때문에 여러 노드 사이에 앞과 뒤라는 순서를 저장할 수 있음  

트리 노드도 기본적으로 데이터를 저장하는 단위  
링크드 리스트는 다음 노드를 가리키는 레퍼런스를 갖고 있던 반면, 트리 노드는 하위 관계에 있는 노드를 가리키는 레퍼런스를 가짐  
특정 노드의 하위 노드를 자식 노드라고 부름  
A 노드가 B 노드와 C 노드를 하위 노드로 갖는다면, B와 C는 A의 자식 노드, A는 B와 C의 부모 노드  

링크드 리스트의 맨앞 노드를 head 노드라고 하고 특별히 관리함  
트리에서도 맨위 노드 뿌리 또는 root 노드라고 하여 특별히 관리함  
이 노드에서부터 레퍼런스 따라가면 모든 노드 찾을 수 있음  
나무의 뿌리처럼 트리의 가장 시작점이기 때문에 root라고 부름  

<br/><br/>

## 03. 트리 용어

트리에 대해서 더 깊이 배우기 전에 꼭 알아야하는 트리 관련 용어들을 배우고 갈게요. 앞으로 이 용어들을 다음 레슨들에서 자주 사용할 거니까 꼭 이해하고 외워두세요.

![image](https://bakey-api.codeit.kr/files/2369/TM643U?name=1.png)

- root 노드(뿌리 노드): 트리의 시작 노드, 뿌리가 되는 노드를 말합니다. 보통 트리를 표현할 때 위 그림처럼 가장 위에 root 노드를 놓는 방식으로 나타냅니다.
- 부모 노드: 특정 노드의 직속 상위 노드입니다. 노드 G, J, K가 있는 노란색 박스를 살펴보면 G가 J와 K의 부모 노드입니다.
- 자식 노드: 특정 노드의 직속 하위 노드입니다. 부모 노드와 반대되는 개념인데요. 노드 G, J, K가 있는 노란색 박스를 살펴보면 J와 K가 G의 자식 노드입니다.
- 형제 노드: 같은 부모를 갖는 노드입니다. D와 E는 둘다 그 부모가 B죠? 이럴 때 D와 E는 서로 형제 노드입니다.
- leaf 노드 (잎/말단 노드): 자식 노드를 갖고 있지 않은, 가장 말단에 있는 노드입니다. 트리의 끝에 있다고 해서 root(뿌리) 노드와 반대되는 표현으로 leaf(잎) 노드라고 부릅니다. 위 그림에서 노란색 박스로 둘러싼 F가 leaf 노드입니다. F뿐만 아니라 D, H, I, J, K 모두 leaf 노드입니다.
- 깊이: 특정 노드가 root 노드에서 떨어져 있는 거리입니다. 깊이는 해당 노드로 가기 위해서 root 노드에서 몇 번 아래로 내려와야 하는지를 나타냅니다. 예를 들어 위 그림에서 root 노드의 자식 노드인 B와 C는 깊이가 1입니다. D, E, F, G는 깊이가 2이고, H, I, J, K는 깊이가 3입니다. 결국 깊이라는 건 특정 노드가 root 노드로부터 얼마나 멀리 떨어져 있는지를 나타냅니다.
- 레벨: 깊이 + 1. 깊이랑 거의 똑같은 개념입니다. 그냥 깊이에 1을 더한 값이죠. 레벨 1에 있는 노드들, 레벨 2에 있는 노드들… 이런식으로 특정 깊이인 노드들을 묶어서 표현할 때 사용하는 용어입니다.
- 높이: 트리에서 가장 깊이 있는 노드의 깊이입니다. 위 그림의 트리에서는 H, I, J, K가 가장 깊이 있는 노드들이고 그 깊이는 모두 3입니다. 그래서 트리의 높이는 3입니다.

![image](https://bakey-api.codeit.kr/files/2369/AlHaCe?name=2.png)
- 부분 트리 (sub-tree): 현재 트리의 일부분을 이루고 있는 더 작은 트리를 말합니다. 위 그림의 트리는 root 노드가 A인 트리입니다. 그런데 이 트리를 좀더 작은 단위로 쪼개보면 더 작은 부분 트리들을 발견할 수 있습니다. 예를 들어 위 그림의 노란색 큰 박스 안을 보세요. 노란색 큰 박스 안에는 ‘C가 root 노드인 트리’가 있는데요. 이런 걸 바로 부분 트리라고 합니다. 지금 C가 A의 오른쪽 자식이죠? 그래서 노란색 큰 박스 안에 있는 부분 트리를 A의 “오른쪽 부분 트리”라고 합니다. 특정 노드를 root 노드라고 생각하고 바라본다면 여러 가지 부분 트리들을 발견할 수 있습니다. 하나의 전체 트리에 여러 부분 트리들이 존재하는 겁니다.

<br/><br/>

## 04. 트리의 활용  

트리의 장점은 계층적 관계가 있는 데이터를 자연스럽게 저장할 수 있다는 점  
트리는 폭넓게 사용됨
- 컴퓨터 과학의 다양한 문제들을 기발하게 해결!
    - 정렬 문제, 압축 문제 등
- 다양한 추상 자료형 구현!
    - 딕셔너리, 세트, 우선순위 큐 등  

### 트리의 활용  
- 계층적 관계가 있는 데이터를 컴퓨터에서 사용!
- 컴퓨터 과학의 다양한 문제 기발하게 해결!
- 흔히 사용하는 여러 추상 자료형 구현!

<br/><br/>

## 05. 이진 트리
- 각 노드가 최대 2개의 자식 노드를 가질 수 있는 트리
- 각 노드의 자식은 0~2개 있을 수 있음
- 최대 두 개의 자식이 있기 때문에, 왼쪽 자식 & 오른쪽 자식으로 부를 수 있음  
- 개념을 이해하기도 쉽고 구현도 간단하기 때문에 트리를 공부할 때 이진 트리를 쓰면 더 개념에 집중할 수 있음
- (항상 이진 트리만 쓰는 것은 아님!)

<br/><br/>

## 06. 이진 트리 구현
```python
class Node:
    """이진 트리 노드 클래스"""

    def __init__(self, data):
        """데이터와 두 자식 노드에 대한 레퍼런스를 갖는다"""
        self.data = data
        self.left_child = None
        self.right_child = None

"""노드 인스턴스 생성"""
root_node = Node(2)
node_B = Node(3)
node_C = Node(5)
node_D = Node(7)
node_E = Node(11)

"""B와 C를 root 노드의 자식으로 지정"""
root_node.left_child = node_B
root_node.right_child = node_C

"""D와 E를 B 노드의 자식으로 지정"""
node_B.left_child = node_D
node_B.right_child = node_E

# root 노드에서 왼쪽 자식 노드 받아오기
test_node_1 = root_node.left_child

print(test_node_1.data)  # 3

# 노드 B의 오른쪽 자식 노드 받아오기
test_node_2 = test_node_1.right_child

print(test_node_2.data)  # 11
```

<br/><br/>

## 07. 이진 트리 만들어 보기  

### 실습 설명
이전 영상에서는 간단히 이진 트리를 코드로 구현해봤습니다. 그 순서를 간단히 설명하면 아래 3 단계로 나타낼 수 있습니다.
1. 노드 클래스를 정의하고
2. 그 인스턴스들을 생성한 후
3. 만들어놓은 인스턴스들을 트리 모양에 맞게 연결한다.

이번 과제에서는 이 방법대로 이진 트리를 직접 만들어 볼게요.
저희가 만들어 볼 이진 트리는 아래와 같은 모양의 트리입니다.
![image](https://bakey-api.codeit.kr/files/2370/o1NaXU?name=1.png)

노드 안에 있는 데이터는 문자열 데이터이며, 각각 문자열 A, B, C, D, E, F, G, H를 저장하고 있습니다.  
직접 노드 인스턴스들을 만들고 연결시켜서 위와 같은 트리를 만들어 보세요.

### 실습 결과
```
F
G
H
```

<br/><br/>

### 해설
```python
# root 노드 생성
root_node = Node("A")
```
#### 각 노드 인스턴스 생성
먼저 트리 안에 추가할 모든 노드 인스턴스들을 생성해야 하는데요. root 노드를 Node("A")로 만든 것처럼, 다른 노드들도 저장할 데이터를 Node 클래스의 \_\_init\_\_ 메소드의 파라미터로 넘겨 주면서 생성합시다.
```python
# 다른 노드들 생성
node_B = Node("B")
node_C = Node("C")
node_D = Node("D")
node_E = Node("E")
node_F = Node("F")
node_G = Node("G")
node_H = Node("H")
```

#### 각 노드 인스턴스를 서로 연결
만든 노드 인스턴스들을 트리 모양에 맞게 연결합니다. 각 노드 인스턴스는 왼쪽 자식 노드를 나타내는 변수 left_child와 오른쪽 자식 노드를 나타내는 변수 right_child를 가지는데요. 이 변수들을 통해서 각 노드들을 연결하면 됩니다.
```python
# 노드 인스턴스들 연결
root_node.left_child = node_B
root_node.right_child = node_C

node_B.left_child = node_D
node_B.right_child = node_E

node_C.right_child = node_F

node_E.left_child = node_G
node_E.right_child = node_H
```
root 노드의 왼쪽 자식은 B, 오른쪽 자식은 C.  
B의 왼쪽 자식은 D, 오른쪽 자식은 E.  
C의 오른쪽 자식은 F.  
E의 왼쪽 자식은 G, 오른쪽 자식은 H.  
이대로 연결하면 되겠죠?  

### 테스트 코드
테스트 코드를 실행해 볼게요.
```python
# 실행 코드
test_node = root_node.right_child.right_child
print(test_node.data)

test_node = root_node.left_child.right_child.left_child
print(test_node.data)

test_node = root_node.left_child.right_child.right_child
print(test_node.data)
```

### 실습 결과
```
F
G
H
```
트리 모양에 맞게 잘 출력됩니다.

[main1_07.py](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/Data%20Structure/2%20Tree/1%20Tree/main1_07.py) 참고

<br/><br/>

## 08. 이진 트리 종류
트리에는 여러 종류가 있다고 했죠? 그리고 우리는 그 중 하나인 이진 트리를 배웠는데요. 사실 이진 트리도 다시 여러 종류로 분류할 수 있습니다.

이진 트리의 종류에 어떤 것들이 있는지 살펴봅시다.

### 정 이진 트리 (Full Binary Tree)
먼저 “정 이진 트리”라는 게 있습니다. 영어로는 **"full binary tree"** 라고 부르는데요. 모든 노드가 2개 또는 0개의 자식을 갖는 이진 트리입니다.  
![image](https://bakey-api.codeit.kr/files/2372/W2dJf5?name=%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA+2020-05-28+%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE+5.19.38.png)
왼쪽 그림의 이진 트리를 보면 12의 자식은 10 밖에 없습니다. 또 10은 자식이 2 밖에 없죠. 그러니까 왼쪽은 정 이진 트리가 아닙니다.

반면에 오른쪽 그림의 이진 트리는 모든 노드가 2개 또는 0개의 자식을 갖는 걸 볼 수 있습니다. 이런 트리가 바로 정 이진 트리입니다. 별로 어렵지 않죠?  

### 완전 이진 트리 (Complete Binary Tree)
그 다음 “완전 이진 트리”라는 게 있습니다. 영어로는 **"complete binary tree"** 라고 부릅니다. 이진 트리에서 노드의 깊이를 레벨이라고 해봅시다. 이진 트리 중에서도 마지막 레벨 직전의 레벨까지는 모든 노드들이 다 채워진 트리를 “완전 이진 트리”라고 합니다. 그리고 한 가지 조건이 더 있는데요. 마지막 레벨에서는 노드들이 다 채워질 필요는 없더라도, 왼쪽부터 오른쪽 방향으로는 노드들이 다 채워져야 합니다.

아래 트리는 완전 이진 트리입니다. 마지막 레벨을 제외한 모든 레벨에서 노드들이 꽉 차 있고, 마지막 레벨에서는 노드들이 왼쪽에서 오른쪽 방향으로 차 있는 거 보이시죠? 방금 말한 조건을 만족하기 때문에 완전 이진 트리인 거죠.  
![image](https://bakey-api.codeit.kr/files/2372/c2zngI?name=2.png)  
완전 이진 트리가 아닌 트리들도 좀 볼게요.
![image](https://bakey-api.codeit.kr/files/2372/k4yiH5?name=3.png)  
왼쪽 그림의 이진 트리를 봅시다. 레벨 4가 마지막 레벨인데 12의 오른쪽 자식이 없어서 레벨 3에 빈 부분이 생겼습니다. 마지막 레벨 직전 레벨까지는 노드로 다 채워져야 하는데 그렇지 않으므로 완전 이진 트리가 아닙니다.

이번엔 오른쪽 그림의 이진 트리를 봅시다. 마지막 레벨 직전 레벨까지는 노드로 다 채워지긴 했습니다. 하지만 마지막 레벨에서 노드들이 왼쪽에서 오른쪽으로 가득 채워지지 않아 왼쪽에 빈 공간이 생겼습니다. 그래서 완전 이진 트리가 아닙니다.

완전 이진 트리가 되기 위한 조건이 무엇인지 확실하게 이해하고 넘어가세요.

#### 완전 이진 트리의 높이

완전 이진 트리에는 아주 중요한 성질이 하나 있습니다. 그건 바로 트리의 높이와 관련된 성질인데요. 완전 이진 트리 안에 저장된 노드가 $n$개라고 할 때, 높이는 항상 $lg(n)$에 비례합니다. 그림으로 표현하면 아래와 같은데요.
![image](https://bakey-api.codeit.kr/files/2372/NRFEzr?name=4.png)
왜 그런건지 설명할게요.

완전 이진 트리는 마지막 레벨 직전 레벨까지는 모두 노드로 가득 채워져 있습니다. 이때 완전 이진 트리에는 노드가 모두 몇 개 있을까요?
- 레벨 1에 1개
- 레벨 2에 2개
- 레벨 3에 4개
- 레벨 4에 8개

이런 식으로 노드 개수가 늘어나는데요. 레벨이 하나씩 증가할 때마다 이전 레벨에 있는 노드 개수의 2배를 더 담을 수 있습니다.

이 내용을 표로 정리해볼게요.  
| 레벨 |                   총 노드수 최솟값                  |                  총 노드수 최댓값                  |
|:----:|:---------------------------------------------------:|:--------------------------------------------------:|
|   1  |                          1                          |                          1                         |
|   2  |                         1+1                         |                         1+2                        |
|   3  |                        1+2+1                        |                        1+2+4                       |
|   4  |                       1+2+4+1                       |                       1+2+4+8                      |
|   5  |                      1+2+4+8+1                      |                     1+2+4+8+16                     |
|   …  |                          …                          |                          …                         |
|  $h$ | 1+2+4+…+ $2^{h-1}$ +1<br>( $2^h$ , 등비수열 공식 참조) | 1+2+4+… $2^h$ <br>( $2^{h+1}$ -1, 등비수열 공식 참조) |
