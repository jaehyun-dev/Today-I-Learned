# 1 트리란?

23.01.16  

## 01. 계층적 관계  

### 트리
- 데이터의 상-하 관계를 저장하는 자료 구조

상하관계 = 계층적 관계  
예시) 회사 임직원 데이터, 컴퓨터 폴더 구조, 클래스 상속 관계 등  

계층적 데이터 저장하려면?  
배열, 링크드 리스트 등은 선형적 자료 구조  
해시 테이블도 데이터 관계를 저장하기에는 적합하지 않음  

이런 계층적 관계의 자료를 저장하는 트리 자료구조에 대해서 배워볼 것

<br/><br/>

## 02. 트리란?  

링크드 리스트는 여러 개의 데이터를 순서대로 저장하는 선형 자료구조  
노드라는 기본 단위에 데이터를 담음  
하나의 노드는 저장하려는 데이터와 다음 순서를 가르키는 레퍼런스를 가짐
각 노드가 다음 노드에 대한 레퍼런스를 갖기 때문에 여러 노드 사이에 앞과 뒤라는 순서를 저장할 수 있음  

트리 노드도 기본적으로 데이터를 저장하는 단위  
링크드 리스트는 다음 노드를 가리키는 레퍼런스를 갖고 있던 반면, 트리 노드는 하위 관계에 있는 노드를 가리키는 레퍼런스를 가짐  
특정 노드의 하위 노드를 자식 노드라고 부름  
A 노드가 B 노드와 C 노드를 하위 노드로 갖는다면, B와 C는 A의 자식 노드, A는 B와 C의 부모 노드  

링크드 리스트의 맨앞 노드를 head 노드라고 하고 특별히 관리함  
트리에서도 맨위 노드 뿌리 또는 root 노드라고 하여 특별히 관리함  
이 노드에서부터 레퍼런스 따라가면 모든 노드 찾을 수 있음  
나무의 뿌리처럼 트리의 가장 시작점이기 때문에 root라고 부름  

<br/><br/>

## 03. 트리 용어

트리에 대해서 더 깊이 배우기 전에 꼭 알아야하는 트리 관련 용어들을 배우고 갈게요. 앞으로 이 용어들을 다음 레슨들에서 자주 사용할 거니까 꼭 이해하고 외워두세요.

![image](https://bakey-api.codeit.kr/files/2369/TM643U?name=1.png)

- root 노드(뿌리 노드): 트리의 시작 노드, 뿌리가 되는 노드를 말합니다. 보통 트리를 표현할 때 위 그림처럼 가장 위에 root 노드를 놓는 방식으로 나타냅니다.
- 부모 노드: 특정 노드의 직속 상위 노드입니다. 노드 G, J, K가 있는 노란색 박스를 살펴보면 G가 J와 K의 부모 노드입니다.
- 자식 노드: 특정 노드의 직속 하위 노드입니다. 부모 노드와 반대되는 개념인데요. 노드 G, J, K가 있는 노란색 박스를 살펴보면 J와 K가 G의 자식 노드입니다.
- 형제 노드: 같은 부모를 갖는 노드입니다. D와 E는 둘다 그 부모가 B죠? 이럴 때 D와 E는 서로 형제 노드입니다.
- leaf 노드 (잎/말단 노드): 자식 노드를 갖고 있지 않은, 가장 말단에 있는 노드입니다. 트리의 끝에 있다고 해서 root(뿌리) 노드와 반대되는 표현으로 leaf(잎) 노드라고 부릅니다. 위 그림에서 노란색 박스로 둘러싼 F가 leaf 노드입니다. F뿐만 아니라 D, H, I, J, K 모두 leaf 노드입니다.
- 깊이: 특정 노드가 root 노드에서 떨어져 있는 거리입니다. 깊이는 해당 노드로 가기 위해서 root 노드에서 몇 번 아래로 내려와야 하는지를 나타냅니다. 예를 들어 위 그림에서 root 노드의 자식 노드인 B와 C는 깊이가 1입니다. D, E, F, G는 깊이가 2이고, H, I, J, K는 깊이가 3입니다. 결국 깊이라는 건 특정 노드가 root 노드로부터 얼마나 멀리 떨어져 있는지를 나타냅니다.
- 레벨: 깊이 + 1. 깊이랑 거의 똑같은 개념입니다. 그냥 깊이에 1을 더한 값이죠. 레벨 1에 있는 노드들, 레벨 2에 있는 노드들… 이런식으로 특정 깊이인 노드들을 묶어서 표현할 때 사용하는 용어입니다.
- 높이: 트리에서 가장 깊이 있는 노드의 깊이입니다. 위 그림의 트리에서는 H, I, J, K가 가장 깊이 있는 노드들이고 그 깊이는 모두 3입니다. 그래서 트리의 높이는 3입니다.

![image](https://bakey-api.codeit.kr/files/2369/AlHaCe?name=2.png)
- 부분 트리 (sub-tree): 현재 트리의 일부분을 이루고 있는 더 작은 트리를 말합니다. 위 그림의 트리는 root 노드가 A인 트리입니다. 그런데 이 트리를 좀더 작은 단위로 쪼개보면 더 작은 부분 트리들을 발견할 수 있습니다. 예를 들어 위 그림의 노란색 큰 박스 안을 보세요. 노란색 큰 박스 안에는 ‘C가 root 노드인 트리’가 있는데요. 이런 걸 바로 부분 트리라고 합니다. 지금 C가 A의 오른쪽 자식이죠? 그래서 노란색 큰 박스 안에 있는 부분 트리를 A의 “오른쪽 부분 트리”라고 합니다. 특정 노드를 root 노드라고 생각하고 바라본다면 여러 가지 부분 트리들을 발견할 수 있습니다. 하나의 전체 트리에 여러 부분 트리들이 존재하는 겁니다.

<br/><br/>

## 04. 트리의 활용  

트리의 장점은 계층적 관계가 있는 데이터를 자연스럽게 저장할 수 있다는 점  
트리는 폭넓게 사용됨
- 컴퓨터 과학의 다양한 문제들을 기발하게 해결!
    - 정렬 문제, 압축 문제 등
- 다양한 추상 자료형 구현!
    - 딕셔너리, 세트, 우선순위 큐 등  

### 트리의 활용  
- 계층적 관계가 있는 데이터를 컴퓨터에서 사용!
- 컴퓨터 과학의 다양한 문제 기발하게 해결!
- 흔히 사용하는 여러 추상 자료형 구현!

<br/><br/>

## 05. 이진 트리
- 각 노드가 최대 2개의 자식 노드를 가질 수 있는 트리
- 각 노드의 자식은 0~2개 있을 수 있음
- 최대 두 개의 자식이 있기 때문에, 왼쪽 자식 & 오른쪽 자식으로 부를 수 있음  
- 개념을 이해하기도 쉽고 구현도 간단하기 때문에 트리를 공부할 때 이진 트리를 쓰면 더 개념에 집중할 수 있음
- (항상 이진 트리만 쓰는 것은 아님!)

<br/><br/>

## 06. 이진 트리 구현
```python
class Node:
    """이진 트리 노드 클래스"""

    def __init__(self, data):
        """데이터와 두 자식 노드에 대한 레퍼런스를 갖는다"""
        self.data = data
        self.left_child = None
        self.right_child = None

"""노드 인스턴스 생성"""
root_node = Node(2)
node_B = Node(3)
node_C = Node(5)
node_D = Node(7)
node_E = Node(11)

"""B와 C를 root 노드의 자식으로 지정"""
root_node.left_child = node_B
root_node.right_child = node_C

"""D와 E를 B 노드의 자식으로 지정"""
node_B.left_child = node_D
node_B.right_child = node_E

# root 노드에서 왼쪽 자식 노드 받아오기
test_node_1 = root_node.left_child

print(test_node_1.data)  # 3

# 노드 B의 오른쪽 자식 노드 받아오기
test_node_2 = test_node_1.right_child

print(test_node_2.data)  # 11
```

<br/><br/>

## 07. 이진 트리 만들어 보기  

### 실습 설명
이전 영상에서는 간단히 이진 트리를 코드로 구현해봤습니다. 그 순서를 간단히 설명하면 아래 3 단계로 나타낼 수 있습니다.
1. 노드 클래스를 정의하고
2. 그 인스턴스들을 생성한 후
3. 만들어놓은 인스턴스들을 트리 모양에 맞게 연결한다.

이번 과제에서는 이 방법대로 이진 트리를 직접 만들어 볼게요.
저희가 만들어 볼 이진 트리는 아래와 같은 모양의 트리입니다.
![image](https://bakey-api.codeit.kr/files/2370/o1NaXU?name=1.png)

노드 안에 있는 데이터는 문자열 데이터이며, 각각 문자열 A, B, C, D, E, F, G, H를 저장하고 있습니다.  
직접 노드 인스턴스들을 만들고 연결시켜서 위와 같은 트리를 만들어 보세요.

### 실습 결과
```
F
G
H
```

<br/><br/>

### 해설
```python
# root 노드 생성
root_node = Node("A")
```
#### 각 노드 인스턴스 생성
먼저 트리 안에 추가할 모든 노드 인스턴스들을 생성해야 하는데요. root 노드를 Node("A")로 만든 것처럼, 다른 노드들도 저장할 데이터를 Node 클래스의 \_\_init\_\_ 메소드의 파라미터로 넘겨 주면서 생성합시다.
```python
# 다른 노드들 생성
node_B = Node("B")
node_C = Node("C")
node_D = Node("D")
node_E = Node("E")
node_F = Node("F")
node_G = Node("G")
node_H = Node("H")
```

#### 각 노드 인스턴스를 서로 연결
만든 노드 인스턴스들을 트리 모양에 맞게 연결합니다. 각 노드 인스턴스는 왼쪽 자식 노드를 나타내는 변수 left_child와 오른쪽 자식 노드를 나타내는 변수 right_child를 가지는데요. 이 변수들을 통해서 각 노드들을 연결하면 됩니다.
```python
# 노드 인스턴스들 연결
root_node.left_child = node_B
root_node.right_child = node_C

node_B.left_child = node_D
node_B.right_child = node_E

node_C.right_child = node_F

node_E.left_child = node_G
node_E.right_child = node_H
```
root 노드의 왼쪽 자식은 B, 오른쪽 자식은 C.  
B의 왼쪽 자식은 D, 오른쪽 자식은 E.  
C의 오른쪽 자식은 F.  
E의 왼쪽 자식은 G, 오른쪽 자식은 H.  
이대로 연결하면 되겠죠?  

### 테스트 코드
테스트 코드를 실행해 볼게요.
```python
# 실행 코드
test_node = root_node.right_child.right_child
print(test_node.data)

test_node = root_node.left_child.right_child.left_child
print(test_node.data)

test_node = root_node.left_child.right_child.right_child
print(test_node.data)
```

### 실습 결과
```
F
G
H
```
트리 모양에 맞게 잘 출력됩니다.

[main1_07.py](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/Data%20Structure/2%20Tree/1%20Tree/main1_07.py) 참고

<br/><br/>

## 08. 이진 트리 종류
트리에는 여러 종류가 있다고 했죠? 그리고 우리는 그 중 하나인 이진 트리를 배웠는데요. 사실 이진 트리도 다시 여러 종류로 분류할 수 있습니다.

이진 트리의 종류에 어떤 것들이 있는지 살펴봅시다.

### 정 이진 트리 (Full Binary Tree)
먼저 “정 이진 트리”라는 게 있습니다. 영어로는 **"full binary tree"** 라고 부르는데요. 모든 노드가 2개 또는 0개의 자식을 갖는 이진 트리입니다.  
![image](https://bakey-api.codeit.kr/files/2372/W2dJf5?name=%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA+2020-05-28+%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE+5.19.38.png)
왼쪽 그림의 이진 트리를 보면 12의 자식은 10 밖에 없습니다. 또 10은 자식이 2 밖에 없죠. 그러니까 왼쪽은 정 이진 트리가 아닙니다.

반면에 오른쪽 그림의 이진 트리는 모든 노드가 2개 또는 0개의 자식을 갖는 걸 볼 수 있습니다. 이런 트리가 바로 정 이진 트리입니다. 별로 어렵지 않죠?  

### 완전 이진 트리 (Complete Binary Tree)
그 다음 “완전 이진 트리”라는 게 있습니다. 영어로는 **"complete binary tree"** 라고 부릅니다. 이진 트리에서 노드의 깊이를 레벨이라고 해봅시다. 이진 트리 중에서도 마지막 레벨 직전의 레벨까지는 모든 노드들이 다 채워진 트리를 “완전 이진 트리”라고 합니다. 그리고 한 가지 조건이 더 있는데요. 마지막 레벨에서는 노드들이 다 채워질 필요는 없더라도, 왼쪽부터 오른쪽 방향으로는 노드들이 다 채워져야 합니다.

아래 트리는 완전 이진 트리입니다. 마지막 레벨을 제외한 모든 레벨에서 노드들이 꽉 차 있고, 마지막 레벨에서는 노드들이 왼쪽에서 오른쪽 방향으로 차 있는 거 보이시죠? 방금 말한 조건을 만족하기 때문에 완전 이진 트리인 거죠.  
![image](https://bakey-api.codeit.kr/files/2372/c2zngI?name=2.png)  
완전 이진 트리가 아닌 트리들도 좀 볼게요.
![image](https://bakey-api.codeit.kr/files/2372/k4yiH5?name=3.png)  
왼쪽 그림의 이진 트리를 봅시다. 레벨 4가 마지막 레벨인데 12의 오른쪽 자식이 없어서 레벨 3에 빈 부분이 생겼습니다. 마지막 레벨 직전 레벨까지는 노드로 다 채워져야 하는데 그렇지 않으므로 완전 이진 트리가 아닙니다.

이번엔 오른쪽 그림의 이진 트리를 봅시다. 마지막 레벨 직전 레벨까지는 노드로 다 채워지긴 했습니다. 하지만 마지막 레벨에서 노드들이 왼쪽에서 오른쪽으로 가득 채워지지 않아 왼쪽에 빈 공간이 생겼습니다. 그래서 완전 이진 트리가 아닙니다.

완전 이진 트리가 되기 위한 조건이 무엇인지 확실하게 이해하고 넘어가세요.

#### 완전 이진 트리의 높이

완전 이진 트리에는 아주 중요한 성질이 하나 있습니다. 그건 바로 트리의 높이와 관련된 성질인데요. 완전 이진 트리 안에 저장된 노드가 $n$개라고 할 때, 높이는 항상 $lg(n)$에 비례합니다. 그림으로 표현하면 아래와 같은데요.
![image](https://bakey-api.codeit.kr/files/2372/NRFEzr?name=4.png)    
왜 그런건지 설명할게요.

완전 이진 트리는 마지막 레벨 직전 레벨까지는 모두 노드로 가득 채워져 있습니다. 이때 완전 이진 트리에는 노드가 모두 몇 개 있을까요?
- 레벨 1에 1개
- 레벨 2에 2개
- 레벨 3에 4개
- 레벨 4에 8개

이런 식으로 노드 개수가 늘어나는데요. 레벨이 하나씩 증가할 때마다 이전 레벨에 있는 노드 개수의 2배를 더 담을 수 있습니다.

이 내용을 표로 정리해볼게요.  
| 레벨 |                   총 노드수 최솟값                  |                  총 노드수 최댓값                  |
|:----:|:---------------------------------------------------:|:--------------------------------------------------:|
|   1  |                          1                          |                          1                         |
|   2  |                         1+1                         |                         1+2                        |
|   3  |                        1+2+1                        |                        1+2+4                       |
|   4  |                       1+2+4+1                       |                       1+2+4+8                      |
|   5  |                      1+2+4+8+1                      |                     1+2+4+8+16                     |
|   …  |                          …                          |                          …                         |
|  $h$ | 1+2+4+…+ $2^{h-1}$ +1<br>( $2^h$ , 등비수열 공식 참조) | 1+2+4+… $2^h$ <br>( $2^{h+1}$ -1, 등비수열 공식 참조) |

이 표가 나타내는 내용을 정리하면 완전 이진 트리의 높이를 $h$, 그 노드 수를 $n$이라고 할 때,

$2^h <= n <= 2^{h+1} - 1$

$2^h <= n < 2^{h+1}$ 

이고 각 항에 $lg$를 씌우면

$h <= lg(n) < h+1$

이 됩니다. 이걸 보면 완전 이진 트리의 높이는 노드 수에 $lg$를 취한 값보다 작은 정수 중에서 최대의 정수임을 알 수 있습니다.

즉, 노드 수가 $n$개인 완전 이진 트리의 높이는 $h <= lg(n)$를 만족하는 정수 중 최대의 정수입니다. 
따라서 완전 이진 트리의 높이 $h$는 노드 수인 $n$에 $lg$를 취한 값인 $lg(n)$에 비례해서 증가한다는 것을 알 수 있습니다. 그럼 언제 높이가 하나 더 증가할까요? 그건 바로 노드 수가 현재보다 최소 2배 이상이 되었을 때입니다.

$h <= lg(n)$

인 상황에서 $n$이 $2n$이 되면,

$lg(2n) = lg(n) + 1$

이고,

$h + 1 <= lg(n) + 1$

을 만족하므로, 최소한 현재 노드 수보다 노드 수가 2배 이상이 되었을 때 높이도 하나 더 올라간다는 것을 알 수 있습니다.

이 내용을 정리하면 완전 이진 트리의 높이는 결국 $O(lg(n))$라고 할 수 있습니다. 이건 완전 이진 트리의 속성에서 아주 중요한 내용이니까 꼭 기억하고 넘어가세요.

### 포화 이진 트리 (Perfect Binary Tree)  
![image](https://bakey-api.codeit.kr/files/2372/Suu7QL?name=5.png)  
포화 이진 트리는 위 트리처럼 모든 레벨이 빠짐없이 다 노드로 채워져있는 이진 트리입니다. 모든 레벨이 완벽하게 다 채워져 있기 때문에 영어로는 **"perfect binary tree”** 라고 부르죠. 포화 이진 트리는 기본적으로 정 이진 트리와 완전 이진 트리의 특성을 모두 갖습니다.

포화 이진 트리는
- 높이가 0이면 노드 수가 1개
- 높이가 1이면 노드 수가 (1 + 2)개
- 높이가 2면 (1 + 2 + 4)개
- 높이가 3이면 (1 + 2 + 4 + 8)개

이런 식으로 그 높이에 따라 노드의 수가 고정됩니다. 트리의 높이를 $h$, 노드 수를 $n$이라고 하면, 높이와 노드 수의 관계를 이렇게 표현할 수 있습니다.  

$n = 2^{h+1} − 1$

이 식의 양 쪽에 1을 더해주면 결국

$n + 1 = 2^{h + 1}$

이런 공식이 성립합니다.

지금 위 그림의 포화 이진 트리는 노드 수가 총 7개인데요. 위 공식의 $n$에 7을 그대로 대입해보면

$7 + 1 = 2^{h + 1}$  
$8 = 2^{h + 1}$

이런 식이 성립합니다. 8은 2의 3승이니까 $h + 1 = 3$, 높이 $h$는 2라는 걸 알 수 있습니다. 이렇게 포화 이진 트리는 그 높이나 노드 수, 둘 중에서 하나만 알아도 나머지 하나의 값을 바로 구할 수 있습니다.

<br/><br/>

## 09. 완전 이진 트리 배열로 구현하기  

### 완전 이진 트리 배열 (파이썬 리스트)에 저장하기
이진 트리를 구현하는 방법, 기억 나시나요? 먼저 노드 클래스를 정의하고, 여러 개의 노드 인스턴스를 생성한 후, 이 인스턴스들을 서로 연결시켜서 트리를 만들었잖아요?

이번 레슨에서는 트리를 파이썬의 리스트로 구현해보겠습니다. 하지만 이 방법은 모든 이진 트리에 쓸 수 있는 방법은 아니구요. 완전 이진 트리인 경우에만 쓸 수 있는 방법입니다.

바로 예시를 볼게요. (완전 이진 트리가 뭔지 기억이 안 나시면 바로 전 노트를 복습하고 오세요!)

이런 완전 이진 트리가 있다고 합시다.

![image](https://bakey-api.codeit.kr/files/2373/CE2pR8?name=1.png)  

이 완전 이진 트리는 아래처럼 리스트에 저장할 수 있습니다.
```python
complete_binary_tree = [None, 1, 5, 12, 11, 9, 10, 14, 2, 10]
```
0번째 인덱스를 None으로 두고, 1번째 인덱스부터 root 노드를 시작으로, 그 다음에 깊이가 1인 노드들을 왼쪽에서 오른쪽 방향 순으로, 그 다음에 깊이가 2인 노드들을 왼쪽에서 오른쪽 방향 순으로 차례대로 리스트에 저장하면 됩니다.

지금 위 그림을 보면 각 노드 위에 빨간 색의 작은 숫자가 있죠? 빨간 색 작은 숫자는 각 노드의 리스트 내에서의 인덱스를 나타냅니다. 그러니까 리스트에서 5번째 노드는 노드 9입니다.

### 자식 노드를 찾는 방법
이진 트리에서 각 노드는 기본적으로 자식 노드들을 가리키는 레퍼런스를 가져야합니다. 그래야 부모 노드가 자식 노드에 접근할 수 있을 테니까요? 그렇다면 이렇게 리스트에 노드들이 저장된 경우에는 부모 노드가 자식 노드에 어떻게 접근할 수 있을까요?

트리의 이미지를 다시 봅시다.  
![image](https://bakey-api.codeit.kr/files/2373/1uPCSo?name=2.png)  

지금 2번째 노드(노드 5)의 왼쪽 자식 노드를 찾고 싶다고 합시다.

그럼 먼저 노드의 인덱스 2에 2를 곱합니다. 4죠? 그 다음 리스트의 4번째 인덱스에 있는 노드를 찾으면 됩니다. 노드 11이 있죠? 제대로 찾았습니다.

이런 식으로 특정 부모 노드의 왼쪽 자식 노드를 찾고 싶을 때는, 부모 노드가 저장된 인덱스에 2를 곱해준 값을 인덱스로 생각하고 리스트에서 찾으면 됩니다.

이번에는 3번째 노드(노드 12)의 오른쪽 자식 노드를 찾아 볼게요.

이번에도 노드의 인덱스 3에 2를 곱합니다. 그리고 1을 더해주는데요. 그럼 7입니다. 이번에는 리스트의 7 번째 인덱스를 보면 노드 14가 있습니다. 맞게 찾았네요.

어떤 식으로 자식 노드들을 찾을 수 있는지 이제 알겠죠?

### 부모 노드 찾기
비슷한 방식으로 특정 노드의 부모 노드도 찾을 수 있는데요.

![image](https://bakey-api.codeit.kr/files/2373/WFrkkS?name=3.png)  

여기서 6번째 노드(노드 10)의 부모를 찾으려면 6을 2로 나누면 됩니다. 리스트의 3번째 인덱스에 있는 노드 12를 잘 찾았네요.

그럼 자식 노드의 인덱스가 홀수일 때는 어떻게 할까요? 7번재 노드(노드 14)의 부모 노드를 찾고 싶다고 합시다. 이때는 7을 2로 나눈 후 정수 값만 가져오면 됩니다. 그 값은 3이죠? 그럼 리스트의 3번째 인덱스에 있는 노드 12를 잘 찾을 수 있습니다.

완전 이진 트리는 그것이 가지는 특수한 2가지 성질:
- 마지막 레벨 직전의 레벨까지는 노드들로 가득 차 있음
- 마지막 레벨은 왼쪽에서 오른쪽 방향으로 노드들로 가득 차 있어야 함(오른쪽은 비어있어도 되지만 왼쪽은 비어있으면 안 됨)

때문에 이렇게 각 노드를 리스트에 저장한 후에도 부모 노드와 자식 노드를 손쉽게 찾을 수 있습니다.

<br/><br/>

## 10. 완전 이진 트리 직접 구현하기  

### 실습 설명

![image](https://bakey-api.codeit.kr/files/2374/DEp8fI?name=1.png)  
```python
complete_binary_tree = [None, 1, 5, 12, 11, 9, 10, 14, 2, 10]
```
이전 레슨에서는 파이썬의 리스트로 완전 이진 트리를 구현하는 방법을 배웠습니다. 그리고 자식 노드와 부모 노드를 찾는 법을 배웠는데요.

이번 레슨에서는 자식 노드와 부모 노드를 찾는 기능을 함수로 직접 구현해 볼게요.

- get_left_child_index() 함수는 리스트 complete_binary_tree와 정수 index를 파라미터로 받습니다. 그리고 왼쪽 자식 노드가 있는 인덱스를 찾아서 리턴해 줍니다. 단, 왼쪽 자식 노드가 없을 경우, None을 리턴합니다.
- get_right_child_index() 함수는 리스트 complete_binary_tree와 정수 index를 받습니다. 그리고 오른쪽 자식 노드가 있는 인덱스를 찾아서 리턴해 줍니다. 단, 오른쪽 자식 노드가 없을 경우, None을 리턴합니다.
- get_parent_index() 함수는 리스트 complete_binary_tree와 정수 index를 받습니다. 그리고 부모 노드가 있는 인덱스를 찾아서 리턴해 줍니다. 단, 부모 노드가 없을 경우, None을 리턴합니다.

실행 코드에서는 위 이미지에 있는 트리를 그대로 사용합니다.

### 출력 예시
```
5
12
11
None
None
None
```

<br/><br/>

### 해설
각 함수를 하나씩 살펴볼게요.

#### get_parent_index() 함수
```python
def get_parent_index(complete_binary_tree, index):
    """배열로 구현한 완전 이진 트리에서 index번째 노드의 부모 노드의 인덱스를 리턴하는 함수"""
    parent_index = index // 2

    # 부모 노드가 있으면 인덱스를 리턴한다
    if 0 < parent_index < len(complete_binary_tree):
        return parent_index

    return None
```
get_parent_index() 함수는 부모 노드의 인덱스를 리턴해 주는 함수입니다. 이전 노트에서 부모 노드의 인덱스는 자식 노드의 인덱스에서 2를 나눈 후의 정수값이라고 했죠? 파이썬의 // 연산자를 사용해서 계산하면 됩니다.

부모 노드의 인덱스를 구했으면 그 인덱스가 유효한 범위에 있는 인덱스인지를 판단해야 합니다.
- 지금 complete_binary_tree 리스트의 0번째 인덱스에는 None이 저장돼 있기 때문에 인덱스는 0보다 커야 하고
- 인덱스는 리스트의 길이보다는 작아야 합니다.

그러니까 인덱스가 0보다 크고, complete_binary_tree 리스트의 길이보다 작은지 확인해야 합니다. 
만약 이 범위를 벗어나는 인덱스라면 어차피 노드가 존재하지 않습니다.

유효한 범위 내의 인덱스인 경우, parent_index를 리턴하고, 아니면 None을 리턴해 줍니다.

#### get_left_child_index() 함수
```python
def get_left_child_index(complete_binary_tree, index):
    """배열로 구현한 완전 이진 트리에서 index번째 노드의 왼쪽 자식 노드의 인덱스를 리턴하는 함수"""
    left_child_index = 2 * index

    # 왼쪽 자식 노드가 있으면 인덱스를 리턴한다
    if 0 < left_child_index < len(complete_binary_tree):
        return left_child_index

    return None
```
get_left_child_index() 함수는 왼쪽 자식 노드의 인덱스를 리턴해 주는 함수입니다. 이전 노트에서 왼쪽 자식 노드의 인덱스는 부모 노드의 인덱스에 2를 곱하면 된다고 했는데요. 이건 그냥 2\*index를 해 주면 되죠?

그렇게 구한 인덱스가 유효한 범위에 있는 인덱스인지를 확인하면 됩니다.
- 지금 complete_binary_tree 리스트의 0번째 인덱스에는 None이 저장돼있기 때문에 인덱스는 0보다 커야 하고
- 인덱스는 리스트의 길이보다는 작아야 합니다.

그러니까 인덱스가 0보다 크고, complete_binary_tree 리스트의 길이보다 작은지 확인해야 합니다. 
만약 이 범위를 벗어나는 인덱스라면 어차피 노드가 존재하지 않습니다.

유효한 범위 내의 인덱스인 경우, left_child_index를 리턴하고, 아니면 None을 리턴해 줍니다.

#### get_right_child_index() 함수
```python
def get_right_child_index(complete_binary_tree, index):
    """배열로 구현한 완전 이진 트리에서 index번째 노드의 오른쪽 자식 노드의 인덱스를 리턴하는 함수"""
    right_child_index = 2 * index + 1

    # 오른쪽 자식 노드가 있으면 인덱스를 리턴한다
    if 0 < right_child_index < len(complete_binary_tree):
        return right_child_index

    return None
```
get_right_child_index() 함수는 오른쪽 자식 노드의 인덱스를 리턴해 주는 함수입니다. 이전 노트에서 오른쪽 자식 노드의 인덱스는 부모 노드의 인덱스에 2를 곱하고 1을 더하면 된다고 했는데요. 이건 그냥 2\*index + 1을 해 주면 되죠?

그렇게 구한 인덱스가 유효한 범위에 있는 인덱스인지를 확인하면 됩니다.
- 지금 complete_binary_tree 리스트의 0번째 인덱스에는 None이 저장돼있기 때문에 인덱스는 0보다 커야 하고
- 인덱스는 리스트의 길이보다는 작아야 합니다.

그러니까 인덱스가 0보다 크고, complete_binary_tree 리스트의 길이보다 작은지 확인해야 합니다. 
만약 이 범위를 벗어나는 인덱스라면 어차피 노드가 존재하지 않습니다.

유효한 범위 내의 인덱스인 경우, right_child_index를 리턴하고, 아니면 None을 리턴해 줍니다.

### 테스트 코드
작성한 함수들이 제대로 동작하는지 확인해 봅시다.
```python
# 실행 코드
root_node_index = 1 # root 노드

tree = [None, 1, 5, 12, 11, 9, 10, 14, 2, 10]  # 과제 이미지에 있는 완전 이진 트리

# root 노드의 왼쪽과 오른쪽 자식 노드의 인덱스를 받아온다
left_child_index = get_left_child_index(tree, root_node_index)
right_child_index = get_right_child_index(tree,root_node_index)

print(tree[left_child_index])
print(tree[right_child_index])

# 9번째 노드의 부모 노드의 인덱스를 받아온다
parent_index = get_parent_index(tree, 9)

print(tree[parent_index])

# 부모나 자식 노드들이 없는 경우들
parent_index = get_parent_index(tree, 1)  # root 노드의 부모 노드의 인덱스를 받아온다
print(parent_index)

left_child_index = get_left_child_index(tree, 6)  # 6번째 노드의 왼쪽 자식 노드의 인덱스를 받아온다
print(left_child_index)

right_child_index = get_right_child_index(tree, 8)  # 8번째 노드의 오른쪽 자식 노드의 인덱스를 받아온다
print(right_child_index)
```

### 실습 결과
```
5
12
11
None
None
None
```
구하려는 각 인덱스에 위치한 노드의 값이 잘 출력되는 걸 확인할 수 있습니다. 그리고 어차피 노드가 없는 인덱스인 경우 None을 리턴하는 것을 알 수 있습니다.

[main1_10.py](https://github.com/jaehyun-dev/Today-I-Learned/blob/24280debc2c738c38fcac806fdd46e9841c0225b/Data%20Structure/2%20Tree/1%20Tree/main1_10.py) 

<br/><br/>

23.01.17

## 11. 트리 순회

### 순회
- 자료 구조에 저장된 모든 데이터를 도는 것
- 배열, 링크드 리스트 같은 선형 자료구조는 가장 앞 데이터부터 마지막 데이터까지 순서대로 데이터 접근하면 된다
- 트리 노드들 사이에는 앞과 뒤라는 선형적 관계가 없는데 어떻게 순회할 수 있을까?
- 즉, 데이터를 어떤 순서로 접근할 수 있을까?

### 트리 순회
- 선형 자료구조 순회는 반복문을 주로 사용하고, 트리 순회는 재귀 함수를 주로 사용함
- 순회하며 출력하는 예시
```python
def traverse(node):
    """트리를 순회하면서 출력하는 함수"""
     
traverse(root_node)
```
순회하고 싶은 트리의 루트 노드를 파라미터로 받아와서 트리의 모든 노드를 순회

### 순회 방법
- 재귀적으로 왼쪽 부분 트리 순회
```python
def traverse(node):
    ...
    traverse(node.left_child)
    ...
```
- 재귀적으로 오른쪽 부분 트리 순회
```python
def traverse(node):
    ...
    traverse(node.right_child)
    ...
```
- 현재 노드 데이터에 접근
```python
def traverse(node):
    ...
    print(node.data)  # 순회하여 출력하는 예시이므로
    ...
```

<br/><br/>

## 12. 트리 순회: pre-order

### pre-order 순회
- 현재 노드 데이터를 출력한다
- 재귀적으로 왼쪽 부분 트리 순회
- 재귀적으로 오른쪽 부분 트리 순회

![image](https://user-images.githubusercontent.com/71001479/212907010-34749899-18bb-4c48-9593-5e7541c0fb29.png)
