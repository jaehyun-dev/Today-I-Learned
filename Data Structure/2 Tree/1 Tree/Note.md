# 1 트리란?

23.01.16  

## 01. 계층적 관계  

### 트리
- 데이터의 상-하 관계를 저장하는 자료 구조

상하관계 = 계층적 관계  
예시) 회사 임직원 데이터, 컴퓨터 폴더 구조, 클래스 상속 관계 등  

계층적 데이터 저장하려면?  
배열, 링크드 리스트 등은 선형적 자료 구조  
해시 테이블도 데이터 관계를 저장하기에는 적합하지 않음  

이런 계층적 관계의 자료를 저장하는 트리 자료구조에 대해서 배워볼 것

<br/><br/>

## 02. 트리란?  

링크드 리스트는 여러 개의 데이터를 순서대로 저장하는 선형 자료구조  
노드라는 기본 단위에 데이터를 담음  
하나의 노드는 저장하려는 데이터와 다음 순서를 가르키는 레퍼런스를 가짐
각 노드가 다음 노드에 대한 레퍼런스를 갖기 때문에 여러 노드 사이에 앞과 뒤라는 순서를 저장할 수 있음  

트리 노드도 기본적으로 데이터를 저장하는 단위  
링크드 리스트는 다음 노드를 가리키는 레퍼런스를 갖고 있던 반면, 트리 노드는 하위 관계에 있는 노드를 가리키는 레퍼런스를 가짐  
특정 노드의 하위 노드를 자식 노드라고 부름  
A 노드가 B 노드와 C 노드를 하위 노드로 갖는다면, B와 C는 A의 자식 노드, A는 B와 C의 부모 노드  

링크드 리스트의 맨앞 노드를 head 노드라고 하고 특별히 관리함  
트리에서도 맨위 노드 뿌리 또는 root 노드라고 하여 특별히 관리함  
이 노드에서부터 레퍼런스 따라가면 모든 노드 찾을 수 있음  
나무의 뿌리처럼 트리의 가장 시작점이기 때문에 root라고 부름  

<br/><br/>

## 03. 트리 용어

트리에 대해서 더 깊이 배우기 전에 꼭 알아야하는 트리 관련 용어들을 배우고 갈게요. 앞으로 이 용어들을 다음 레슨들에서 자주 사용할 거니까 꼭 이해하고 외워두세요.

![image](https://bakey-api.codeit.kr/files/2369/TM643U?name=1.png)

- root 노드(뿌리 노드): 트리의 시작 노드, 뿌리가 되는 노드를 말합니다. 보통 트리를 표현할 때 위 그림처럼 가장 위에 root 노드를 놓는 방식으로 나타냅니다.
- 부모 노드: 특정 노드의 직속 상위 노드입니다. 노드 G, J, K가 있는 노란색 박스를 살펴보면 G가 J와 K의 부모 노드입니다.
- 자식 노드: 특정 노드의 직속 하위 노드입니다. 부모 노드와 반대되는 개념인데요. 노드 G, J, K가 있는 노란색 박스를 살펴보면 J와 K가 G의 자식 노드입니다.
- 형제 노드: 같은 부모를 갖는 노드입니다. D와 E는 둘다 그 부모가 B죠? 이럴 때 D와 E는 서로 형제 노드입니다.
- leaf 노드 (잎/말단 노드): 자식 노드를 갖고 있지 않은, 가장 말단에 있는 노드입니다. 트리의 끝에 있다고 해서 root(뿌리) 노드와 반대되는 표현으로 leaf(잎) 노드라고 부릅니다. 위 그림에서 노란색 박스로 둘러싼 F가 leaf 노드입니다. F뿐만 아니라 D, H, I, J, K 모두 leaf 노드입니다.
- 깊이: 특정 노드가 root 노드에서 떨어져 있는 거리입니다. 깊이는 해당 노드로 가기 위해서 root 노드에서 몇 번 아래로 내려와야 하는지를 나타냅니다. 예를 들어 위 그림에서 root 노드의 자식 노드인 B와 C는 깊이가 1입니다. D, E, F, G는 깊이가 2이고, H, I, J, K는 깊이가 3입니다. 결국 깊이라는 건 특정 노드가 root 노드로부터 얼마나 멀리 떨어져 있는지를 나타냅니다.
- 레벨: 깊이 + 1. 깊이랑 거의 똑같은 개념입니다. 그냥 깊이에 1을 더한 값이죠. 레벨 1에 있는 노드들, 레벨 2에 있는 노드들… 이런식으로 특정 깊이인 노드들을 묶어서 표현할 때 사용하는 용어입니다.
- 높이: 트리에서 가장 깊이 있는 노드의 깊이입니다. 위 그림의 트리에서는 H, I, J, K가 가장 깊이 있는 노드들이고 그 깊이는 모두 3입니다. 그래서 트리의 높이는 3입니다.

![image](https://bakey-api.codeit.kr/files/2369/AlHaCe?name=2.png)
- 부분 트리 (sub-tree): 현재 트리의 일부분을 이루고 있는 더 작은 트리를 말합니다. 위 그림의 트리는 root 노드가 A인 트리입니다. 그런데 이 트리를 좀더 작은 단위로 쪼개보면 더 작은 부분 트리들을 발견할 수 있습니다. 예를 들어 위 그림의 노란색 큰 박스 안을 보세요. 노란색 큰 박스 안에는 ‘C가 root 노드인 트리’가 있는데요. 이런 걸 바로 부분 트리라고 합니다. 지금 C가 A의 오른쪽 자식이죠? 그래서 노란색 큰 박스 안에 있는 부분 트리를 A의 “오른쪽 부분 트리”라고 합니다. 특정 노드를 root 노드라고 생각하고 바라본다면 여러 가지 부분 트리들을 발견할 수 있습니다. 하나의 전체 트리에 여러 부분 트리들이 존재하는 겁니다.

<br/><br/>

## 04. 트리의 활용  

트리의 장점은 계층적 관계가 있는 데이터를 자연스럽게 저장할 수 있다는 점  
트리는 폭넓게 사용됨
- 컴퓨터 과학의 다양한 문제들을 기발하게 해결!
    - 정렬 문제, 압축 문제 등
- 다양한 추상 자료형 구현!
    - 딕셔너리, 세트, 우선순위 큐 등  

### 트리의 활용  
- 계층적 관계가 있는 데이터를 컴퓨터에서 사용!
- 컴퓨터 과학의 다양한 문제 기발하게 해결!
- 흔히 사용하는 여러 추상 자료형 구현!

<br/><br/>

## 05. 이진 트리
- 각 노드가 최대 2개의 자식 노드를 가질 수 있는 트리
- 각 노드의 자식은 0~2개 있을 수 있음
- 최대 두 개의 자식이 있기 때문에, 왼쪽 자식 & 오른쪽 자식으로 부를 수 있음  
- 개념을 이해하기도 쉽고 구현도 간단하기 때문에 트리를 공부할 때 이진 트리를 쓰면 더 개념에 집중할 수 있음
- (항상 이진 트리만 쓰는 것은 아님!)

<br/><br/>

## 06. 이진 트리 구현
```python
class Node:
    """이진 트리 노드 클래스"""

    def __init__(self, data):
        """데이터와 두 자식 노드에 대한 레퍼런스를 갖는다"""
        self.data = data
        self.left_child = None
        self.right_child = None

"""노드 인스턴스 생성"""
root_node = Node(2)
node_B = Node(3)
node_C = Node(5)
node_D = Node(7)
node_E = Node(11)

"""B와 C를 root 노드의 자식으로 지정"""
root_node.left_child = node_B
root_node.right_child = node_C

"""D와 E를 B 노드의 자식으로 지정"""
node_B.left_child = node_D
node_B.right_child = node_E

# root 노드에서 왼쪽 자식 노드 받아오기
test_node_1 = root_node.left_child

print(test_node_1.data)  # 3

# 노드 B의 오른쪽 자식 노드 받아오기
test_node_2 = test_node_1.right_child

print(test_node_2.data)  # 11
```
