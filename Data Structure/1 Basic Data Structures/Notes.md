22.08.13  

자료구조 = 데이터를 저장하고 관리하기 위해 사용하는 구조  
데이터의 효율적인 접근 및 조작을 가능하게 해주는 저장 및 관리 방식  
  
  
22.08.14  
각 상황에 알맞은 자료구조를 사용해야 시간적으로 효율적임 
  
22.08.15 23:45  
예시) python에서 0부터 1000000까지의 정수가 저장되어있는 리스트와 세트가 있을 때, 세트에서 1000000이라는 원소를 찾는 게 라스트에서 찾는 것보다 3000배 정도 빠르다.  
상황에 따라 효율적인 자료구조는 다르고, 각 자료구조마다 장점과 단점이 있기 때문에 모든 경우에 제일 좋은 자료구조는 없다.  
자료구조를 잘 배우면 어떤 자료구조들이 존재하고 어떤 상황에서 어느 자료구조를 써야 하는지 알 수 있다.  
  
22.08.16 23:49  
자료구조의 목적 = 자료를 구조화하여 데이터를 효율적으로 사용하는 것  
컴퓨터에 데이터가 어떻게 저장되는지 알아야 됨  
데이터가 저장되는 곳 두 가지  
1. 스토리지  
데이터가 영구적으로 저장되는 곳  
사진, 음성, 문서파일 등  
사용자가 지우거나 심각한 충격이 있지 않은 이상 사라지지 않음  
데이터를 저장하는 데 오래 걸린다  
데이터를 받아오는 데 오래 걸린다  
창고 같은 역할  
지금 당장 사용하는 게 아니라 나중에 사용할 파일, 정확히 언제 사용할지 모르겠는 파일 저장  
2. 메모리  
데이터가 임시로 저장되는 곳  
데이터를 저장하는 데 빠르다  
데이터를 받아오는 데 빠르다  
책상 서랍 같은 역할  
지금 당장 사용하는 파일 저장  
  
워드 프로세서에서 작성하던 내용은 메모리에 저장됨  
이 상황에서 컴퓨터가 꺼지면 메모리에 있던 내용 사라짐  
만약 작업 도중 저장 버튼을 누르면, 내용은 스토리지에 저장되고 컴퓨터가 꺼져도 사라지지 않음  
  
자료구조를 배울 때는 메모리가 스토리지보다 더 중요함  
메모리에서 데이터를 효율적으로 사용하기 위한 것이 자료구조
  
22.08.17 23:23  
메모리  
일정한 칸으로 나눠져 있는 긴 띠로 비유할 수 있음  
각 칸에 데이터를 저장할 수 있음  
각 칸은 자신만의 주소가 있음  

RAM(Random Access Memory, 임의 접근 메모리)  
임의 접근: 저장 위치를 알면 접근할 때 항상 일정한 시간이 걸림  
따라서 메모리에 저장한 데이터 접근 시간 복잡도: O(1)  
  
비디오 테이프의 경우 원하는 위치로 가려면 한참 걸림  
순차 접근: 저장된 위치까지 가는 데 한 단계씩 거쳐야 됨  
임의 접근이 순차 접근보다 압도적으로 효율적임  

자료 구조 배울 때  
메모리에 데이터를 저장한다  
메모리에 저장된 데이터를 찾는다  
등의 표현은 항상 임의 접근으로 하고 있고 O(1)임을 기억해야 함  
  
  
  
22.08.18 23:30  
메모리는 하나의 긴 띠라고도 표현했는데요. 이 띠는  
  
1. 일정한 칸으로 나눠져 있고  
2. 각 칸에 데이터를 저장할 수 있고  
3. 각 칸은 자신만의 주소가 있습니다  
  
이 메모리 한 칸이 저장할 수 있는 가장 기본적인 용량의 단위는 바이트, 영어로는 byte입니다. 자료 구조를 공부하면서 바이트라는 단위가 정확히 얼만큼의 정보를 저장하는 단위인지는 모르셔도 됩니다. 그냥 엄청 작은 단위라고만 알고 계시면 됩니다.  
  
바이트가 아닌 다른 크기의 용량을 담는 저장 장치들도 있긴 한데요. 대부분의 현대 컴퓨터 시스템들은 메모리 한 칸에 바이트만큼의 데이터를 저장합니다.  
  
일상 생활 속에서도 많은 분들께서 이미 바이트라는 용어를 들어보셨을 텐데요. 흔히 영상, 문서, 음성 파일이나, RAM 또는 컴퓨터의 스토리지의 크기를 표현할 때,  
  
* 160 킬로 바이트(kB)  
* 10 메가 바이트(MB)  
* 32 기가 바이트(GB)  
이런 식으로 많이 표현하는데요. 킬로 바이트, 메가 바이트, 기가 바이트는 그냥 데이터의 용량이 몇 바이트인지 표현한 겁니다. 정확히 얘기하자면,  
  
* 킬로 바이트 = 1,000 바이트  
* 메가 바이트 = 1,000,000 바이트  
* 기가 바이트 = 1,000,000,000 바이트  
이만큼의 저장 공간 용량들이죠.  

자료 구조를 배우면서 바이트나 다른 저장 공간 단위들을 심도 있게 다루지는 않을 건데요. 그래도 자료 구조에서는 이해하면 도움이 되는 개념/용어이니까,  
  
1. 바이트는 컴퓨터 저장 공간 용량을 나태내는 단위다.  
2. 메모리 한 칸에 담기는 데이터 용량은 1 바이트다.  
이 정도는 이해하고 넘어가시면 나중에 나오는 내용을 이해하는 데 조금 더 수월할 거예요!  
  
  
  
22.08.19 23:21  
x = 95  
95라는 정수값을 변수 x에 지정하면 변수 x는 정수 95를 갖는다.  
"x는 95다"는 파이썬에서 틀린 표현.  
x는 95라는 값 자체를 갖는 게 아니라, 95가 담겨있는 메모리 주소를 갖는다.  
이 메모리 주소를 이용해서 정수값 95를 찾아오는 것.   
"x는 95를 가리킨다"가 맞는 표현.  

데이터에 접근하게 해주는 값 = 레퍼런스(reference)  
주소와 레퍼런스는 다르다.  
주소는 메모리의 진짜 실질적인 주소를 말한다.  
레퍼런스는 추상적인 개념, 데이터에 접근할 수 있게 해주는 값, "주소"보다 조금 더 포괄적인 표현.  
하지만 자료구조를 배울 때는 "주소 = 레퍼런스"라고 생각해도 됨.  
  
변수를 사용할 때
```python
x = 95
print(x + 5)
```
실제로 변수를 사용할 때는 저장된 값을 알아서 받아옴.  
파이썬이 메모리에 있는 95를 받아와서, 95 + 5를 print하게 됨.  
  
    
22.08.20 23:24  
## 05. 데이터의 주소  
### 파이썬 id 함수  
데이터가 저장되어 있는 주소를 알아내는 방법을 볼게요.  
id 함수를 이용하면 저장한 데이터의 메모리 주소를 정수로 표현한 값을 알아낼 수 있습니다. 여러 타입의 데이터를 저장하고 id 함수를 써서 메모리 주소를 출력시켜보겠습니다.  
```python
# 여러 데이터를 저장한다
list1 = [1, 2]
int1 = 0
float1 = 3.14
set1 = set()
tuple1 = (2, 3)
    
# 저장한 데이터의 메모리 저장 위치를 받아온다
print(id(list1))
print(id(int1))
print(id(float1))
print(id(set1))
print(id(tuple1))
```
```python
140237662138184
4450309504
140237661913472
140237664406888
140237662993992
```
데이터가 각각 다른 메모리 주소에 저장돼 있군요.  
주소는 코드를 돌릴 때마다 다르게 나오니까 여러분 컴퓨터에 다르게 출력되어도 놀라지 마세요!  

## 같은 주소에 저장돼 있는 데이터  
좀 당연한 말같이 들리실 수도 있는데요. 똑같은 주소에 저장돼 있는 데이터는 똑같은 데이터입니다.  
```python
# 리스트를 정의한다
list1 = [1, 2]
list3 = [1, 2, 3]
    
# Aliasing을 통해 list1과 list2를 같게 한다
list2 = list1
    
# 두 데이터의 메모리를 출력한다
print(id(list1))  # 140657629409160
print(id(list2))  # 140657629409160
print(id(list3))  # 140657629409096
```
위 코드를 살펴봅시다. 세 변수 list1, list2, list3를 만들었습니다.  
list1은 정수 1, 2를, 그리고 list3은 1, 2, 3을 담고 있는 리스트입니다.  
그리고 list2에  list1를 지정했습니다. 메모리에서 만든 하나의 같은 리스트를 list1, list2라는 두 개의 다른 변수가 가리키고 있는 거죠. 이렇게 여러 변수가 같은 메모리를 가리키는 것을 Aliasing이라고 합니다.  
id 함수를 써서 list1과 list2의 메모리 주소를 출력해 보면 같다고 나오죠? list3는 다른 주소에 저장되어 있습니다. list1과 list2는 서로 같은 리스트를 가리키고 있기 때문에 똑같은 메모리가 출력되고, list3는 전혀 다른 리스트를 가리키고 있기 때문에 다른 메모리가 출력되는 거죠.
  
22.08.21 22:10  
질문 1  
  
다음 중 RAM에 대한 설명으로 옳지 않은 것을 모두 고르시오.  
  
1 RAM은 임의 접근 방식을 이용해서 저장한 데이터에 빠르게 접근할 수 있다.  
2 RAM은 동일한 크기의 칸으로 나눠진 굉장히 긴 띠라고 생각하면 편하다.  
3 RAM의 한 칸에 저장되는 데이터의 용량은 1 킬로 바이트다.  
4 RAM에서 데이터에 접근할 때, 더 멀리 있는 주소에 접근하려면 시간이 더 오래 걸린다.  
5 RAM에 저장된 데이터는 임시적으로 저장된다. 데이터를 영구적으로 저장하고 싶으면 스토리지에 저장해야 된다.  
  
  
답> 3번, 4번  

퀴즈 해설  
3: RAM의 한 칸에 저장되는 데이터의 용량은 1 바이트다.  
4: RAM은 접근하려는 데이터의 주소에 상관없이 항상 일정한 시간 내에 접근할 수 있다.  
  
22.08.22 22:55  
질문 2  

다음 문장이 옳은지 틀린지 고르시오.  

x = 5 이 파이썬 코드에서 x는 5라는 데이터 자체를 담고 있는게 아니라 5가 저장된 곳의 레퍼런스를 갖고 있다.  

1 옳다.  
2 틀리다.  

답> 1번  

퀴즈 해설  
파이썬 변수는 실제 데이터를 저장하지 않고 저장한 데이터를 찾는 방법(레퍼런스)을 저장한다.  
print(x + 10) 이렇게 변수에 저장한 데이터를 받아와야 될 때는, 파이썬이 알아서 변수 x에 저장한 데이터인 5를 찾아와서 10에 더해준다. (실제 레퍼런스와 10을 더하지는 않는다)  
  
  
22.08.23 23:59  
배열  
(파이썬 리스트와 비슷)  
파이썬 언어는 C언어 기반으로 만들어졌고, 파이썬 리스트는 C의 배열을 이용해서 만들어졌음  
차이점  
파이썬 리스트에서는 append 메소드를 쓰면 계속해서 요소를 추가할 수 있음  
C 배열은 크기가 고정돼 있음(처음에 크기를 정해놓고 시작)  
배열의 각 요소를 다른 값으로 수정할 수는 있지만, 지우거나 삭제할 수는 없음  
파이썬 리스트에서는 다양한 타입의 값들을 담을 수 있지만, C 배열에서는 같은 타입의 데이터만 담을 수 있음  

```c
int numAraay[4];
```
정수 4개 배열   
메모리에 필요한만큼의 공간을 미리 할당한다  
배열이 쓸 공간을 미리 예약하는 것  
C언어에서 정수는 보통 4byte  
정수 4개 배열은 총 16byte의 메모리가 필요  
연속적인 16칸 예약  
사용할 메모리 공간 정했으면 값들을 채워넣을 수 있음  
```c
numArray[0] = 2;
numArray[1] = 3;
numArray[2] = 5;
numArray[3] = 7;
```
1-4째 칸에 2를 저장    
5-8째 칸에 3을 저장    
9-12째 칸에 5를 저장    
13-16째 칸에 7을 저장    

```python
num_list = [2, 3, 5, 7]
```
파이썬 리스트는 2, 3, 5, 7 값들이 메모리 아예 다른 곳에 저장돼있을 수 있음  
연속적인 공간에 있을 수도 있고 아닐 수도 있음  
16byte 예약된 메모리 공간에는 2, 3, 5, 7이 저장된 레퍼런스가 저장됨  
2, 3, 5, 7을 저장하고 있는 게 아니고 가리키고 있는 개념  
값 자체가 저장되는 게 아니기 때문에, 자료들의 크기가 상관이 없게 됨  
아무리 큰 값이나 작은 값이더라도 가리키기만 하기 때문에, C 배열과 다르게 다양한 타입의 값들을 저장할 수 있음 
  
배열은 가장 기본적인 자료 구조이기 떄문에 중요!

22.08.24 22:38  
배열에 데이터를 저장하고 가지고 오는 법  
```c
int numArray[4];
```
정수는 보통 4byte이기에 정수 4개의 배열을 저장하기 위해서는 16byte 메모리가 필요  
컴퓨터는 메모리에서 사용하고 있지 않은 공간 중 연속적인 16byte인 공간을 찾음  
예를 들어 주소값 1000에서 1015까지  
```c
numArray[0] = 2;
numArray[1] = 3;
numArray[2] = 5;
numArray[3] = 7;
```
정수 2는 주소 1000-1003까지 차지  
정수 3는 주소 1004-1007까지 차지  
정수 5는 주소 1008-1011까지 차지  
정수 7는 주소 1012-1015까지 차지  
배열의 요소들이 메모리에 순서대로, 그리고 연속적으로 저장  
  
불러올 때는 인덱스를 사용하면 됨 
```c
printf("%d", numArray[0]); // 0번 인덱스 값 출력
printf("%d", numArray[1]); // 1번 인덱스 값 출력
printf("%d", numArray[2]); // 2번 인덱스 값 출력
printf("%d", numArray[3]); // 3번 인덱스 값 출력
```
내부적으로 어떻게 이루어지고 있을까?  
numArray는 배열이 시작되는 지점의 주소를 가리키고 있음(1000)
몇 번 인덱스를 받아오고 싶냐에 따라 주소를 찾는다  
예를 들어 2번 인덱스를 받아오고 싶으면  
인덱스 2 주소: 1000 + 4 x 2 = 1008  
인덱스 i 주소: 1000 + 4 x i  
배열이 시작하는 지점의 주소만 알면 어떤 인덱스이든 주소를 쉽게 계산할 수 있음  
  
램은 임의접근 메모리이기에 주소가 있으면 어디에 있든 상관없이 효율적으로 접근할 수 있음(O(1))  
배열의 어떤 인덱스의 값을 받아오려면 그 값의 주소를 알아야 함  
그 주소는 간단한 계산으로 구할 수 있음  
주소를 알면 O(1)으로 접근 가능함  
배열에서 값을 받아오는 건 O(1)으로 할 수 있으므로 굉장히 효율적  
값을 저장하는 것도 똑같음  
특정 인덱스의 값을 저장하기 위해서는 그 인덱스의 주소를 알아야 하는데 값을 받아올 때와 똑같이 주소를 찾아서 그 주소에 O(1)으로 접근하고 거기에 값을 저장하면 됨  
배열 인덱스 접근: O(1)  
배열의 가장 큰 장점  
주소만 정확히 알고 있으면 한 번에 접근할 수 있는 램의 특성을 똑똑하게 이용하는 자료구조  
  
22.08.25  23:45  
배열 탐색  
접근: 인덱스를 통해 값을 찾는 것  
탐색: 특정 조건을 만족하는 값을 찾는 것  
ex) intArray가 있을 때 이 안에 23이 있을지 없을지 확인  
배열에서 탐색은 접근보다 비효율적일 수밖에 없음  
특정 조건을 만족하는 값을 찾기 위해서는 하나하나 배열을 다 봐야 하기 때문  
```c
numArray[0] = 2;
numArray[1] = 3;
numArray[2] = 5;
numArray[3] = 7;
```
이 배열에서 7이라는 값을 찾는다고 하면, 처음에는 0번 인덱스에 7이 있는지 보고, 없으면 1번 인덱스로 가서 있는지 보고, 없으면 2번, 그 다음 3번 등 7을 찾을 때까지 쭉 봐야 함  
순서대로 데이터를 하나씩 찾는 탐색법 = 선형 탐색  
배열이 특정 순서로 정렬되어있지 않은 이상 사실상 이보다 효율적으로 탐색할 수는 없음  
배열 탐색의 시간복잡도 = O(n)  
운이 좋으면(최선의 경우) 찾는 값이 0번 인덱스에 있을 수 있음  
최악의 경우는 값이 배열에 없는 경우  
배열에 값이 5개 있으면 최악의 경우 5개를 봐야 하고, 배열에 값이 10,000개 있으면 최악의 경우 10,000를 봐야 함  
배열에 저장한 데이터가 n개일 때, 탐색에 걸리는 시간은 n에 비례함  
따라서 시간 복잡도 = O(n)  
  
정리  
배열의 특정 인덱스에 접근하고 특정 인덱스에 값을 저장하는 것은 매우 효율적, O(1)  
특정 조건을 만족하는 값을 탐색하는 것은 비교적 오래 걸림, O(n)  
  
22.08.26 23:40  
정적 배열: 처음 정의할 때 크기 고정(요소 수 제한), 그 이상으로 추가할 수 없음  
동적 배열: 크기 변함(요소 계속 추가 가능)  
C 배열은 정적 배열  
보통 배열이라고 하면 정적 배열, 동적 배열은 "동적" 붙여 말함  
배열 = 정적 배열 의미  
  
배열 만들 때 어떤 타입의 데이터 저장할지, 몇 개의 데이터 저장할지 정함  
정수 5개를 담을 수 있는 배열 꽉 찼을 때, 하나의 정수를 배열에 추가하는 유일한 방법은, 정수 6개를 담을 수 있는 새로운 배열을 만드는 것  
6개의 정수값을 담을 수 있는 새로운 메모리 공간을 확보하고, 앞의 5개의 정수값을 복사하고, 그 뒤에 마지막 정수값을 저장  
5번째 정수값 뒤에 새 정수값을 저장할 수 있으면 좋을 텐데 안 되는 이유?  
배열을 정의하면 메모리에서 쓸 수 있는 공간을 찾아야 하는데, 저장하려고 하는 데이터의 타입과 개수에 따라서 얼만큼의 공간이 필요한지 정해짐  
이 메모리 공간은 띄엄띄엄 있으면 안 되고, 쭉 연결된 공간이어야 함  
사용할 수 있는 공간을 찾아서 값들을 저장했을 경우, 배열이 꽉 찬 상태에서 새로운 데이터를 추가하고 싶을 때, 다음 주소가 써도 되는 공간인지 알 수 없음  
비어있으면 그냥 저장하면 되지만, 비어있는지 아닌지 알 수 없으니까 그냥 사용하기는 위험함  
이 위험성을 미리 예방하기 위해서 배열은 저장할 수 있는 공간을 고정해둠  
딱 이 저장공간 내에서만 데이터를 수정하도록 함  
여유롭게 쓰겠다고 배열을 처음부터 크게 정의하면, 필요 이상으로 크게 정의해 메모리 공간을 낭비함(낭비되는 공간이 많아짐)  
나중에 다른 데이터를 저장해야 하는데 공간이 부족해서 문제가 생길 수 있음  
처음에 값을 5개 저장하는데, 정수 5만 개인 배열을 정의하면, 49,995개의 정수를 저장할 수 있는 공간을 낭비하게 됨  
  
22.08.27 21:57  
## 동적 배열(Dynamic Array)  
정적 배열은 처음부터 크기가 정해져있고 그 후에는 크기를 바꿀 수 없음  
반면 동적 배열은 상황에 맞게 크기가 바뀜  
사실상 동적 배열은 정적 배열을 이용해 만들어진 것  
intDynamicArray라는 동적 배열 정의했다고 가정  
이게 그냥 배열이었으면, 꽉 찼을 때 더이상 값을 추가할 수 없음  
예약한 공간이 꽉찬 것은 똑같은데 어떻게 값을 추가할 수 있을까?  
더 많은 값을 저장하기 위해 더 큰 메모리 공간을 확보  
기존에 있던 배열보다 두 배로 큰 배열을 만듦  
원래 정수 4개를 담을 수 있는 배열이었으면, 정수 8개를 담을 수 있는 배열을 만듦  
꼭 2배일 필요는 없고, 정하기 나름  
일단 2배로 커진다고 가정  
공간이 2배로 많아졌으니, 값들을 추가할 수 있음  
기존에 있던 데이터를 앞에서부터 복사해서 붙여넣고, 새로운 데이터를 바로 다음 공간에 저장하면 됨  
또 값을 추가하고 싶으면, 여유 공간이 이미 확보돼있기 때문에 다음 칸에 값을 저장하면 됨  
반복하다가 배열이 또 꽉 차면, 이번에도 2배 크기의 배열을 만들면 됨  
메모리 공간을 확보하면 기존 배열에서 값들을 다 복사하고 새 값을 추가하면 됨  
정적 배열로 만들어진 자료 구조  
정적 배열의 크기를 상황에 맞게 조절한다  
기존 배열이 꽉 찼을 때 크기를 두 배 정도로 적당히 늘리면 한동안은 새로운 배열을 만들지 않고 값을 추가할 수 있음  
개발자 입장에서는 배열의 크기에 대해서는 신경쓸 필요가 없기 때문에 굉장히 편해짐  
  
22.08.28 23:20  
## 파이썬 리스트(동적 배열)의 비밀  
사실 우리는 이미 동적 배열을 사용하고 있었는데요. 파이썬 리스트가 바로 동적 배열입니다. C 배열을 이용해서 동적 배열을 구현한 거죠.  
보세요.  
이렇게 5개의 정수 값이 들어간 파이썬 리스트를 만들었습니다. 파이썬 리스트는 동적 배열이기 때문에, 내부적으로는 C 배열이 만들어진 거죠.  
```python
int_list = [2, 3, 5, 7, 11]
```
여기에 새로운 값을 추가할 수도 있습니다.  
```python
int_list.append(13)
```
우리 입장에서는 내부적으로 얼마나 큰 배열이 있는지 몰라도, 값을 맘대로 추가할 수 있습니다. 동적 배열이기 때문에 상황에 맞게 배열 크기가 조절되고 있는 거죠.  
자 그런데, 우리는 리스트를 사용할 때 현재 내부적으로 사용되고 있는 배열의 크기를 모릅니다. 아무리 저장한 데이터가 6개여도 내부적으로는 8개짜리 배열일 수도 있고, 12개짜리 배열일 수도 있고, 15개짜리 배열일 수도 있고… 알 수가 없습니다.  
그럼 만약 리스트의 길이를 출력하면 뭐가 나올까요? len 함수를 쓰면 길이를 알 수 있죠?  
```python
print(len(int_list))
```
출력되는 결과를 보면…  
```python
6
```
6이라고 나오는데요. 실제 사용하고 있는 메모리 공간이 더 많을지라도, 파이썬은 개수를 셀 때 값을 저장해 놓은 공간에 대해서만 알려 줍니다. 그래서 우리는 나머지 공간에 대해서 전혀 신경을 안 써도 됩니다.  
오히려 채워지지 않은 공간을 접근하려고 하면…  
```python
print(int_list[9])
```
```
Traceback (most recent call last):
  File "main.py", line 4, in <module>
    print(int_list[9])
IndexError: list index out of range
```
오류가 납니다.  
우리가 미리 값을 저장해 놓은 공간에만 접근할 수 있도록 파이썬이 미리 처리를 해 놓은 겁니다.  
파이썬뿐만 아니라, 동적 배열을 자료형으로 제공하는 대부분의 언어들은 이렇게 실제 사용하는 배열의 크기와 상관없이 저장해 놓은 공간만 사용할 수 있게 처리를 해 줍니다.  
뒤 레슨들에서 이 여유 공간은 항상 빈칸으로 표시할 건데요. 이 공간은 항상 개발자들이 접근할 수 없다고 가정할게요.  
  
22.08.29 23:12  
## 동적 배열 추가 연산 시간 복잡도  
배열의 가장 끝에 새 값을 넣는 걸 영어로 append operation이라고 함(추가 연산).  
동적 배열의 끝에 값을 추가할 때 시간이 얼마나 걸리는지 분석해보자.  
동적 배열은 내부적으로는 그냥 정적 배열을 사용한다.  
새 값을 추가하려고 할 때, 내부적으로 사용 중인 정적 배열에 남은 공간이 있을 수도 있고 꽉 찼을 수도 있다.  
  
- 경우 1: 정적 배열 남는 공간 있을 때  
비어있는 공간 중에 가장 앞쪽에 있는 칸에 데이터를 저장하면 됨.  
인덱스를 이용해서 접근하는 것은 O(1).  
이 경우에 동적 배열에 데이터를 추가하는 건 굉장히 효율적으로 할 수 있다.  
  
- 경우 2: 정적 배열이 꽉 찼을 때  
이번에는 좀 더 복잡함.  
값을 추가하기 위해서는 현재 사용 중인 배열보다 두 배로 큰 메모리 공간을 예약함.  
기존 배열에서 새로운 배열로 값을 싹 다 복사한다.  
마지막으로 새 값을 빈 칸에 추가한다.  
  
걸리는 시간?  
기존에 저장돼있던 데이터의 갯수 = n  
이미 있던 n개의 데이터를 새 배열에 복사해야 하는데, 이건 일일이 하나씩 해야 한다.  
기존 배열의 0번 인덱스에 접근해서 값을 복사하고, 새 배열의 0번 인덱스에 접근해서 값을 붙여넣고.  
1번 인덱스, 2번 인득세 등 차례로 하나하나.  
배열의 특정 인덱스에 접근하는 건 O(1)이라서 빠르지만, 총 n번 해야 하기 때문에 이 과정은 O(n)이 걸린다.  
새 값을 추가하는 마지막 단계도 O(1)이니까, O(n + 1) = O(n)  

요약  
동적 배열에 값을 추가하는 건 얼마나 걸릴까?  
두 가지 경우가 있다  
내부적으로 사용 중인 배열의 상태에 따라 달라짐  
- 경우 1: 내부 배열에 여유 공간이 있을 때는 O(1)  
- 경우 2: 내부 배열에 여유 공간이 없을 떄는 O(n)  
  
최고의 경우: O(1)  
최악의 경우: O(n)  
  
22.08.30 23:48  
## 분할 상환 분석 개념  
추가 연산 시간 복잡도  
최고의 경우: O(1), 배열에 공간이 있을 때, 자주 일어남  
최악의 경우: O(n), 배열이 꽉 차있을 때, 가끔 일어남  
보통 시간 복잡도는 보수적으로 계산하기 위해 최악의 경우를 기준으로 하는데, 이런 경우는 불합리하다  
그래서 시간 복잡도를 다르게 계산하는 몇 가지 방법이 있음  
  
분할 상환 분석(Amortized Analysis)  
할부와 비슷한 개념  
108만원 핸드폰을 3년 할부로 사면, 3년에 108만원 vs 1개월에 3만원  
  
컴퓨터과학의 분할 상환 분석  
같은 동작을 n번 했을 때 드는 시간이 X일 때:  
동작을 한 번 하는 데 걸린 시간: X/n  
시간 복잡도를 최악으로 얘기하지 않고 평균을 내서 얘기하는 것  
조금 더 합리적인 시간 복잡도를 구할 수 있음  
  
22.08.31 23:33  
## 분할 상환 분석 적용  
분할 상환 분석은 연산을 n 번 했을 때 총 드는 시간 X를 n으로 나눠주는 “할부” 개념이라고 배웠는데요. 최악의 경우로 시간 복잡도를 얘기하는 것이 비합리적인 경우에 사용하죠. 이번 레슨에서는 동적 배열의 추가(append) 연산에 직접 분할 상환 분석을 해 봅시다.  

### 동적 배열 동작
동적 배열에 추가를 할 때는:  
1\. 새로운 인덱스에 데이터를 저장하는 시간  
2\. 기존 배열의 크기가 부족해서 더 큰 배열을 만들고, 기존 배열의 데이터들을 옮기는 시간  
이 두 가지를 나눠서 생각하면 편합니다.  
우선 기억을 상기시키기 위해서 동적 배열에 데이터를 추가할 때 일어나는 일들을 쭉 나열해 볼게요.  
비어 있는 동적 배열에 추가 연산을 9번 한다고 가정합시다. 처음 시작할 때 동적 배열은 크기가 1인 배열입니다.  
  
1. 첫 번째 요소 추가:  
    1. 그냥 새로운 데이터를 저장합니다.  
2. 두 번째 요소 추가:  
    1. 배열이 꽉 찼습니다. 크기가 2인 배열을 새로 만들고 기존 데이터를 옮겨 저장합니다(1개 옮겨 저장)  
    2. 맨 뒤 인덱스에 새로운 데이터를 저장합니다.  
3. 세 번째 요소 추가:  
    1. 배열이 꽉 찼습니다. 크기가 4인 배열을 새로 만들고 기존 데이터를 옮겨 저장합니다(2개 옮겨 저장)  
    2. 맨 뒤 인덱스에 새로운 데이터를 저장합니다.  
4. 네 번째 요소 추가  
    1. 맨 뒤 인덱스에 새로운 데이터를 저장합니다.  
5. 다섯 번째 요소 추가  
    1. 배열이 꽉 찼습니다. 크기가 8인 배열을 새로 만들고 기존 데이터를 옮겨 저장합니다(4개 옮겨 저장)  
    2. 맨 뒤 인덱스에 새로운 데이터를 저장합니다.  
6. 여섯 번째 요소 추가  
    1. 맨 뒤 인덱스에 새로운 데이터를 저장합니다.  
7. 일곱 번째 요소 추가  
    1. 맨 뒤 인덱스에 새로운 데이터를 저장합니다.  
8. 여덟 번째 요소 추가  
    1. 맨 뒤 인덱스에 새로운 데이터를 저장합니다.  
9. 아홉 번째 요소 추가  
    1. 배열이 꽉 찼습니다. 크기가 16인 배열을 새로만들고 기존 데이터를 옮겨 저장합니다(8개 옮겨 저장)  
    2. 맨 뒤 인덱스에 새로운 데이터를 저장합니다.  
    
이런 식으로 내부 배열이 꽉 찼을 때는 새로운 배열을 만들고, 기존 요소들을 복사하고, 새로운 요소를 저장하면 됩니다. 그리고 배열에 여유가 있으면 그냥 새로운 요소만 저장하면 되죠?  
  
### 분할 상환 분석  
분할 상환 분석을 하면 이 동작을 n번 반복한다고 가정합니다. 총 걸리는 시간을 계산하기 쉽게 두 가지로 나눠서 생각해 볼 거라고 했잖아요?

1\. 새로운 데이터를 동적 배열 맨 끝에 단순히 저장하는 데 걸리는 시간  
2\. 더 큰 배열을 만들고 그 배열에 기존의 데이터를 옮기는 데 걸리는 시간  
걸리는 두 시간을 각각 따로 계산해 볼게요.  
  
#### 배열 끝에 새로운 데이터 저장하는 데 걸리는 시간  
먼저 새로운 데이터를 저장하는 데 걸리는 총 시간에 대해서 생각해 봅시다.  
| x번째 추가 | 배열 끝에 데이터 저장하는 데 걸리는 시간 |
|:----------:|:----------------------------------------:|
|      1     |                     1                    |
|      2     |                     1                    |
|      3     |                     1                    |
|      4     |                     1                    |
|      5     |                     1                    |
|      6     |                     1                    |
|      7     |                     1                    |
|      8     |                     1                    |
|      9     |                     1                    |
|     ...    |                     1                    |
|      n     |                     1                    |  

인덱스에 데이터를 저장하는 데 걸리는 시간은 1이라고 했잖아요? 이걸 총 n번 하는 거니까 O(n)이 걸리겠죠?  
  
#### 새로운 배열에 데이터 옮기는 시간  
이번에는 내부 배열이 꽉 차서 기존 데이터를 복사하는 데 걸리는 시간에 대해서 생각해 봅시다. 이 부분이 좀 어려우니까 집중해서 보세요.  
| x번째 추가 | 배열 크기 | 새로운 배열에 요소 옮겨 저장하는 데 걸린 시간 |
|:----------:|:---------:|:---------------------------------------------:|
|      1     |     1     |                       0                       |
|      2     |     2     |                       1                       |
|      3     |     4     |                       2                       |
|      4     |     4     |                       0                       |
|      5     |     8     |                       4                       |
|      6     |     8     |                       0                       |
|      7     |     8     |                       0                       |
|      8     |     8     |                       0                       |
|      9     |     16    |                       8                       |
|     ...    |           |                       0                       |
|      n     |           |                                               |  
  
새로운 배열에 기존 데이터를 옮겨 저장하는 시간은 위 표에 나와 있는대로 소요됩니다.  
표를 살펴봅시다. 2 번째, 3 번째, 5 번째, 9 번째 추가 때 배열의 크기를 늘려야 합니다. 그럴 때마다 데이터를 옮겨야 하는데요. 이때 데이터를 각각 1, 2, 4, 8 개씩 복사하고 붙여 넣습니다.  
데이터를 복사해서 붙여 넣는 총 시간 비용은 이 시간들을 더한 8 + 4 + 2 + 1인데요. 좀 더 일반화해서 생각할까요?  
추가 연산을 n번 했을 때, 가장 마지막에 데이터를 m개 옮겨서 저장했다고 합시다.  
그럼 데이터를 복사해서 저장하는 데 걸린 총 시간은 : m + m/2 + m/4 + ... + 1 이렇게 표현할 수 있는데요. 이걸 도형으로 나타내 볼게요. 이런 식으로 처음에 m이 있고 그 다음에 계속 반으로 줄어든 값을 더해 주겠죠?  
처음에 이렇게 더해 주다가, 결국에는 이렇게 될 텐데요.  
  
도형에서 볼 수 있듯이 이런 식으로 어느 자연수든 반씩 줄여서 1까지 계속 더해주면 그 결과는 절대 2m을 넘을 수 없습니다. 정확히 말하면 딱 2m - 1이 되죠.  
근데 가장 최근에 데이터를 옮겨 저장할 때 8이 걸렸다는 건 무슨 의미일까요? 원래 배열의 수용 가능 크기가 8이었지만 크기가 부족해서 16개의 데이터를 담을 수 있는 새로운 배열로 복사했다는 얘기인데요. 그럼 결국에 현재 배열 안에 있는 데이터는 9개에서 16개 사이라는 말입니다. 16개보다 더 많은 요소가 있으면 가장 최근에 옮겨 저장한 요소의 수가 8이 아니라 16이겠죠?  
이 사실을 바탕으로 우리가 일반화할 때 사용했던 배열 안 요소 수 n과 가장 최근 옮겨 저장한 요소 수 m의 관계에 대해서 한 가지 사실을 알아낼 수 있는데요.  
가장 최근에 복사하는 데 걸린 시간이 8일 때, 배열 안에 있는 데이터는 9개에서 16개 사이입니다. 즉, m은 무조건 n보다 작다고 할 수 있습니다.  
추가 연산을 연속으로 n번 하고, 가장 마지막에 옮겨 저장한 데이터 요소 수를 m이라고 할 때:  
- 복사해서 저장하는 데 걸리는 총 시간이 2m - 1이고  
- m은 n보다 작습니다.  
  
이걸 다시 정리해서 나타내면:  

> 연속으로 추가 연산을 n번을 하면 데이터를 옮겨서 저장하는 데 걸리는 총 시간은 2n보다 작다!

라고 할 수 있습니다.  
  
#### 두 경우 합치기
지금까지 나온 내용을 종합해 보면, 동적 배열에 n개의 데이터를 연속으로 추가하면:  
1\. 새로운 데이터를 저장하는 데에는 n의 시간이 들고,  
2\. 데이터를 옮겨 저장하는 데에는 2n보다 적은 시간이 걸리는데요.  
이 두 시간을 합치면 총 드는 시간은 3n보다 적은 시간이 걸리겠죠? 이걸 시간 복잡도로 표현하면 O(3n), 그러니까 O(n)이라고 할 수 있습니다.  
근데 이건 추가 연산을 한 번 하는 게 아니라 연속으로 n번 하는 데 걸리는 시간 복잡도입니다.  
그러니까 총 n번의 추가 연산을 하는 데 걸리는 시간이 O(n)인 건데요. 추가 연산을 n번 하는 데 O(n)의 시간이 걸리니까 1번 하는 데는 O(n)/n, 즉 O(1)이 걸리는 거죠.  
전에는 추가 연산이 최악의 경우 O(n)이 걸린다고 했었는데요. 분할 상환 분석을 하면 O(1)이 걸린다고 보는 거죠.  
  
#### 최악의 경우 분석 vs. 분할 상환 분석 뭘 쓰면 되는 걸까  
사실 분할 상환 분석을 한다고 꼭 시간 복잡도가 줄어드는 건 아닙니다. 보통은 할부 개념을 적용해도 시간 복잡도가 줄어들지 않죠.  
하지만 만약 최악의 경우보다 분할 상환 분석을 한 시간 복잡도가 더 적다면, 분할 상환 분석을 한 시간 복잡도를 사용합니다. 그러니까 “동적 배열의 끝에 데이터를 추가할 때는 O(1)이 걸린다.”라고 표현해도 된다는 거죠.  
보통은 혼란을 없애기 위해 좀 더 정확하게:  
> 동적 배열의 추가(append) 연산은 최악의 경우 O(n)이 걸리지만, 분할 상환 분석을 하면 O(1)이 걸린다.  
라고 표현할 수 있습니다!  
  
22.09.01 22:02  
## 삽입 연산(insert operation)  
배열의 아무 위치에나 새로운 데이터를 더하는 연산  
추가(append): 동적 배열의 끝에 새로운 데이터 더해줄 때 쓰는 표현  
삽입(insertion): 아무 위치에나 데이터를 더해줄 때 쓰는 표현  
- 경우 1: 정적 배열 남는 공간 있을 때  
0번부터 6번 인덱스까지 정수가 저장되어있는 배열에서 3번 인덱스에 7이라는 데이터를 삽입하고 싶다고 가정  
배열은 요소들이 연속되어 저장되어 있음  
배열 중간에 새로운 요소를 저장하려면 인덱스 3에 틈을 벌리고 들어가야 함  
인덱스 3과 인덱스 3 뒤에 있는 모든 요소들을 한 인덱스씩 뒤로 밀어넣어야 함  
인덱스 6의 요소를 인덱스 7로, 인덱스 5의 요소를 인덱스 6으로 등  
인덱스 3에 빈 공간이 생기면 여기에 7을 저장하면 됨  
시간복잡도: 최악의 경우는 인덱스 0에 삽입할 경우  
n개 요소가 저장된 배열에서 0번 인덱스에 삽입하기 위해서는 n개를 한칸씩 뒤로 미뤄야 함  
O(1)을 n번 반복, 따라서 O(n)  
새로운 데이터를 0번 인덱스에 삽입하는 것은 O(1)  
시간복잡도: O(n+1) = O(n)  
  
- 경우 2: 정적 배열이 꽉 찼을 때  
0번부터 4번 인덱스까지 정수가 저장돼어 꽉 차있는 배열에서 3번 인덱스에 7이라는 데이터를 삽입하고 싶다고 가정  
수용공간이 부족하기 떄문에 여유롭게 정수 10개를 저장할 수 있는 새로운 배열을 만든 후 기존 데이터를 복사해서 저장  
수용공간이 남았을 때와 마찬가지로 인덱스 3과 인덱스 3 뒤에 있는 모든 요소들을 한 인덱스씩 뒤로 밀어넣음  
인덱스 3에 7을 저장합  
시간 복잡도: 배열에 n개의 요소가 있을 때, 새로운 배열을 만들고 이 배열의 기존 요소들을 하나하나 옮겨 저장하는 것은 O(n)  
최악의 경우 인덱스 0에 요소를 삽입할 때  
n개의 요소를 모두 바로 뒤의 인덱스로 밀어야 하므로 O(n)  
저장하고 싶은 인덱스에 자리가 났으니까 새로운 데이터를 저장 O(1)  
따라서 O(n) + O(n) + O(1) = O(2n + 1) = O(n)  
  
삽입 연산의 시간 복잡도: O(n)  
  
22.09.02 22:52  
## 동적 배열 삭제 연산  
이번 레슨에서는 동적 배열에서 특정 위치에 있는 데이터를 지우는 삭제 연산에 대해서 배워 볼게요.  
### 삭제 연산 동작  
바로 예시를 볼게요. 이렇게 2, 3, 5, 7, 11이 있는 동적 배열에서 인덱스 1에 있는 3을 지우고 싶다고 할게요. 한 단계씩 봅시다.  
1. 인덱스 1 뒤에 있는 데이터를 모두 한 칸씩 앞으로 밀어서 저장합니다.
    1. 인덱스 1에 인덱스 2에 있던 5를 저장합니다
    2. 인덱스 2에 인덱스 3에 있던 7을 저장합니다
    3. 인덱스 3에 인덱스 4에 있던 11을 저장합니다
2. 동적 배열은 배열의 크기와 개발자가 사용하는 인덱스들의 범위를 따로 관리합니다. 전에 파이썬 리스트(동적 배열)의 비밀 노트에서 말씀드렸는데 기억 나시나요? 데이터를 삭제했으니까 동적 배열에서 접근할 수 있는 인덱스 범위도 1을 줄여 줍니다.

동적 배열에 남은 데이터를 확인해보면 2, 5, 7, 11입니다. 인덱스 1에 있는 데이터 3이 잘 삭제됐죠?  
요약하자면, 삭제 연산은 그냥 삭제하고 싶은 데이터 뒤에 있는 모든 데이터 요소들을 한 칸씩 앞으로 밀어서 저장하면 됩니다.  
  
### 삭제 연산 시간 복잡도  
삭제 연산의 시간 복잡도를 알아봅시다.  
전 레슨들에서는 데이터를 아무 위치에나 더해 주는 삽입(insert) 연산과 맨 끝에 더해주는 추가(append) 연산을 나눠서 생각했었는데요.  
삭제 연산도 아무 위치의 데이터를 삭제할 때와 맨 뒤 데이터를 삭제할 때, 두 경우를 나눠서 생각할 수 있습니다.  
  
#### 맨 앞 데이터를 지울 때 (최악의 경우)
삭제 연산이 가장 오래 걸리는 경우는 가장 앞 인덱스에 있는 데이터를 지우는 경우입니다.  
가장 앞 데이터를 삭제할 때는 인덱스 1부터 끝까지 모든 요소들을 한 칸씩 앞으로 밀어서 저장해야 됩니다.  
그러니까 삭제하기 전 배열 안에 총 n개의 데이터가 남아 있으면, 총 n-1개의 요소들을 하나씩 앞 칸으로 밀어서 저장해야 되는 거죠.  
이 횟수가 n에 비례하기 때문에 O(n)이 걸린다고 할 수 있죠.  
왜 가장 앞 인덱스를 지우는 게 최악의 경우인지 알겠죠?  
종합해 보면 삭제 연산은 총 O(n)이 걸린다고 할 수 있습니다.  
꽤 오래 걸리는 거죠.  
  
#### 맨 뒤 데이터를 지울 때
일단 아무 위치에 있는 데이터를 삭제할 때는 최악의 경우 O(n)이 걸린다고 했잖아요?  
이번엔 맨 뒤 데이터를 삭제하는 데 얼마나 걸리는지 생각해 볼게요.  
맨 뒤 데이터를 삭제할 때는 아무 요소도 안 밀고 저장해도 되고, 그냥 동적 배열의 사용 공간을 한 인덱스 줄이면 됩니다.  
이건 배열에 데이터 요소가 몇 개가 있는지에 상관이 없이 일정한 시간에 할 수 있습니다.  
O(1)이라고 할 수 있는 거죠.  

#### 정리
정리해 볼게요.
동적 배열의 아무 위치에 데이터를 삭제할 때는 원하는 위치 뒤에 있는 데이터를 옮겨 저장해야 됩니다.  
그래서 최악의 경우 O(n)이 걸립니다.  
하지만 가장 뒤에 있는 데이터를 삭제할 때는 다른 데이터를 옮겨 저장할 필요가 없습니다.  
따라서 O(1)이 걸립니다.  
  
22.09.03 23:45  
## 동적 배열 크기 줄이기  
동적 배열은 내부적으로 정해진 크기의 정적 배열을 사용하고 있습니다.  
값을 추가하다가 내부 배열이 꽉 차면, 더 큰 내부 배열을 사용하도록 자동으로 늘려 주는 거죠.  
반대로 삭제를 할 때에는 내부 배열의 크기를 줄이기도 하는데요...  
### 왜 내부 배열의 크기를 줄여야 될까?  
데이터 요소 10000 개가 들어 있는 동적 배열이 있다고 생각해 봅시다.  
편의상 배열의 크기가 꽉 찼다고 생각할게요.  
여기서 요소 9900 개를 삭제하면 100 개밖에 남지 않는데요.  
그러면 나머지 9900 개의 요소를 저장할 수 있는 메모리는 낭비되겠죠?  
동적 배열은 요소의 개수가 어느정도 줄어들면 내부 배열의 크기도 적절히 줄여서 공간을 좀 더 효율적으로 사용합니다.  
### 내부 배열의 크기는 어떻게 줄어들까?  
위의 동적 배열 int_array를 봅시다.  
int_array는 9 개의 요소를 담고 있습니다.  
내부 배열 크기가 9 개인 꽉 찬 동적 배열이라고 할게요.  
여기서 맨 뒤 요소 6 개를 삭제합니다.  
그럼 요소가 3 개로 줄어들죠?  
그럼 정수 6 개를 저장할 수 있는 공간이 낭비되네요.  
이렇게 낭비하는 공간이 너무 많아지는 경우에 내부 배열의 크기를 줄일 수 있습니다.  
그런데 정확히 어떤 시점에 줄이면 좋을까요?  
크기를 늘릴 때는 내부 배열이 꽉 찼을 때였는데요.  
크기를 줄일 때는 내부 배열의 사용 비율이 특정 값 이하로 떨어질 때입니다.  
이 비율이 1/3 이라고 가정하고 볼게요.  
요소가 4 개에서 3 개로 줄어든 상황이라고 합시다.  
내부 배열에 요소 9 개를 담을 수 있는데, 현재 사용 중인 공간은 3 칸밖에 없습니다.  
그러니까 총 사용할 수 있는 공간 중 1/3 밖에 사용을 안 하게 된 거죠.  
이때:  
1. 새로운 내부 배열을 정의합니다. 이번에는 크기가 3인 내부 배열을 만듭니다:  
2. 그리고 기존의 3 개 요소를 새로 만든 내부 배열에 옮겨서 저장합니다:  

전에는 6 칸을 낭비하고 있었는데 이제는 낭비하는 공간이 하나도 없습니다.  
내부 배열의 크기를 요소 수에 맞게 줄이면, 낭비하는 공간을 최소한으로 할 수 있습니다.  
그렇다고 방금 예시처럼 꼭 사용 비율이 1/3 일 때 크기를 줄여야 하는 것은 아닙니다.  
1/2, 1/4, 1/5 일 때 줄일 수도 있죠. 개발자나 프로그래밍 언어에 따라 이 비율은 다릅니다.  
일단 저희는 생각하기 편하게 내부 배열의 크기를 늘릴 때에는 2 배로 늘리고, 줄일 때에는 요소 수가 크기의 1/2 가 됐을 때 줄인다고 가정할게요.  
  
### 시간 복잡도
#### 동적 배열 맨 끝 데이터 삭제 시간 복잡도
맨 끝 요소를 삭제했을 때 걸리는 시간 복잡도에 대해서 생각해 봅시다.  
최악의 경우를 가정합시다.  
가장 오래 걸리는 경우는, 더 작은 배열로 모든 요소들을 옮겨 저장해야 될 때인데요.  
배열 안에 있는 요소 수가 n 이라고 할 때, 총 n 개의 데이터를 모두 새 배열에 복사해서 넣어야겠죠.  
맨 뒤 데이터를 삭제하는 건 O(1)이 걸립니다.  
하지만 n 개의 데이터를 모두 새 배열에 복사해서 넣어야 되기 때문에 n에 비례하는 시간, O(n)이 걸립니다.  
  
#### 맨 끝 데이터 삭제 분할 상환 분석
하지만 내부 배열의 크기가 줄어드는 건 드문 경우입니다.  
대부분의 경우 그냥 마지막 인덱스에 있는 데이터를 지워 주기만 하면 됩니다.  
위에서 봤던 예시를 다시 생각해 봅시다.  
요소가 9 개에서 3 개로 줄어들 때까지, 그러니까 마지막 데이터 6 개를 삭제할 동안 배열의 크기를 조절할 필요가 없었습니다.  
이 6 번은 그냥 O(1)로 맨 끝 데이터를 삭제한 거죠.  
근데 요소 수가 4 개에서 3 개로 줄어들 때에는, 마지막 데이터를 삭제하고 남은 3 개의 데이터를 새롭게 만든 더 작은 배열로 복사해서 저장했습니다.  
이 경우에 O(n)이 걸린 거죠.  
동적 배열에서 마지막 데이터를 삭제할 때는 대부분의 경우 O(1)이 걸리지만, 드물게 O(n)이 걸립니다.  
그렇기 때문에 추가 연산과 마찬가지로 분할 상환 분석을 적용할 수 있습니다.  
분할 상환 분석을 적용하면 맨 끝 데이터 삭제 연산도 O(1)이 걸린다고 이야기할 수 있습니다.  
  
#### 정리  
> 동적 배열에서 맨 끝 데이터를 삭제하는 연산은 최악의 경우 O(n)이 걸리지만, 분할 상환 분석을 적용하면 O(1)이라고 할 수 있다.
  
22.09.04 22:28  
## 배열과 동적 배열 정리/비교  
### 연산 & 시간 복잡도
|               | 배열 |     동적 배열    |
|:-------------:|:----:|:----------------:|
| 접근 (access) | O(1) |       O(1)       |
| 탐색 (search) | O(n) |       O(n)       |
| 삽입 (insert) |  N/A | O(n), 맨 뒤 O(1) |
| 삭제 (delete) |  N/A | O(n), 맨 뒤 O(1) |
### 낭비하는 공간  
- 배열: 크기가 고정되어 있기 때문에 낭비하는 공간이 없다!  
- 동적 배열: 공간을 낭비할 수도 있고 안 할 수도 있다!  
    - 최악의 경우(새로운 배열을 만들었을 때): 저장된 요소 수가 n일 때 낭비되는 공간 n - 2  

따라서 낭비하는 공간: O(n)  
  
## 정적 배열에 삽입과 삭제를 못하는 이유
챕터 정리 레슨에서 배열에는 삽입과 삭제 연산을 자연스럽게 할 수 없다고 했습니다.  
두 연산의 시간 복잡도를 N/A, 해당 사항 없음으로 표기했죠?  
이번 노트에서 왜 그런지 알아볼게요.  
C 배열을 써서 보여드릴게요.  

### 배열에 데이터 삽입을 못하는 이유
이건 정적 배열의 한계 레슨에서 이미 배운 내용이긴 한데요.  
복습한다는 생각으로 보세요!  

```c
int numArray[4];
    
numArray[0] = 2;
numArray[1] = 3;
numArray[2] = 5;
numArray[3] = 7;
```

배열에 삽입을 못하는 이유는 직관적입니다.  
이렇게 정수형 데이터 4 개를 저장하는 배열을 정의했다고 할게요.  
배열은 크기가 정해져 있습니다.  
더 많은 데이터 요소들을 저장하고 싶으면 더 큰 배열을 정의해야 되죠.  
사용하고 싶은 요소 수에 따라 크기를 바꿀 수 있으면 그건 배열이 아니라 동적 배열이겠죠?  
크기가 고정되어 있는 배열에는 처음 정한 수보다 더 많은 데이터를 삽입할 수가 없는 거죠.  
  
### 배열에 데이터 삭제를 못하는 이유
이번에는 삭제를 못하는 이유를 알아봅시다.  

```c
int numArray[4];
    
numArray[0] = 2;
numArray[1] = 3;
numArray[2] = 5;
numArray[3] = 7;
```

정수 4개를 담을 수 있는 배열에 2, 3, 5, 7이 저장돼 있다고 할게요.  
여기서 인덱스 1에 있는 3을 지우고 싶으면 어떻게 하면 될까요?  
동적 배열 삭제 연산처럼 배웠던 거처럼 인덱스 1 자리에 인덱스 2의 데이터를 저장하고, 인덱스 2에 인덱스 3 데이터를 저장해서 2, 5, 7, 7 이렇게 하면 될 거 같긴 한데요.  
여기서 문제는 인덱스 3에 저장되어 있던 7을 메모리에서 자연스럽게 지울 수 있는 방법이 마땅히 없습니다.  
비었다는 것을 표시하기 위해서 파이썬에서는 None, 다른 언어들에서는 Null 이런 값을 넣는 걸 생각하실 수 있는데요.  
numArray는 정수형 데이터를 4 개를 저장합니다.  
None이나 Null은 정수형이 아닙니다.  
numArray의 인덱스 3에 저장할 수 없습니다.  
정리하자면 배열 numArray에서 인덱스 1을 지우기 위해서는 2, 3, 5, 7의 데이터를 2, 5, 7으로 만드는 게 아니라 2, 5, 7, 7 이런 식으로 밖에 못 만듭니다.  
지우고 싶은 요소를 “자연스럽게” 삭제할 수 없는 거죠.  
  
### 동적 배열 삭제와 차이
배열을 사용하는 동적 배열에서는 어떻게 데이터를 삭제할 수 있는지 생각해볼게요.  
파이썬 리스트의 비밀 레슨 기억나시나요?  
많은 언어들 자체적으로 제공하는 동적 배열은 사용하는 배열의 크기와 사용하는 인덱스 범위를 따로 처리한다고 했습니다.  
동적 배열이 내부적으로 정수 4개를 저장할 수 있는 배열에 2, 3, 5, 7을 저장하고 있다고 할게요.  
동적 배열에서 인덱스 1을 삭제하고 싶으면 인덱스 1에 5를 저장하고, 인덱스 2에 7을 저장합니다.  
그럼 내부적으로는 2, 5, 7, 7 이렇게 저장되어 있을 텐데요.  
그다음에 인덱스 3에 있는 7을 지우는 게 아니라 파이썬 내부적으로 개발자가 접근할 수 있는 인덱스 범위를 0 ~ 2로 만들어 버립니다.  
더 이상 인덱스 3에 접근할 수 없게 만드는 거죠.  
실제로 인덱스 3에 어떤 값이 저장되어 있든 상관없이 개발자는 더 이상 거기 접근할 수 없습니다.  
동적 배열에서 접근할 수 있는 데이터가 2, 5, 7 밖에 없으니까 실질적으로 삭제됐다고 할 수 있는 거죠.  
  
## 배열 퀴즈  
  
질문 1  
다음 중 옳지 않은 내용을 고르세요.  
1 배열은 정의할 때부터 수용 가능 항목 수가 정해져 있고, 바꿀 수 없다.  
2 배열은 인덱스를 통해서 데이터를 저장 및 접근하는 자료 구조다.  
3 배열을 만들면 컴퓨터 메모리에서 사용 가능한 공간에 값들이 순서대로, 그리고 연속적으로 저장된다.  
4 배열의 범위를 벗어나는 인덱스를 사용할 수 있고 사용해도 된다.  
5 배열의 특정 인덱스에 접근해서 항목을 받아오거나 수정하는 데 드는 시간 복잡도는 O(1) 이다.  
  
질문 2  
배열 int_array의 주소가 10000이고, 정수 자료형의 크기가 4 바이트이면, int_array[300]의 주소를 계산해 보세요!  
  
질문 3  
다음 중 옳지 않은 내용을 고르세요.  
1 동적 배열의 끝에 요소를 추가하면 O(n)의 시간 복잡도가 걸리기 때문에 굉장히 비효율적인 연산이다.  
2 동적 배열을 사용하게 되면 낭비하는 공간이 O(n)만큼 생긴다.  
3 동적 배열은 내부적으로 배열을 사용하는 자료 구조다.  
4 동적 배열은 수용 가능 요소 수가 따로 정해져 있지 않기 때문에 데이터 요소들을 추가할 수 있다.  
5 동적 배열의 특정 인덱스에 접근해서 데이터를 받아오거나 수정하는 데 드는 시간 복잡도는 O(1)이다.  

질문 4  
다음 중 동적 배열을 사용하는 게 가장 부적절한 경우를 고르세요.  
1 순위 정보를 담아 놓고, 저장해 놓은 데이터에 접근해야 될 때.  
2 게임 프로그램에서 캐릭터가 죽을 때마다 추가해야 될 때.  
3 온라인 상담소에서 접수가 들어오는 순서대로 저장하고, 가장 앞에 있는 문의부터 처리하고 지워야 될 때.  
  
<br/><br/><br/><br/>
질문 1 정답: 4번  
퀴즈 해설  
배열은 처음 정해 놓은 범위를 벗어나는 인덱스를 사용하면 안 됩니다.  
  
질문 2 정답: 11200  
퀴즈 해설  
배열은 데이터를 연속적이고 순차적으로 저장해 놓기 때문에  
1. 배열의 시작 주소  
2. 저장하는 자료형의 크기  
3. 인덱스  

이 세 가지만 알면 원하는 인덱스의 주소를 계산할 수 있습니다.  
> 배열 시작의 주소 + (인덱스 * 저장하는 데이터 자료형 크기)  

이렇게 원하는 인덱스의 주소를 O(1)으로 계산하면 되고, 이 주소로 해당 메모리에 접근할 수 있습니다.
  
질문 3 정답: 1번  
퀴즈 해설  
보통 추가 연산의 시간 복잡도는 분할 상환 분석을 한 시간 복잡도를 이용합니다.  
최악의 경우 O(n)이 걸리긴 하지만, 분할 상환 분석을 하면 O(1)이 걸리기 때문에 효율적인 연산이라고 볼 수 있습니다.  
  
질문 4 정답: 3번  
퀴즈 해설  
온라인 상담소 문의를 앞 순서부터 처리하고 지워야 되면, 동적 배열의 가장 앞 데이터를 계속해서 삭제해야 됩니다.  
동적 배열의 길이가 n이라고 할 때 가장 앞 데이터를 삭제하면 뒤에 있는 모든 항목들을 한 칸씩 앞으로 복사 붙여넣기를 해야 됩니다.  
O(n)이 걸리는 거죠. 계속해서 O(n)이 걸리는 동작을 하면 비효율적입니다.  
반면 보기 1에서는 동적 배열의 접근 연산을 많이 사용하고, 보기 2에서는 추가 연산을 많이 합니다.  
접근 연산은 O(1), 추가 연산은 분할 상환 분석을 했을 때 O(1)이 걸립니다.  
보기 3보다 효율적이게 동적 배열을 사용하는 거죠.
