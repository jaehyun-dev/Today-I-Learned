# 5 해시 테이블
23.01.07  

## 01. key-value 데이터  

배열과 링크드 리스트는 데이터를 순서대로 저장하므로 순서관계가 중요함  
하지만 모든 데이터에 순서관계가 있는 것은 아님  

101호: 최지웅  
711호: 김현승  
942호: 손동욱  
204호: 강영훈  
302호: 성태호  

호수과 입주민의 관계.  
어떤 호수에 어떤 입주민이 살고 싶은지 알고 싶을 때, 순서에 큰 의미는 없음.  

순서가 아니라 이미 알고 있는 정보를 이용하여 저장한 정보를 검색할 수 있는 데이터 유형을 **key-value 데이터**라고 부름.  
- 하나의 key과 그 key에 해당하는 value를 합쳐서: key - value 쌍  
- 하나의 key에는 하나의 value만 있어야 된다!  

이번 챕터에서 배울 내용  
- key - value 데이터를 어떻게 저장할 수 있는지
- key를 이용해서 저장한 value를 어떻게 찾을 수 있는지

<br/><br/>

## 02. Direct Access Table  
배열 인덱스 접근: $O(1)$  
인덱스는 데이터의 순서에 해당하는 정보. 항상 0부터 배열의 크기 - 1까지의 자연수.  
인덱스를 순서가 아니라 key라고 생각하면 직관적으로 key - value 쌍을 저장할 수 있음.  

101호: 최지웅  
711호: 김현승  
942호: 손동욱  
204호: 강영훈  
302호: 성태호  

위 예시에서, 가장 큰 호수인 942를 마지막 인덱스로 갖는 배열을 만들고, 각 호수를 인덱스로, 입주민을 값으로 저장하면 key(인덱스)를 이용해 모든 value(입주민)에 $O(1)$으로 접근 가능  
이런 방식을 Direct Access Table이라고 부름  
단점: 공간을 너무 많이 낭비할 수 있음  

<br/><br/>

## 03. 해시 테이블 개념  
Direct Access Table의 단점인 공간 낭비를 개선하여 시간과 공간을 모두 효율적으로 사용할 수 있는 자료구조  

### 해시 함수
특정 값을 원하는 범위의 자연수로 바꿔주는 함수  
해시 함수를 이용하면 key가 아무리 커도 항상 원하는 범위 사이의 자연수로 바꿀 수 있음  

### 해시 테이블(Hash Table)
해시 함수와 배열을 같이 사용하는 자료구조  
key를 바로 인덱스로 하지 않고, 해시 함수에 넣어 return된 값을 인덱스로 사용함  

### 방법:  
1. 원하는 크기의 배열을 만듦
2. key-value 쌍에서 key를 해시 함수에 넣어 원하는 범위 안의 값으로 return 받음  
3. 배열에 return된 값을 인덱스로 하여, key와 value를 함께 저장함  
4. 접근할 때는, 원래의 key가 들어오면 해시 함수에 넣어 return된 값으로 배열에서 접근하여 value를 가져옴  

<br/><br/>

## 04. 해시 함수
영상에서는 그냥 해시 함수를 key를 넣었을 때 원하는 범위의 자연수를 리턴해주는 어떤 함수라고만 얘기했었는데요. 이번에는 해시 함수에 대해서 조금 더 알아보고 해시 함수를 구현할 수 있는 가장 간단한 방법들에 대해서 살펴볼게요.
```
101호: 최지웅
204호: 강영훈
302호: 성태호
711호: 김현승
942호: 손동욱
```
먼저 주어진 key를 원하는 범위의 자연수로 바꿔서 리턴해주는 것 말고 다른 해시 함수의 조건들을 볼게요.
1. 한 해시 테이블의 해시 함수는 결정론적이어야 된다.
- 똑같은 key를 넣었을 때는 항상 똑같은 결과가 나와야 한다는 건데요. 942를 해시 함수에 넣을 때 어쩔 때는 5이 나오고 어쩔 때는 10이 나오고 이러면 안 된다는 거죠. 942를 넣으면 항상 똑같은 결과가 나와야 됩니다.
2. 결과 해시값이 치우치지 않고 고르게 나온다.
- 그러니까 해시 함수에 101, 204, 302, 711, 942나 아무 숫자를 넣었을 때 항상 40만 나오면 안 된다는 거죠. 원하는 범위가 0 부터 100까지의 자연수면, 이 사이에 아무 두 숫자가 나올 확률이 최대한 비슷해야 됩니다..
3. 빨리 계산할 수 있어야 된다.
- 해시 테이블은 모든 연산을 할 때마다 해시 함수를 써야 되는데요. 해시 함수가 비효율적이면 해시 테이블도 비효율적일 수밖에 없겠죠?

이 조건들이 조금 어렵게 느껴질 수도 있는데요. 사실 해시 함수를 만드는 건 생각보다 어렵지 않습니다. 이번 레슨에서는 가장 간단한 두 가지만 알아볼게요.

### 나누기 방법
가장 직관적이면서 쉬운 방법은 나누기 방식인데요. 자연수 key를 해시 테이블의 크기로 나눈 나머지를 리턴하는 함수입니다. 그러니까 저장해야 되는 키가 40, 120, 788, 2307이고 배열의 크기가 200이라고 할게요. 그럼 그냥 key를 200으로 나누어서 남는 나머지를 리턴한다는 거죠. 40을 넣으면 40, 120은 120, 788 은 188, 2307은 107가 리턴됩니다.

나누기 방법을 코드로 나타내면 이렇게 됩니다.

```python
def hash_function_remainder(key, array_size):
    """해시 테이블의 key를 나누기 방법으로 0 ~ array_size - 1 범위의 자연수로 바꿔주는 함수"""
    return key % array_size


print(hash_function_remainder(40, 200))
print(hash_function_remainder(120, 200))
print(hash_function_remainder(788, 200))
print(hash_function_remainder(2307, 200))
```
```
40
120
188
107
```
어떤 키가 들어와도 0 ~ 원하는 정수 범위의 자연수로 바꿔줍니다.

### 곱셈 방법
다음으로 볼 방법은 곱셈 방법입니다. 곱셈 방법은 나누기 방법보다는 조금 까다로운데요.

이해를 돕기 위해 예시로 key가 200이고 사용하려는 배열 크기가 30이라고 할게요.

1. 먼저 0 < a < 10<a<1 인 아무 값 a를 정합니다. 일단 임의로 0.6666로 정할게요
2. 그다음에 이 a에 key를 곱합니다. 그러니까 0.666에 200을 곱하면 133.32이 되는데 이때 정수 부분은 버리고 소수 부분만 남깁니다. 0.32가 남습니다.
3. 마지막으로 남은 소수 부분에 배열의 크기를 곱해줍니다. 0.32 * 30 하면 9.6이 되죠. 이번엔 소수점 부분을 버리고 9만 남깁니다.

단계가 조금 많아서 헷갈릴 수도 있는데요. 왜 이 방법이 원하는 범위의 자연수를 리턴하는지 생각해볼까요? a와 key를 곱한 값의 정수 부분을 버리면 그 결과 값은 0.xxxx 이런 식으로 0과 1 사이의 소수가 나올 수밖에 없겠죠? 0과 1 사이의 소수에 테이블의 크기를 곱해버리면, 다시 0과 테이블 크기 사이의 수가 나오죠. 그러니까 0.0001에 테이블 크기 30을 곱하면 0.003이 나오고 0.9999에 테이블 크기 30을 곱하면 29.997이 나오는데요. 항상 0보다 크거나 같고 테이블 크기인 30보다는 작은 숫자가 나옵니다. 그리고 여기서 소수점 뒷자리를 버리니까 원하는 범위의 자연수를 구할 수 있습니다.

곱셈 방법도 코드로 작성해 볼까요?

```python
def hash_function_multiplication(key, array_size, a):
    """해시 테이블의 key를 곱셈 방법으로 0 ~ array_size - 1 범위의 자연수로 바꿔주는 함수"""
    temp = a * key # a와 key를 곱한다
    temp = temp - int(temp) # a와 key를 곱한 값의 소숫점 오른쪽 부분만 저장한다
    
    return int(array_size * temp) # temp와 배열 크기를 곱한 수의 자연수 부분만 리턴한다
        

print(hash_function_multiplication(40, 200, 0.61426212))
print(hash_function_multiplication(120, 200, 0.61426212))
print(hash_function_multiplication(788, 200, 0.61426212))
print(hash_function_multiplication(2307, 200, 0.61426212))
```
```
114
142
7
20
```

### 정리
나누기 방법과 곱셈 방법은 해시 함수로 사용할 수 있는 가장 간단한 두 예시였는데요. 사실 key를 받아서 원하는 범위의 자연수를 리턴하면서:
1. 결정론적이어야 된다.
2. 원하는 범위의 자연수 하나하나가 리턴될 확률이 최대한 비슷해야 된다.
3. 빨리 계산을 할 수 있어야 된다.

이 세 조건을 만족하는 아무 함수나 만들면 해시 함수로 이용할 수 있습니다.

<br/><br/>

## 05. 파이썬 hash 함수

### 파이썬 hash 함수
파이썬 언어도 내부적으로 hash라는 함수를 제공합니다. 근데 이건 우리가 방금 배운 해시 함수랑 조금 다른데요. 파이썬 해시 함수는 파라미터로 받은 값을 그냥 아무 정수로만 바꿔주는 함수입니다.

저희가 배웠던 해시 함수와는 달리 특정 범위 안에 있는 정수가 아니라 아무 정수로 바꿔주죠.

정수형, 소수형, 문자열 타입에 hash 함수를 호출했을 때 나오는 결과를 살펴볼게요.
```python
# 정수 값
print(hash(12345))  # 12345
print(hash(12345))  # 12345

# 다른 정수 값
print(hash(12346))  # 12346 
```
```python
# 소수 값
print(hash(15.1234))  # 284541027336970255
print(hash(15.1234))  # 284541027336970255

# 다른 소수 값
print(hash(81.1234))  # 284541027336978513
```
```python
# 문자열
print(hash("파이썬"))  # -8002119629611903017
print(hash("파이썬"))  # -8002119629611903017

# 다른 문자열
print(hash("자바"))  # -8553573703343279427
```
이런식으로 같은 값을 넣으면 항상 같은 정수를 리턴해주는 함수입니다. 이 때 중요한 점은 hash 함수에 서로 다른 두 값을 파라미터로 넣었을 때 같은 정수가 리턴될 수 없다는 건데요.

그러니까 hash("파이썬")이 -8002119629611903017이 리턴됐으면, 다른 그 어떤 값을 파라미터로 넣어도 -8002119629611903017가 나올 수 없습니다. 데이터를 자신만의 고유한 정수 값으로 바꿔주는 함수죠.

지금까지는 해시 함수에 key를 정수형으로만 생각했잖아요? 다른 타입의 데이터들을 자신만의 고유한 정수 값으로 바꿀 수 있으면 이제 정수 뿐만 아니라 다른 자료형들도 key로 사용할 수 있습니다. 해시 테이블에 저장할 수 있는 종류의 데이터를 더 폭 넓게 늘릴 수 있다는 말이죠. 과제에서 해시 테이블을 직접 구현할 때 이 hash 함수를 사용해서 해시 테이블에 key가 문자열인 데이터를 저장할 건데요. 그 때 그냥 “아 문자열을 고유한 정수 값으로 바꿔주는구나”라고 이해하시면 됩니다!

### hash 함수의 한계
여기서 조심해야 되는 게 하나 있는데요. 파이썬 hash 함수는 언어 자체적으로는 불변 타입 자료형에만 사용할 수 있습니다.

파이썬에서 여러분이 가장 많이 접해봤을 대표적인 불변 타입 자료형은:
- 불린형
- 정수형
- 소수형
- 튜플
- 문자열

이 정도가 있는데요. 이런 타입의 자료형만 hash 함수의 파라미터로 넘겨줄 수 있습니다.

<br/><br/>

23.01.08  
## 06. 해시 테이블 충돌과 Chaining 개념

key-value쌍을 저장하기 위해 key를 해시 함수에 넣었는데, 서로 다른 key 값이 같은 해시함수 return 값이 나올 수가 있음  
한 인덱스에 두 개의 key-value 쌍을 저장해야 되는 경우가 생김  
이미 사용하고 있는 인덱스에 새로운 key-value 쌍을 또 저장해야 되는 경우를 충돌(Collision)이 일어났다고 표현함  
충돌을 해결하는 방법 중 하나인 Chaining에 대해 알아볼 것  

### Chaining
직역하면 쇠사슬로 묶는 것  
배열 인덱스에 링크드 리스트를 저장해서 충돌을 해결함  

```python
class Node:
    """링크드 리스트 노드"""
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.next = next
```

이렇게 노드를 만들어서, 만약 key 값에 같은 hash 함수 return값이 나오면 해당 인덱스에 링크드 리스트 노드를 그대로 이어붙이면 됨

<br/><br/>

23.01.09  
## 07. Chaining에서 사용하는 링크드 리스트

전 레슨에서도 보았듯이 Chaining을 이용하면 해시 테이블에서 충돌이 일어나도 key - value 쌍들을 모두 저장할 수 있습니다. 이번 챕터에서는 해시 테이블의 개념을 배우고 직접 구현해볼 건데요. 지난 챕터에서 만들었던 링크드 리스트 클래스도 한 번 해시 테이블에서 사용할 수 있게 바꿔볼게요.

더블리 링크드 리스트를 이용하겠습니다.

### Node 클래스
여기서는 크게 바꿀 건 없는데요. 영상에서 본 것처럼 그냥 링크드 리스트 노드가 변수 data 대신 key와 value를 저장하도록 해줄게요.
```python
class Node:
    """링크드 리스트의 노드 클래스"""
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.next = None  # 다음 노드에 대한 레퍼런스
        self.prev = None  # 전 노드에 대한 레퍼런스
```
### LinkedList 클래스
링크드 리스트 클래스에서는 필요한 메소드들만 가지고 와서 쓰면 됩니다. 노드 클래스랑 마찬가지로 그대로 사용할 수는 없고요. 조금씩 고쳐서 써야합니다.

다행히 \_\_init\_\_ 메소드는 바꾸지 않아도 됩니다.
```python
class LinkedList:
    """링크드 리스트 클래스"""
    def __init__(self):
        self.head = None  # 링크드 리스트의 가장 앞 노드
        self.tail = None  # 링크드 리스트의 가장 뒤 노드
```
#### 탐색 메소드
```python
def find_node_with_key(self, key):
    """링크드 리스트에서 주어진 데이터를 갖고있는 노드를 리턴한다. 단, 해당 노드가 없으면 None을 리턴한다"""
    iterator = self.head   # 링크드 리스트를 돌기 위해 필요한 노드 변수

    while iterator is not None:
        if iterator.key == key:
            return iterator

        iterator = iterator.next

    return None
```
탐색 메소드는 이제 특정 데이터를 갖는 노드를 찾는 게 아니라 특정 key를 갖는 노드를 찾습니다. 이에 맞게 링크드 리스트를 처음부터 끝까지 돌면서 원하는 key를 갖는 노드를 리턴해주도록 수정해줍니다. 코드에서는 기존에 data 변수를 다 key로 바꿔주면 되죠.

#### 추가 (맨 뒤 삽입) 메소드
```python
def append(self, key, value):
    """링크드 리스트 추가 연산 메소드"""
    new_node = Node(key, value)

    # 빈 링크드 리스트라면 head와 tail을 새로 만든 노드로 지정
    if self.head is None:
        self.head = new_node
        self.tail = new_node
    # 이미 노드가 있으면
    else:
        self.tail.next = new_node  # tail의 다음 노드로 추가
        new_node.prev = self.tail
        self.tail = new_node  # tail 업데이트
```
추가 메소드 append는 이제 파라미터로 data 변수 대신 key와 value를 받습니다. 링크드 리스트에 데이터를 더해줄 때는 항상 새로운 노드를 만들어줘야 되는데요. 파라미터로 받은 정보를 key와 value를 갖는 새로운 노드를 만들어줍니다. 새 노드를 링크드 리스트에 연결해주는 부분 코드는 똑같습니다.

#### 삭제 메소드
```python
def delete(self, node_to_delete):
    """더블리 링크드 리스트 삭제 연산 메소드"""

    # 링크드 리스트에서 마지막 남은 데이터를 삭제할 때
    if node_to_delete is self.head and node_to_delete is self.tail:
        self.tail = None
        self.head = None

    # 링크드 리스트 가장 앞 데이터 삭제할 때
    elif node_to_delete is self.head:
        self.head = self.head.next
        self.head.prev = None

    # 링크드 리스트 가장 뒤 데이터 삭제할 떄
    elif node_to_delete is self.tail:
        self.tail = self.tail.prev
        self.tail.next = None

    # 두 노드 사이에 있는 데이터 삭제할 때
    else:
        node_to_delete.prev.next = node_to_delete.next
        node_to_delete.next.prev = node_to_delete.prev
```
원래 링크드 리스트 삭제 메소드에서는 노드를 삭제할 때 삭제하는 노드의 데이터를 리턴했는데요. 이 부분을 빼줄게요.

나머지 부분은 바꿔줄 필요 없습니다. 더블리 링크드 리스트 삭제 메소드는 어차피 노드가 주어졌을 때 그 노드를 링크드 리스트에서 삭제해주죠? 기존 data 변수나 key, value 변수와 전혀 관계가 없는 메소드기 때문에 나머지 코드를 바꿀 필요가 없는 거죠.

#### 문자열 메소드
문자열 메소드는 출력 형식을 조금 바꿔줄게요.
```python
def __str__(self):
    """링크드 리스트를 문자열로 표현해서 리턴하는 메소드"""
    res_str = ""

    # 링크드 리스트 안에 모든 노드를 돌기 위한 변수. 일단 가장 앞 노드로 정의한다.
    iterator = self.head

    # 링크드 리스트 끝까지 돈다
    while iterator is not None:
        # 각 노드의 데이터를 리턴하는 문자열에 더해준다
        res_str += "{}: {}\n".format(iterator.key, iterator.value)
        iterator = iterator.next # 다음 노드로 넘어간다

    return res_str
```
원래는 링크드 리스트에 2, 3, 5, 7, 11이 들어있으면 이런 식으로 링크드 리스트의 모든 data 변수를 한 줄에 순서대로 출력했잖아요?
```
2 | 3 | 5 | 7 | 11
```
이제는 key - value 쌍을 저장하니까 출력 형식도 바꿔주는 거죠.

링크드 리스트에 101: “최지웅”, 204: “강영훈”, 305: “성태호”이 들어 있다고 할게요. 그러면 아래와 같이 이 링크드 리스트를 출력했을 때 한 줄에 한 key, value 쌍 하나씩 나오도록 바꿔준 거죠.
```
101: 최지웅
204: 강영훈
305: 성태호
```

<br/><br/>

## 08. Chaining을 쓰는 해시 테이블 탐색 연산

### 해시 테이블 연산
- 탐색
- 삽입
- 삭제

### 해시 테이블 탐색  
- 배열과 링크드 리스트는 접근 연산이 있지만 해시 테이블은 순서 관계가 없으므로 접근 연산을 쓰지 않고 탐색 연산을 사용함  
- 원하는 key에 해당하는 value를 찾는 연산
- 예시: 101: "최지웅"을 찾고 싶을 때
    - 101을 해시함수에 넣어서 20이라는 값을 return 받으면, 배열의 인덱스 20에 접근해 링크드 리스트를 받아온다.
    - 링크드 리스트의 가장 앞 노드부터, 끝까지 원하는 key가 있는지 확인한다.
    - 원하는 데이터를 찾으면 value를 return한다.
- 탐색 연산 시간 복잡도
    - 해시 함수 계산: $O(1)$
    - 배열 인덱스 접근: $O(1)$
    - 링크드 리스트 탐색: $O(n)$
    - 총합: $O(1 + 1 + n) = O(n)$

<br/><br/>

## 09. Chaining을 쓰는 해시 테이블 삽입 연산

### 해시 테이블 삽입
- key - value 데이터 쌍을 저장, 또는 수정
- 예시: 205: "강영훈"을 삽입하고 싶을 때
    - 205를 해시함수에 넣어서 20이라는 값을 return 받으면, 배열의 인덱스 20에 접근한다.
    - 저장된 링크드 리스트에 원하는 키를 갖는 노드가 있는지 탐색한다.(key-value 쌍에는 하나의 key에 하나의 value만 대응되어야 하기 때문)
    - 링크드 리스트를 탐색하다가 같은 key가 있으면 value 데이터를 새로운 데이터로 바꿔준다.
    - 탐색에 실패했다면 링크드 리스트에 해당 key가 없는 것이니 링크드 리스트 맨 마지막에 노드를 붙여준다.
- 삽입 연산 시간 복잡도
    - 해시 함수 계산: $O(1)$
    - 배열 인덱스 접근: $O(1)$
    - 링크드 리스트 노드 탐색: $O(n)$
    - 링크드 리스트 저장 / 노드 수정: $O(1)$
    - 총합: $O(1 + 1 + n + 1) = O(n)$

<br/><br/>

## 10. Chaining을 쓰는 해시 테이블 삭제 연산

### 해시 테이블 삭제
- 원하는 key에 대한 key-value 데이터 쌍을 삭제
- 예시: key 205에 해당하는 노드를 삭제하고 싶을 때
    - 205를 해시함수에 넣어서 20이라는 값을 return 받으면, 배열의 인덱스 20에 접근한다.
    - 저장된 링크드 리스트에 원하는 key에 해당하는 노드를 탐색한다.
    - 원하는 노드를 찾으면 링크드 리스트에서 지워준다.
- 삭제 연산 시간 복잡도
    - 해시 함수 계산: $O(1)$
    - 배열 인덱스 접근: $O(1)$
    - 링크드 리스트 노드 탐색: $O(n)$
    - 링크드 리스트 삭제: $O(1)$
    - 총합: $O(1 + 1 + n + 1) = O(n)$


<br/><br/>

## 11. (중요!) Cahining을 쓰는 해시 테이블 평균 시간 복잡도
| 동작 (Operation) | 시간 복잡도 |
|:----------------:|:-----------:|
|   탐색 (search)  |   $O(n)$  |
|    저장 (save)   |   $O(n)$  |
|   삭제 (delete)  |   $O(n)$  |

해시 테이블의 탐색, 저장, 삭제 연산들은 이런 시간 복잡도를 갖습니다. 세 연산 모두 key를 이용해서 저장된 링크드 리스트 노드를 탐색하는 과정을 포함하는데요. 링크드 리스트 탐색 연산은 링크드 리스트의 길이에 비례합니다.

해시 테이블이 사용하는 링크드 리스트의 길이가 가장 길 경우는, 저장하는 모든 key - value 데이터 쌍이 하나의 링크드 리스트에 저장되는 경우입니다. 해시 테이블에 저장된 key - value 쌍의 수가 $n$이라고 하면 최악의 경우 링크드 리스트의 길이도 $n$인 거죠. 길이가 $n$인 링크드 리스트를 탐색하는 데 걸리는 시간은 $O(n)$입니다. 세 연산 모두 링크드 리스트를 탐색하는 단계를 포함합니다. 그렇기 때문에 세 연산은 최악의 경우 $O(n)$가 걸리죠.

근데 해시 테이블의 모든 key - value 쌍이 모두 같은 링크드에 저장되는 건 거의 일어나지 않는 일일 텐데요. 이걸 이용해서 해시 테이블의 연산들을 평가하는 건 좀 불공평합니다.

동적 배열 추가 동작은 분할 상환 분석을 이용해서 조금 더 합리적으로 시간 복잡도를 구했죠? 이번에는 최악의 경우만으로 연산을 효율성을 평가하는 게 불공평할 때 사용하는 방법 중 하나인 평균 시간 복잡도를 이용해서 해시 테이블 연산들을 분석해 볼게요.

### 해시 테이블 연산들 분해 분석
먼저 해시 테이블 연산들의 단계를 나눠서 볼까요?
| 연산 (Operation) |                                                        부분 단계들                                                       |  각 부분 단계 시간 복잡도  |
|:----------------:|:------------------------------------------------------------------------------------------------------------------------:|:--------------------------:|
|   탐색 (search)  |                             1. 해시 함수 계산<br>2. 배열 인덱스 접근<br>3. 링크드 리스트 탐색                            |    $O(1 + 1 + n)$    |
|    저장 (save)   | 1. 해시 함수 계산<br>2. 배열 인덱스 접근<br>3. 링크드 리스트 탐색<br>4. 탐색한 노드 수정 or 링크드 리스트 앞에 노드 삽입 | $O(1 + 1 + n + 1)$ |
|   삭제 (delete)  |                 1. 해시 함수 계산<br>2. 배열 인덱스 접근<br>3. 링크드 리스트 탐색<br>4. 탐색한 노드 삭제                 | $O(1 + 1 + n + 1)$ |

각 연산의 단계들을 나눠서 보면, 링크드 리스트를 탐색하는 데 $O(n)$이 걸리고 나머지 부분 단계들은 다 $O(1)$이 걸리는 걸 알 수 있습니다.

그리고 링크드 리스트 탐색이 $n$에 비례하는 이유는 모든 데이터가 하나의 링크드 리스트에 저장된 경우 때문이죠?

배열에 저장된 각 링크드 리스트의 길이가 평균적으로는 $n$ 이 아니라 다른 값, 예를 들어 $average$ $length$라는 값이라면 어떨까요? 나머지 부분 연산들의 시간 복잡도가 $O(1)$ 밖에 걸리지 않기 때문에 세 연산 모두 링크드 리스트 탐색에 걸리는 시간, $O(average$ $length)$가 걸린다고 할 수 있습니다.

해시 테이블 연산의 시간 복잡도는 평균적으로는 이 $average$ $length$에 비례하는 거죠.

이 노트에서는 인덱스에 저장되어 있는 링크드 리스트들의 평균 길이 $average$ $length$가 어떻게 되는지 알아볼 건데요. 이 평균 길이를 이용해서 해시 테이블 연산들의 평균 시간 복잡도를 재평가해볼게요.

### 배열에 저장되어 있는 링크드 리스트들의 평균 길이
일단 일반적인 경우에 우리가 어떤 값들의 평균을 어떻게 구하는지 되짚어 볼게요. 가장 대표적인 예시인 평균 성적을 구하는 방법을 볼게요.

평균 성적을 구할 때는 어떻게 구하죠? 모든 학생들의 성적을 다 합한 다음에 모든 학생 수로 나눕니다. 그러니까 5 명의 학생이 100점, 95점, 90점, 85점, 80점을 받았다고 합시다. 그럼 100 + 95 + 90 + 85 + 80을 총 학생 수인 5으로 나눠서 “평균 성적은 90이다” 라고 하는데요.

마찬가지로 각 인덱스에 저장된 링크드 리스트들의 평균 길이를 구해볼게요.

생각보다 간단한데요. 총 들어 있는 key - value 쌍 수를 배열 인덱스 수로 나눠주면 됩니다.

그러니까 key - value 쌍은 10 개, 그리고 해시 테이블이 사용하는 배열의 크기가 20이면, $\frac{10}{20}$ 이렇게 해서 사용되는 링크드 리스트의 길이는 평균적으로 0.5인 거죠.

좀 더 일반화해서 표현해볼까요?
1. 해시 테이블에 총 들어가 있는 key - value 쌍의 수: $n$
2. 해시 테이블이 사용하는 배열의 크기: $m$

라고 하면, 링크드 리스트들의 평균 길이는 $\frac{n}{m}$라고 할 수 있습니다.

앞에서 봤듯이, 해시 테이블의 세 연산의 시간 복잡도는 모두 링크드 리스트의 길이에 비례합니다. 이 링크드 리스트의 길이가 최악의 경우 $n$이어서 각 연산의 평균 시간 복잡도도 $O(n)$이였던 건데요.

링크드 리스트들의 평균 길이가 $\frac{n}{m}$이면 각 연산들은 “평균적으로 $O(\frac{n}{m})$가 걸린다”라고 표현할 수 있겠죠?

여기까지 이해하셨나요? 좋습니다.

여기서 중요한 한 가지 가정을 하는데요. 해시 테이블을 만들 때 항상 충분히 여유롭게 총 저장하는 key - value 쌍 수와 해시 테이블이 사용하는 배열의 크기를 비슷하거나 작다고 가정을 합니다.

그러니까 해시 테이블을 사용할 때는 항상 어느 정도까지는 $n = m$ 이렇게 유지 시켜준다는 약속을 하는 건데요. 이 약속만 지켜주면, 해시 테이블 연산들이 $O(\frac{n}{m})$이 걸리니까 $n = m$을 적용하면 다시 $O(1)$이라고 표현할 수 있습니다.

### 해시 테이블 평균 시간 복잡도 종합
| 연산 (Operation) | 평균 시간 복잡도 |
|:----------------:|:----------------:|
|   탐색 (search)  |     $O(1)$     |
|   저장 (insert)  |     $O(1)$     |
|   삭제 (delete)  |     $O(1)$     |

해시 테이블 평균 시간 복잡도를 위 표처럼 나타낼 수 있는 거죠. 실제로 해시 테이블을 사용할 때는 대부분의 경우 세 연산들이 그냥 $O(1)$이 걸린다고 가정하고 사용합니다.

분할 상환 분석할 때와 마찬가지로 이 연산들의 최악의 경우 시간 복잡도가 $O(n)$인 것은 변하지 않습니다. 생각해보면 모든 key - value 쌍이 하나의 인덱스에 저장되는 일이 일어나기 쉽지는 않지만 실제 일어날 수도 있는 일이잖아요?

이런 혼란을 줄이기 위해서 좀 더 정확하게는

“해시 테이블 삽입, 삭제, 탐색 연산들은 최악의 경우 $O(n)$이 걸리지만, 평균적으로는 $O(1)$이 걸린다”

라고 합니다.

<br/><br/>

## 12. Chaining을 쓰는 해시 테이블 구현 I

### 실습 설명
Chaining을 이용하는 해시 테이블 탐색과 삽입 연산들을 구현해 볼게요.

이번 과제에서 사용하는 링크드 리스트 클래스는 전에 노트에서 해시 테이블에서 사용할 수 있게 바꿔놓은 더블리 링크드 리스크 클래스입니다. 혹시 링크드 리스트 코드에서 이해가 안 되시는 부분이 있다면 전 노트를 참고하세요!

탐색 연산은 look_up_value라는 이름의 메소드로 구현할게요. 파라미터로는 탐색하려는 key를 받습니다. 파라미터 key에 해당하는 value를 리턴합니다.

삽입 연산은 insert라는 이름의 메소드로 구현합시다. 파라미터로는 key와 value 데이터 쌍을 각각 받습니다. 파라미터로 받은 key - value 쌍을 해시 테이블 안에 저장합니다. 단 이미 key에 해당하는 key - value 데이터 쌍을 저장했다면, 그 데이터 쌍의 value만 새로운 value로 바꿔 줍니다.

(두 메소드 모두 main.py 파일에서 작성하시면 됩니다!)

여러분들이 좀 더 수월하게 과제를 하실 수 있도록 미리 메소드 몇 개를 정의해놨는데요. 하나씩 살펴볼게요.

#### \_\_init\_\_ 메소드
```python
def __init__(self, capacity):
    self._capacity = capacity  # 파이썬 리스트 수용 크기 저장
    self._table = [LinkedList() for _ in range(self._capacity)]  # 파이썬 리스트 인덱스에 반 링크드 리스트 저장
```
해시 테이블 클래스는 인스턴스 변수로 \_capacity와 \_table을 받습니다.
- \_capacity는 해시 테이블(이 사용하는 배열)의 크기입니다. 해시 테이블 인스턴스를 만들 때 파라미터 capacity를 받아서 self.\_capacity에 저장합니다.
- \_table은 해시 테이블에서 사용하는 파이썬 리스트입니다. 크기는 \_capacity 이며 각 인덱스에는 비어 있는 링크드 리스트를 저장합니다. 저희는 배열 대신 파이썬 리스트를 이용해서 해시 테이블을 구현해 볼게요.
- 두 인스턴스 변수는 외부에서 접근하면 안 된다는 걸 알리기 위해서 앞에 \_를 붙입니다.

예를 들어 아래처럼 해시 테이블 인스턴스를 만들었다고 할게요.
```python
test_scores = HashTable(50)
```
- 일단 self.\_capacity에는 50이 저장됩니다.
- 그리고 self.\_table이 만들어집니다. self.\_table은 0 ~ 49까지 인덱스를 갖는 파이썬 리스트가 생성됩니다. 각 인덱스에는 비어 있는 링크드 리스트가 저장됩니다.

#### 해시 함수
```python
def _hash_function(self, key):
    """
    주어진 key에 나누기 방법을 사용해서 해시된 값을 리턴하는 메소드
    주의 사항: key는 파이썬 불변 타입이어야 한다.
    """
    return hash(key) % self._capacity
```
메소드 \_hash_function은 파라미터로 key를 받습니다. 파이썬 hash 함수는 불변 타입의 값을 고유 정수값으로 변환해 주는데요. 이 정수에 나누기 방법을 이용해서 저희 해시 테이블의 해시 함수로 이용합니다. 해시 테이블의 해시 함수도 외부에서 사용하지 말라는 표시로 앞에 \_를 써줍니다.

self.\_capacity 가 50이라면 무조건 0 ~ 49 사이의 자연수가 리턴됩니다.

#### 문자열 메소드
```python
def __str__(self):
    """해시 테이블 문자열 메소드"""
    res_str = ""

    for linked_list in self._table:
        res_str += str(linked_list)
    
    return res_str[:-1]
```
문자열 메소드는 self.\_table을 한 인덱스씩 돌면서 각 인덱스에 저장된 링크드 리스트의 데이터를 출력합니다. 해시 테이블 안에 저장된 모든 key, value 데이터 쌍을 출력할 수 있습니다.

### 실습 결과
- 해시 테이블은 순서가 저장되지 않기 때문에 순서는 출력 예시와 다를 수 있습니다.
```
현승: 85
태호: 90
지웅: 99
규식: 97
신의: 88
영훈: 90
동욱: 87
85
90
90
현승: 10
태호: 20
지웅: 99
규식: 97
신의: 88
영훈: 30
동욱: 87
```

### 해설
본격적으로 각 연산들을 메소드로 구현해 보기 전에 먼저 각 연산들에서 반복적으로 쓰는 코드를 메소드로 정의해 줄게요. 자주 사용하는 코드를 묶어서 메소드로 정의하면 코드를 좀 더 깔끔하게 쓸 수 있습니다.

#### 헬퍼 메소드 1: \_get_linked_list_for_key()
```python
def _get_linked_list_for_key(self, key):
        """주어진 key에 대응하는 인덱스에 저장된 링크드 리스트를 리턴하는 메소드"""
        hashed_index = self._hash_function(key)

        return self._table[hashed_index]
```
\_get_linked_list_for_key 메소드는 파라미터로 key를 받아서 그 key에 해당하는 인덱스에 있는 링크드 리스트를 리턴합니다.

코드를 살펴보면 해시 함수에 key를 넣어서 나온 결과 값을 변수 hashed_index에 저장합니다.

그리고 내부적으로 배열로 사용하는 self.\_table의 hashed_index 인덱스에 있는 링크드 리스트를 리턴해 줍니다.

#### 헬퍼 메소드 2: \_look_up_node()
```python
def _look_up_node(self, key):
        """파라미터로 받은 key를 갖고 있는 노드를 리턴하는 메소드"""
        linked_list = self._get_linked_list_for_key(key)
        return linked_list.find_node_with_key(key)
```
\_look_up_node 메소드는 파라미터로 key를 받아서 그 key를 가지고 있는 링크드 리스트 노드를 리턴합니다.

첫 번째 줄에서는 배열의 원하는 인덱스에 있는 링크드 리스트를 가지고 옵니다.
두 번째 줄에서는 이 링크드 리스트 안에서 원하는 key를 갖고 있는 노드를 탐색해서 리턴합니다.
- find_node_with_key 메소드는 링크드 리스트안에 파라미터로 받은 key가 없으면 None을 리턴합니다.

#### 탐색 연산: look_up_value() 메소드
```python
def look_up_value(self, key):
        """
        주어진 key에 해당하는 데이터를 리턴하는 메소드
        """
        return self._look_up_node(key).value
```
look_up_value() 메소드는 헬퍼 메소드만 써서 작성할 수 있습니다.

먼저, 찾으려는 key를 파라미터로 받습니다. \_look_up_node 메소드를 이용해서 원하는 key에 해당하는 노드를 찾습니다. 이 노드의 value 변수를 리턴합니다.

이미 써놓은 헬퍼 메소드를 잘 이용하기만 하면 되니까 쉽죠?

#### 삽입 연산: insert() 메소드
```python
def insert(self, key, value):
    """
    새로운 key - value 쌍을 삽입시켜주는 메소드
    이미 해당 key에 저장된 데이터가 있으면 해당 key에 해당하는 데이터를 바꿔준다
    """
    existing_node = self._look_up_node(key)  # 이미 저장된 key인지 확인한다

    if existing_node is not None:
        existing_node.value = value  # 이미 저장된 key면 데이터만 바꿔주고
    else:
        # 없는 key면 링크드 리스트에 새롭게 삽입시켜준다
        linked_list = self._get_linked_list_for_key(key)
        linked_list.append(key, value)
```
key - value 데이터는 하나의 key에 두 개의 value를 저장하면 안 되잖아요? 그래서 해시 테이블 삽입 연산에서는 이미 저장한 키인지 아닌지를 확인해야 합니다.

헬퍼 메소드 \_look_up_node 메소드를 이용해서 파라미터 key를 갖고 있는 노드를 탐색합니다. 이미 원하는 key에 대한 key - value 쌍을 저장했으면 변수 existing_node에 노드가 저장되고, 아니면 None 이 저장되겠죠?

파라미터로 받은 key가 이미 저장한 데이터 쌍이라면, existing_node의 변수 value를 파라미터로 받은 value로 바꿔 줍니다.

파라미터 key에 대한 데이터가 저장되어 있지 않다면 아래 내용들을 수행합니다.
1. 원하는 인덱스에 저장된 링크드 리스트를 받아 온다.
2. 이 링크드 리스트에 새로운 key - value 쌍을 추가한다.

### 모범 답안
```python
from HDLL import LinkedList

class HashTable:
    def __init__(self, capacity):
        self._capacity = capacity  # 파이썬 리스트 수용 크기 저장
        self._table = [LinkedList() for _ in range(self._capacity)]  # 파이썬 리스트 인덱스에 반 링크드 리스트 저장

    def _hash_function(self, key):
        """
        주어진 key에 나누기 방법을 사용해서 해시된 값을 리턴하는 메소드
        주의 사항: key는 파이썬 불변 타입이어야 한다.
        """
        return hash(key) % self._capacity


    def _get_linked_list_for_key(self, key):
        """주어진 key에 대응하는 인덱스에 저장된 링크드 리스트를 리턴하는 메소드"""
        hashed_index = self._hash_function(key)

        return self._table[hashed_index]


    def _look_up_node(self, key):
        """파라미터로 받은 key를 갖고 있는 노드를 리턴하는 메소드"""
        linked_list = self._get_linked_list_for_key(key)
        return linked_list.find_node_with_key(key)

    def look_up_value(self, key):
        """
        주어진 key에 해당하는 데이터를 리턴하는 메소드
        """
        return self._look_up_node(key).value

            
    def insert(self, key, value):
        """
        새로운 key - 데이터 쌍을 삽입시켜주는 메소드
        이미 해당 key에 저장된 데이터가 있으면 해당 key에 대응하는 데이터를 바꿔준다
        """
        existing_node = self._look_up_node(key)  # 이미 저장된 key인지 확인한다

        if existing_node is not None:
            existing_node.value = value  # 이미 저장된 key면 데이터만 바꿔주고
        else:
            # 없는 키면 새롭게 삽입시켜준다
            linked_list = self._get_linked_list_for_key(key)
            linked_list.append(key, value)

    def __str__(self):
        """해시 테이블 문자열 메소드"""
        res_str = ""

        for linked_list in self._table:
            res_str += str(linked_list)

        return res_str[:-1]
```

#### 테스트 코드
```python
test_scores = HashTable(50) # 시험 점수를 담을 해시 테이블 인스턴스 생성

# 여러 학생들 이름과 시험 점수 삽입
test_scores.insert("현승", 85)
test_scores.insert("영훈", 90)
test_scores.insert("동욱", 87)
test_scores.insert("지웅", 99)
test_scores.insert("신의", 88)
test_scores.insert("규식", 97)
test_scores.insert("태호", 90)

print(test_scores)

# key인 이름으로 특정 학생 시험 점수 검색
print(test_scores.look_up_value("현승"))
print(test_scores.look_up_value("태호"))
print(test_scores.look_up_value("영훈"))

# 학생들 시험 점수 수정
test_scores.insert("현승", 10)
test_scores.insert("태호", 20)
test_scores.insert("영훈", 30)

print(test_scores)
```

### 실습 결과
```
현승: 85
태호: 90
지웅: 99
규식: 97
신의: 88
영훈: 90
동욱: 87
85
90
90
현승: 10
태호: 20
지웅: 99
규식: 97
신의: 88
영훈: 30
동욱: 87
```

[main5_12.py](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/Data%20Structure/1%20Basic%20Data%20Structures/5%20Hash%20Table/main5_12.py) 참고

<br/><br/>

23.01.10
## 13. Chaining을 쓰는 해시 테이블 구현 II

### 실습 설명
Chaining을 이용하는 해시 테이블 삭제 연산을 구현해 볼게요.

삭제 연산의 메소드 이름은 delete_by_key입니다. 파라미터로 key를 받는데요. 해시 테이블에서 key에 해당하는 key - value 쌍을 지워 줍니다.
- 저번 과제 해설에 나온 헬퍼 메소드를 사용하시면 조금 더 편하게 과제를 풀 수 있습니다.
- 수정할 코드는 main.py의 delete_by_key 메소드입니다

### 실습 결과
```
영훈: 90
동욱: 87
```

<br/><br/>

### 해설
#### delete_by_key() 메소드
```python
def delete_by_key(self, key):
    """주어진 key에 해당하는 key - value 쌍을 삭제하는 메소드"""
    node_to_delete = self._look_up_node(key)  # 이미 저장된 key인지 확인한다

    # 저장되어 있는 key면 삭제한다
    if node_to_delete is not None:
        linked_list = self._get_linked_list_for_key(key)
        linked_list.delete(node_to_delete)
```
delete_by_key() 메소드는 파라미터로 key를 받아서 해시 테이블에서 그 key에 대한 key - value 쌍을 지워줍니다.

delete_by_key()에서도 저번 과제 때 작성했던 헬퍼 메소드들을 사용하면 됩니다.

먼저 파라미터 key를 갖고 있는 노드를 받아옵니다. 이 노드를 node_to_delete 변수에 저장해 줍니다.

만약에 지우려는 key를 갖고 있는 노드가 없다면 node_to_delete 가 None이겠죠?

반대로 None이 아니라는 것은 해시 테이블 안에 해당 key에 대한 key - value 쌍이 있다는 말입니다. 있을 경우 해시 값 인덱스에 저장된 링크드 리스트를 받아옵니다. 이 링크드 리스트에서 node_to_delete를 삭제해 줍니다. 어차피 링크드 리스트 클래스의 delete 메소드는 지우려는 노드 자체를 받잖아요. delete 메소드에 node_to_delete 변수를 파라미터로 넘겨줘서 링크드 리스트에서 삭제합니다.

#### 테스트 코드
제대로 돌아가는지 코드를 돌려 봅시다.
```python
test_scores = HashTable(50) # 시험 점수를 담을 해시 테이블 인스턴스 생성

# 여러 학생들 이름과 시험 점수 삽입
test_scores.insert("현승", 85)
test_scores.insert("영훈", 90)
test_scores.insert("동욱", 87)
test_scores.insert("지웅", 99)
test_scores.insert("신의", 88)
test_scores.insert("규식", 97)
test_scores.insert("태호", 90)

print(test_scores)

# 학생들 시험 점수 삭제
test_scores.delete_by_key("태호")
test_scores.delete_by_key("지웅")
test_scores.delete_by_key("신의")
test_scores.delete_by_key("현승")
test_scores.delete_by_key("규식")

print(test_scores)
```

### 실습 결과
```
영훈: 90
동욱: 87
```

[main5_13.py](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/Data%20Structure/1%20Basic%20Data%20Structures/5%20Hash%20Table/main5_13.py) 

<br/><br/>

## 14. Open Addressing을 이용한 충돌 해결

chaining 이외에도 hash 충돌을 해결하기 위한 방법이 여러 개 있음  
그 중 Open Addressing에 대해 배울 것

### Open Addressing
- 충돌이 일어났을 때 비어있는 인덱스를 찾아 거기에 데이터를 저장하는 방법
- 예시) 101: "최지웅", 204: "강영훈"을 저장하고 싶다
- 101과 204 모두 해시 함수에 넣었을 떄 return 값이 20으로 동일하다면
- 인덱스 20에 101, "최지웅"을 저장
- 인덱스 20에 이미 데이터가 있기 때문에, 204, "강영훈"은 비어있는 인덱스 21에 저장

비어있는 인덱스를 어떻게 찾을 수 있을까?

### 선형 탐사(linear probing)
- 충돌이 일어났을 때, 한 칸씩 다음 인덱스가 비어있는지 확인
- 빈 인덱스를 하나씩, 순서대로, 선형적으로 찾는 방법
- 예시) 101, "최지웅"이 인덱스 20에 저장되어 있는데 해시 함수 return 값이 다시 20이 나온 경우
- 인덱스 20부터 하나씩 더 큰 인덱스가 비어있는지 확인
- 차례대로 확인하다가 가장 먼저 나오는 빈 인덱스에 key - value 쌍 저장

<br/><br/>

## 15. Open Addressing 제곱 탐사
영상에서는 Open addressing을 했을 때 빈 인덱스를 찾는 가장 기본적인 방법인 선형 탐사, 영어로 Linear probing에 대해서 배워봤는데요. Open addressing을 사용한다고 해서 꼭 선형 탐사를 사용해야 되는 건 아닙니다.

이번 노트에서는 다른 방법 중 하나인 제곱 탐사, 영어로 Quadratic Probing에 대해서 알아볼게요.

### 제곱 탐사
Open addressing을 이용하는 해시 테이블이 있다고 할게요. 하얀 색으로 체워져 있는 칸들이 key - value 쌍들이 저장된 인덱스들이고, 검은 칸들이 비어 있는 인덱스라고 할게요.

특정 값을 저장하려고 하는데 해시 함수의 결과가 10이 나왔다고 합시다. 인덱스 10에는 이미 데이터가 저장됐습니다.

선형 탐사를 이용했을 때는 인덱스 11을 확인하고, 인덱스 11은 차 있으니까 인덱스 12를 확인하고 이런 식으로 해서 빈 인덱스를 찾았는데요. 제곱 탐사는 처음에 1의 제곱 뒤에 있는 인덱스를 확인합니다.

1의 제곱은 1이니까 인덱스 11을 확인합니다. 인덱스 11은 차 있습니다.

그다음에는 인덱스 11에서 2의 제곱 뒤에 있는 인덱스를 확인합니다. 2의 제곱은 4입니다. 인덱스 15를 확인합니다. 인덱스 15도 차 있습니다.

그다음은 인덱스 15에서 3의 제곱 밑에 있는 인덱스를 확인합니다. 인덱스 24입니다. 인덱스 24는 비어 있습니다. 여기에 새로운 key - value 쌍 데이터를 저장합니다.

제곱 탐사는 이런 방식으로 선형적으로 바로 다음 인덱스들을 하나씩 확인하지 않고, 제곱을 한 값들을 이용해서 인덱스를 찾습니다.

<br/><br/>

## 16. Open Addressing 탐색/삭제 연산

### 탐색
- Open Addressing을 통해 삽입한 데이터를 찾고 싶을 때
- 해시 함수의 return 값으로 인덱스를 찾은 뒤, 선형탐사를 통해 데이터를 찾으면 됨
- 예시) 인덱스 20에 101, "최지웅", 인덱스 21에 305, "성태호", 인덱스 22에 204, "강영훈"이 저장되어 있고, 204를 찾고 싶을 때
- 204의 해시 함수 return값이 20이 나왔다고 가정
- 인덱스 20을 확인, 하지만 key가 204가 아님
- 저장할 때와 마찬가지로 다음 인덱스를 선형적으로 확인
- 인덱스 20, 21, 22를 차례로 확인하다보면 인덱스 22에 204가 있으므로 value인 "강영훈"을 return
- 주의: 선형탐사를 하던 중 빈 인덱스가 나오면, 찾고 있는 key에 대한 데이터가 저장되지 않음(데이터가 없음)을 의미

### 삭제
- Open Addressing을 통해 삽입한 데이터를 삭제하고 싶을 때
- 일단 탐색하여 해당 데이터를 찾음
- 해당 인덱스를 비워서 데이터를 없애는 게 아니라, "DELETE" 또는 다른 약속된 표시를 해야 함
- 빈 값으로 두지 않는 이유는, 탐색을 할 때 빈 인덱스가 나오면, 뒤에 있는 데이터를 찾을 수 없기 때문

<br/><br/>

## 17. Open Addressing을 쓰는 해시 테이블 시간 복잡도

Open Addressing을 사용하는 해시 테이블은 각각 탐색, 삽입, 삭제 연산들을 얼마나 효율적이게 하는지 알아봅시다.

### 연산들의 세부 단계들
Chaining과 마찬가지로 key를 해시 함수에 넣어서 삽입하고, 이 결과 값을 이용해서 인덱스에 접근하는 데 걸리는 시간은 $O(1)$입니다. 원하는 인덱스에 key - value 쌍을 저장하는 것도 마찬가지로 $O(1)$이죠.

Open Addressing을 하게 되면 탐색, 삽입, 삭제 연산들 모두 인덱스를 찾는 탐사를 해야 합니다. 정확히 얘기하면 삽입 연산은 탐사를 통해서 빈 인덱스를 찾고, 탐색과 삭제 연산은 원하는 key를 갖는 데이터 쌍을 찾습니다. 탐사를 할 때 걸리는 시간을 알아볼게요.

### 탐사 최악의 경우
최악의 경우를 생각해봅시다. 어떤 경우에 가장 탐사를 많이 해야 될까요?

해시 테이블이 사용하는 배열이 거의 꽉 찼을 때인데요. 예를 들어서 그림처럼 사용하는 배열이 인덱스 13 말고 모두 찼다고 생각해봅시다.

여기에 새로운 key - value 쌍을 저장하고 싶으면 어떻게 할까요? key를 해시 함수에 넣었을 때 14가 리턴됐다고 할게요. 그럼 인덱스 14에서 선형 탐사를 이용해서 빈 인덱스를 찾아야 되는데요. 14, 15, 16… 이렇게 쭉 탐사를 하다가 마지막에 인덱스 13을 찾겠죠?

그러니까 빈 인덱스를 찾기 위해 배열 안에 있는 모든 인덱스를 하나씩 다 확인해야 합니다. 해시 테이블 안에 저장된 key - value 쌍의 개수가 $n$일 때, $n$에 비례하는 시간이 걸리는 거죠.

그럼 위에서 삽입한 인덱스 13에 저장한 데이터를 탐색하거나 삭제하고 싶을 때는 어떻게 할까요? key를 해시 함수에 넣으면 아까랑 똑같이 14가 나올탠데요. 다시 선형 탐사로 배열의 모든 인덱스를 다 돌아야 됩니다.

이때도 마찬가지로 $n$에 비례하는 시간이 걸리는 거죠.

탐사를 제외한 세 연산의 다른 모든 단계들은 $O(1)$이 걸렸는데요. 탐사는 최악의 경우 $O(n)$이 걸립니다. 세 연산 모두 탐사가 포함되기 때문에 아래 표에 나와 있는 거만큼 시간이 걸린다고 할 수 있습니다.

### Open Addressing 연산 시간 복잡도
| 연산 | 시간 복잡도 (최악의 경우) |
|:----:|:-------------------------:|
| 삽입 |          $O(n)$         |
| 탐색 |          $O(n)$         |
| 삭제 |          $O(n)$         |

<br/><br/>

## 18. (중요!) Open Addressing을 쓰는 해시 테이블 평균 시간 복잡도

저번 레슨에서는 해시 테이블의 연산들을 최악의 경우를 이용해서 분석해봤습니다. 최악의 경우는 해시 테이블이 사용하는 배열이 거의 꽉 찼을 경우였잖아요? 근데 생각해보면 해시 테이블이 거의 꽉 차 있는 경우는 잘 일어나지 않고, 대부분 경우는 여유 공간이 넉넉하게 있을 탠데요.

Chaining을 이용하는 해시 테이블과 마찬가지로 이 세 연산들을 모두 최악의 경우로만 분석하면 좀 불공평합니다.

Open Addressing을 사용하는 해시 테이블의 연산들도 평균 시간 복잡도로 표현해 볼게요.

### load factor
해시 테이블 연산들을 분석할 때는 load factor라는 것을 사용합니다. load factor α는 해시 테이블이 사용하는 배열의 크기를 m, 해시 테이블 안에 들어 있는 데이터 쌍 수를 n이라고 할 때:

$\alpha$ = $\frac{n}{m}$ 

인데요. 그냥 해시 테이블이 얼마나 차있는지를 나타내는 변수입니다.

Open addressing을 할 때 해시 테이블의 연산들을 분석할 때는 load factor는 굉장히 중요한 역할을 합니다. 해시 테이블 안에 배열의 크기보다 많은 key - value 쌍을 저장할 수 없기 때문에 load factor α는 항상 1보다 작다고 가정합니다.

### 결과
결과적으로 얘기하면 Open addressing을 사용하는 해시 테이블에서 평균적으로 탐사를 해야 되는 횟수(기댓값)은 $\frac{1}{1 - \alpha}$ 보다 작습니다.

기댓값이 $\frac{1}{1 - \alpha}$라는 걸 무슨 의미일까요? 배열이 총 100 칸이라고 하고 90 개의 key - value 쌍을 저장했다고 합시다. 그럼 load factor α = 0.9 인 건데요.

기댓값에 α를 대입하면 10이 나옵니다. 그러니까 빈 인덱스를 찾기 위해서 평균적으로 인덱스 10 개보다 적은 인덱스를 확인해도 된다는 뜻이죠. 사실 load factor 가 0.9도 굉장히 load factor가 큰 거고요. 만약에 α = 0.5 그러니까 해시 테이블이 반 정도 차있다면 어떨까요? 기댓값은 2보다 작습니다. 그러니까 해시 테이블이 반이나 차 있어도 평균적으로 두 개의 인덱스만 확인해봐도 빈칸을 찾을 수 있다는 거죠.

그럼 해시 테이블을 사용할 때, 항상 load factor가 0.9가 넘지 않게 사용하겠다고 약속을 하면 어떻게 될까요? (일반적으로 이 제한을 변수 c를 사용해서 표현합니다) $\frac{1}{1 - \alpha}$를 계산해보면 평균적으로 10 보다 적게 탐사를 해야된다고 할 수 있는데요. $0 < \alpha < 0.9$ 일 때는 평균적으로 항상 10보다 적게 탐사할 수 있겠죠? 그렇기 때문에 이 가정을 한다면, 성공적으로 원하는 인덱스를 찾는 데 봐야 하는 인덱스 수는 평균적으로 $O(10)$ 이하, 즉 $O(1)$이라고 할 수 있습니다. 탐사가 평균적으로 $O(1)$이 걸리는 거죠.

Open addressing을 사용한 해시 테이블 연산들의 시간 복잡도가 $O(n)$인 이유는 다른 단계들은 $O(1)$으로 할 수 있는데 탐사가 최악의 경우 $O(n)$이 걸리기 때문이었는데요. 방금 봤듯이 탐사는 최악의 경우 $O(n)$이 걸리지만 평균적으로는 $O(1)$의 시간이 걸립니다.

그러니까 Open addressing을 사용하든 Chaining을 사용하든 해시 테이블의 모든 연산들을 평균적으로 $O(1)$로 할 수 있는데요? 굉장히 효율적이죠.

| 연산 | 시간 복잡도 (평균) |
|:----:|:------------------:|
| 삽입 |        $O(1)$        |
| 탐색 |        $O(1)$        |
| 삭제 |        $O(1)$        |

### 수학적 분석
여기서부터 어떻게 해서 탐사 연산의 기대 시간이 $\frac{1}{1 - \alpha}$보다 작은지를 수학적으로 분석해보겠습니다. 굳이 보기 싫으신 분들은 건너 뛰셔도 상관없습니다. 또 수학적인 내용이 굉장히 많이 있는데요. 수학적인 부분들이 이해가 안 되시는 부분이 있으시면 이 레슨 질문들을 참고하시거나 새롭게 질문을 해주시면 답해드리겠습니다.

그럼 바로 시작해보겠습니다.

먼저 해시 테이블 배열 크기가 10이라고 하고 여기에 4 개의 key - value 쌍을 저장했다고 가정합시다.

그리고 여기서 새로운 key - value 쌍을 삽입하고 싶다고 할게요.

처음 해시 함수를 계산해서 나온 결과 값 인덱스가 이미 차있을 확률을 얼마나 될까요?
- 총 10칸 중 4칸은 차있고 6칸은 비어 있잖아요? 아무 인덱스나 골랐을 때 차있을 확률은 $\frac{4}{10}$가 되겠죠?

이 인덱스가 차있으면 탐사로 비어 있는 다른 인덱스를 찾아야 되는데요. 그럼 이 인덱스도 차 있을 확률은 어떻게 될까요? 그러니까 첫 번째로 확인한 인덱스도 차있고 두 번째 확인한 인덱스도 차있는 경우인데요.

- 첫 번째 인덱스가 이미 차 있으니까 이제 탐사를 아직 안 한 9 개 칸 중 3 개만 차있을 텐데요. 그럼 또 다른 인덱스가 차있을 확률은 9개 중 3개니까 $\frac{3}{9}$입니다.
- 그리고 첫 번째와 두 번째 탐사 인덱스가 모두 찼을 확률은 $\frac{4}{10} * \frac{4 - 1}{10 - 1}$ 이렇게 되는 거죠.

다음 칸도 차 있을 확률도 계산해 봅시다.
- 이제 8 개 칸 중 2개만 차있습니다. 8개 중 2개니까 $\frac{2}{8}$입니다.
- 탐사를 할 때 첫 세 인덱스가 모두 찼을 확률은 $\frac{4}{10} * \frac{4 - 1}{10 - 1} * \frac{4 - 2}{10 - 2}$입니다.

패턴이 보이기 시작하시나요?

빈 인덱스를 탐사할 때 i 번 이상 탐사를 해야될 확률을 $P_i$라고 할게요. i 번 이상 탐사를 해야된다는 말은, 첫 번째 인덱스부터 i-1 인덱스까지가 차있다는 말이잖아요? 그렇기 때문에 이렇게 표현할 수 있습니다:

$P_i = \frac{n}{m} * \frac{n - 1}{m - 1} * \frac{n - 2}{m - 2} * ... * \frac{n - i + 2}{m - i + 2}$

그럼 이렇게도 표현할 수 있습니다.

$P_i = \frac{n}{m} * \frac{n - 1}{m - 1} * \frac{n - 2}{m - 2} * ... * \frac{n - i + 2}{m - i + 2} < (\frac{n}{m})^{i - 1}$

수학식이 좀 복잡하긴 한데요. 아까 예시를 이용해서 설명하자면 다시 보면 크기가 10인 배열에서 4 번 이상 탐색을 해야될 확률 $P_4$(첫 번째부터 세 번째 인덱스까지 모두 차있을 확률)는:

$P_4 = \frac{4}{10} * \frac{3}{9} * \frac{2}{8} < \frac{4}{10} * \frac{4}{10} * \frac{4}{10}$라는 뜻인데요.

왼쪽 항이 항상 오른쪽 항보다 작죠? 위에 저 복잡한 식이 그냥 이런 관계를 나타낸 겁니다. 왼쪽 항이 $P_i$니까

$P_i < (\frac{n}{m})^{i - 1}$라고 할 수 있습니다.

그리고 $\frac{n}{m} = \alpha$니까

$P_i < \alpha^{i - 1}$라고 할 수 있죠.

$P_i$는 탐사를 i 번 이상할 확률이잖아요? 이 확률을 이용하면 평균적으로 몇 번의 탐사를 해야 빈 인덱스를 찾을 수 있는지를 계산할 수 있는데요. 이걸 기댓값이라고 합니다.

기댓값을 $E_x$라고 하면, 지금 같은 경우는 기댓값을 이렇게:

$E_x = P_1 + P_2 + P_3 + ...$

계산할 수 있습니다(이 부분이 이해가 안 되시면 레슨 질문에 설명드리니 참고해주세요!). $P_i < \alpha^{i - 1}$이니까

$E_x < 1 + \alpha + \alpha^2 + \alpha^3 ...$라고 할 수 있고 α < 1이기 때문에 등비 수열이란 건데요. 이걸 정리하면:

$E_x < \frac{1}{1 - \alpha}$라고 할 수 있습니다.

따라서, 평균적으로 탐사를 해야되는 값의 기댓값은 $\frac{1}{1 - \alpha}$보다 작다고 할 수 있습니다.


<br/><br/>

## 19. 해시 테이블 퀴즈

질문 1  
다음 중 틀린 내용을 고르시오.
1 해시 테이블을 이용하면 key - value 데이터를 저장할 수 있다.  
2 해시 테이블에는 데이터 간 순서 관계를 나타낼 수 없다.  
3 Direct Access Table을 이용하면 key - value 데이터를 시간 효율적으로 저장하고 찾을 수 있다.  
4 해시 함수는 특정 값을 넣었을 때 원하는 범위의 자연수를 리턴하는 함수다.  
5 해시 함수는 빠르지 않아도 제대로 작동하기만 하면 된다.

질문 2  
다음 중 충돌과 Chaining에 대한 내용 중 틀린 것을 고르시오.  
1 충돌은 해시 테이블에서 한 인덱스에 두 개의 key - value 쌍을 저장해야 되는 경우다.  
2 충돌이 일어나도 Chaining이나 다른 해결 방법을 사용하지 않아도 해시 테이블을 사용할 수 있다.  
3 Chaining을 이용하는 해시 테이블이 사용하는 링크드 리스트가 가장 긴 경우는 모든 key - value 쌍이 하나의 인덱스에 저장됐을 때다.  
4 Chaining을 이용하는 해시 테이블의 모든 연산들은 최악의 경우 $O(n)$가 걸린다.  
5 Chaining을 이용하는 해시 테이블의 모든 연산들은 평균적으로 $O(1)$이 걸린다.

질문 3  
다음 중 Open addressing에 대한 내용 중 틀린 것을 고르시오.  
1 Open addressing을 이용하면 충돌이 일어났을 경우 한 인덱스에 여러 개의 key - value 데이터를 저장하는 게 아니라, 저장할 수 있는 다른 인덱스를 찾아서 저장하는 방법이다.  
2 Open addressing을 사용하면 빈 인덱스를 어떻게 찾을지, 그러니까 선형 탐사 같은 탐사 방법을 정해야 된다.  
3 Open addressing의 시간 복잡도 분석할 때는 load factor, 해시 테이블이 얼마나 차 있는지가 중요하다.  
4 Open addressing을 이용하면 해시 테이블의 모든 연산들을 평균적으로 $O(1)$이 걸린다.  
5 Open addressing을 이용하면 해시 테이블의 모든 연산들을 최악의 경우 $O(lg(n))$이 걸린다.

<br/><br/>

### 퀴즈 해설
질문 1  
정답 5  
퀴즈 해설  
해시 함수는 해시 테이블의 모든 연산들에 사용됩니다. 해시 함수를 계산하는 게 오래 걸린다면 해시 테이블의 모든 연산들도 오래 걸릴 수 밖에 없겠죠? 그렇기 때문에 해시 함수는 원하는 범위의 자연수를 빠르게 $(O(1)$으로) 리턴하면 좋습니다.

질문 2  
정답 2  
퀴즈 해설  
해시 테이블을 제대로 사용하고 싶으면 Chaining이나 Open addressing 등을 이용해서 충돌을 해결해야만 합니다.  

질문 3  
정답 5  
퀴즈 해설  
Open addressing을 이용하면 해시 테이블의 모든 연산들은 최악의 경우 $O(n)$이 걸립니다.
