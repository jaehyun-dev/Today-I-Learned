# 5 해시 테이블
23.01.07  

## 01. key-value 데이터  

배열과 링크드 리스트는 데이터를 순서대로 저장하므로 순서관계가 중요함  
하지만 모든 데이터에 순서관계가 있는 것은 아님  

101호: 최지웅  
711호: 김현승  
942호: 손동욱  
204호: 강영훈  
302호: 성태호  

호수과 입주민의 관계.  
어떤 호수에 어떤 입주민이 살고 싶은지 알고 싶을 때, 순서에 큰 의미는 없음.  

순서가 아니라 이미 알고 있는 정보를 이용하여 저장한 정보를 검색할 수 있는 데이터 유형을 **key-value 데이터**라고 부름.  
- 하나의 key과 그 key에 해당하는 value를 합쳐서: key - value 쌍  
- 하나의 key에는 하나의 value만 있어야 된다!  

이번 챕터에서 배울 내용  
- key - value 데이터를 어떻게 저장할 수 있는지
- key를 이용해서 저장한 value를 어떻게 찾을 수 있는지

<br/><br/>

## 02. Direct Access Table  
배열 인덱스 접근: $O(1)$  
인덱스는 데이터의 순서에 해당하는 정보. 항상 0부터 배열의 크기 - 1까지의 자연수.  
인덱스를 순서가 아니라 key라고 생각하면 직관적으로 key - value 쌍을 저장할 수 있음.  

101호: 최지웅  
711호: 김현승  
942호: 손동욱  
204호: 강영훈  
302호: 성태호  

위 예시에서, 가장 큰 호수인 942를 마지막 인덱스로 갖는 배열을 만들고, 각 호수를 인덱스로, 입주민을 값으로 저장하면 key(인덱스)를 이용해 모든 value(입주민)에 $O(1)$으로 접근 가능  
이런 방식을 Direct Access Table이라고 부름  
단점: 공간을 너무 많이 낭비할 수 있음  

<br/><br/>

## 03. 해시 테이블 개념  
Direct Access Table의 단점인 공간 낭비를 개선하여 시간과 공간을 모두 효율적으로 사용할 수 있는 자료구조  

### 해시 함수
특정 값을 원하는 범위의 자연수로 바꿔주는 함수  
해시 함수를 이용하면 key가 아무리 커도 항상 원하는 범위 사이의 자연수로 바꿀 수 있음  

### 해시 테이블(Hash Table)
해시 함수와 배열을 같이 사용하는 자료구조  
key를 바로 인덱스로 하지 않고, 해시 함수에 넣어 return된 값을 인덱스로 사용함  

### 방법:  
1. 원하는 크기의 배열을 만듦
2. key-value 쌍에서 key를 해시 함수에 넣어 원하는 범위 안의 값으로 return 받음  
3. 배열에 return된 값을 인덱스로 하여, key와 value를 함께 저장함  
4. 접근할 때는, 원래의 key가 들어오면 해시 함수에 넣어 return된 값으로 배열에서 접근하여 value를 가져옴  

<br/><br/>

## 04. 해시 함수
영상에서는 그냥 해시 함수를 key를 넣었을 때 원하는 범위의 자연수를 리턴해주는 어떤 함수라고만 얘기했었는데요. 이번에는 해시 함수에 대해서 조금 더 알아보고 해시 함수를 구현할 수 있는 가장 간단한 방법들에 대해서 살펴볼게요.
```
101호: 최지웅
204호: 강영훈
302호: 성태호
711호: 김현승
942호: 손동욱
```
먼저 주어진 key를 원하는 범위의 자연수로 바꿔서 리턴해주는 것 말고 다른 해시 함수의 조건들을 볼게요.
1. 한 해시 테이블의 해시 함수는 결정론적이어야 된다.
- 똑같은 key를 넣었을 때는 항상 똑같은 결과가 나와야 한다는 건데요. 942를 해시 함수에 넣을 때 어쩔 때는 5이 나오고 어쩔 때는 10이 나오고 이러면 안 된다는 거죠. 942를 넣으면 항상 똑같은 결과가 나와야 됩니다.
2. 결과 해시값이 치우치지 않고 고르게 나온다.
- 그러니까 해시 함수에 101, 204, 302, 711, 942나 아무 숫자를 넣었을 때 항상 40만 나오면 안 된다는 거죠. 원하는 범위가 0 부터 100까지의 자연수면, 이 사이에 아무 두 숫자가 나올 확률이 최대한 비슷해야 됩니다..
3. 빨리 계산할 수 있어야 된다.
- 해시 테이블은 모든 연산을 할 때마다 해시 함수를 써야 되는데요. 해시 함수가 비효율적이면 해시 테이블도 비효율적일 수밖에 없겠죠?

이 조건들이 조금 어렵게 느껴질 수도 있는데요. 사실 해시 함수를 만드는 건 생각보다 어렵지 않습니다. 이번 레슨에서는 가장 간단한 두 가지만 알아볼게요.

### 나누기 방법
가장 직관적이면서 쉬운 방법은 나누기 방식인데요. 자연수 key를 해시 테이블의 크기로 나눈 나머지를 리턴하는 함수입니다. 그러니까 저장해야 되는 키가 40, 120, 788, 2307이고 배열의 크기가 200이라고 할게요. 그럼 그냥 key를 200으로 나누어서 남는 나머지를 리턴한다는 거죠. 40을 넣으면 40, 120은 120, 788 은 188, 2307은 107가 리턴됩니다.

나누기 방법을 코드로 나타내면 이렇게 됩니다.

```python
def hash_function_remainder(key, array_size):
    """해시 테이블의 key를 나누기 방법으로 0 ~ array_size - 1 범위의 자연수로 바꿔주는 함수"""
    return key % array_size


print(hash_function_remainder(40, 200))
print(hash_function_remainder(120, 200))
print(hash_function_remainder(788, 200))
print(hash_function_remainder(2307, 200))
```
```
40
120
188
107
```
어떤 키가 들어와도 0 ~ 원하는 정수 범위의 자연수로 바꿔줍니다.

### 곱셈 방법
다음으로 볼 방법은 곱셈 방법입니다. 곱셈 방법은 나누기 방법보다는 조금 까다로운데요.

이해를 돕기 위해 예시로 key가 200이고 사용하려는 배열 크기가 30이라고 할게요.

1. 먼저 0 < a < 10<a<1 인 아무 값 a를 정합니다. 일단 임의로 0.6666로 정할게요
2. 그다음에 이 a에 key를 곱합니다. 그러니까 0.666에 200을 곱하면 133.32이 되는데 이때 정수 부분은 버리고 소수 부분만 남깁니다. 0.32가 남습니다.
3. 마지막으로 남은 소수 부분에 배열의 크기를 곱해줍니다. 0.32 * 30 하면 9.6이 되죠. 이번엔 소수점 부분을 버리고 9만 남깁니다.

단계가 조금 많아서 헷갈릴 수도 있는데요. 왜 이 방법이 원하는 범위의 자연수를 리턴하는지 생각해볼까요? a와 key를 곱한 값의 정수 부분을 버리면 그 결과 값은 0.xxxx 이런 식으로 0과 1 사이의 소수가 나올 수밖에 없겠죠? 0과 1 사이의 소수에 테이블의 크기를 곱해버리면, 다시 0과 테이블 크기 사이의 수가 나오죠. 그러니까 0.0001에 테이블 크기 30을 곱하면 0.003이 나오고 0.9999에 테이블 크기 30을 곱하면 29.997이 나오는데요. 항상 0보다 크거나 같고 테이블 크기인 30보다는 작은 숫자가 나옵니다. 그리고 여기서 소수점 뒷자리를 버리니까 원하는 범위의 자연수를 구할 수 있습니다.

곱셈 방법도 코드로 작성해 볼까요?

```python
def hash_function_multiplication(key, array_size, a):
    """해시 테이블의 key를 곱셈 방법으로 0 ~ array_size - 1 범위의 자연수로 바꿔주는 함수"""
    temp = a * key # a와 key를 곱한다
    temp = temp - int(temp) # a와 key를 곱한 값의 소숫점 오른쪽 부분만 저장한다
    
    return int(array_size * temp) # temp와 배열 크기를 곱한 수의 자연수 부분만 리턴한다
        

print(hash_function_multiplication(40, 200, 0.61426212))
print(hash_function_multiplication(120, 200, 0.61426212))
print(hash_function_multiplication(788, 200, 0.61426212))
print(hash_function_multiplication(2307, 200, 0.61426212))
```
```
114
142
7
20
```

### 정리
나누기 방법과 곱셈 방법은 해시 함수로 사용할 수 있는 가장 간단한 두 예시였는데요. 사실 key를 받아서 원하는 범위의 자연수를 리턴하면서:
1. 결정론적이어야 된다.
2. 원하는 범위의 자연수 하나하나가 리턴될 확률이 최대한 비슷해야 된다.
3. 빨리 계산을 할 수 있어야 된다.

이 세 조건을 만족하는 아무 함수나 만들면 해시 함수로 이용할 수 있습니다.

<br/><br/>

## 05. 파이썬 hash 함수

### 파이썬 hash 함수
파이썬 언어도 내부적으로 hash라는 함수를 제공합니다. 근데 이건 우리가 방금 배운 해시 함수랑 조금 다른데요. 파이썬 해시 함수는 파라미터로 받은 값을 그냥 아무 정수로만 바꿔주는 함수입니다.

저희가 배웠던 해시 함수와는 달리 특정 범위 안에 있는 정수가 아니라 아무 정수로 바꿔주죠.

정수형, 소수형, 문자열 타입에 hash 함수를 호출했을 때 나오는 결과를 살펴볼게요.
```python
# 정수 값
print(hash(12345))  # 12345
print(hash(12345))  # 12345

# 다른 정수 값
print(hash(12346))  # 12346 
```
```python
# 소수 값
print(hash(15.1234))  # 284541027336970255
print(hash(15.1234))  # 284541027336970255

# 다른 소수 값
print(hash(81.1234))  # 284541027336978513
```
```python
# 문자열
print(hash("파이썬"))  # -8002119629611903017
print(hash("파이썬"))  # -8002119629611903017

# 다른 문자열
print(hash("자바"))  # -8553573703343279427
```
이런식으로 같은 값을 넣으면 항상 같은 정수를 리턴해주는 함수입니다. 이 때 중요한 점은 hash 함수에 서로 다른 두 값을 파라미터로 넣었을 때 같은 정수가 리턴될 수 없다는 건데요.

그러니까 hash("파이썬")이 -8002119629611903017이 리턴됐으면, 다른 그 어떤 값을 파라미터로 넣어도 -8002119629611903017가 나올 수 없습니다. 데이터를 자신만의 고유한 정수 값으로 바꿔주는 함수죠.

지금까지는 해시 함수에 key를 정수형으로만 생각했잖아요? 다른 타입의 데이터들을 자신만의 고유한 정수 값으로 바꿀 수 있으면 이제 정수 뿐만 아니라 다른 자료형들도 key로 사용할 수 있습니다. 해시 테이블에 저장할 수 있는 종류의 데이터를 더 폭 넓게 늘릴 수 있다는 말이죠. 과제에서 해시 테이블을 직접 구현할 때 이 hash 함수를 사용해서 해시 테이블에 key가 문자열인 데이터를 저장할 건데요. 그 때 그냥 “아 문자열을 고유한 정수 값으로 바꿔주는구나”라고 이해하시면 됩니다!

### hash 함수의 한계
여기서 조심해야 되는 게 하나 있는데요. 파이썬 hash 함수는 언어 자체적으로는 불변 타입 자료형에만 사용할 수 있습니다.

파이썬에서 여러분이 가장 많이 접해봤을 대표적인 불변 타입 자료형은:
- 불린형
- 정수형
- 소수형
- 튜플
- 문자열

이 정도가 있는데요. 이런 타입의 자료형만 hash 함수의 파라미터로 넘겨줄 수 있습니다.

<br/><br/>

23.01.08  
## 06. 해시 테이블 충돌과 Chaining 개념

key-value쌍을 저장하기 위해 key를 해시 함수에 넣었는데, 서로 다른 key 값이 같은 해시함수 return 값이 나올 수가 있음  
한 인덱스에 두 개의 key-value 쌍을 저장해야 되는 경우가 생김  
이미 사용하고 있는 인덱스에 새로운 key-value 쌍을 또 저장해야 되는 경우를 충돌(Collision)이 일어났다고 표현함  
충돌을 해결하는 방법 중 하나인 Chaining에 대해 알아볼 것  

### Chaining
직역하면 쇠사슬로 묶는 것  
배열 인덱스에 링크드 리스트를 저장해서 충돌을 해결함  

```python
class Node:
    """링크드 리스트 노드"""
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.next = next
```

이렇게 노드를 만들어서, 만약 key 값에 같은 hash 함수 return값이 나오면 해당 인덱스에 링크드 리스트 노드를 그대로 이어붙이면 됨

<br/><br/>

23.01.08  
## 07. Chaining에서 사용하는 링크드 리스트

전 레슨에서도 보았듯이 Chaining을 이용하면 해시 테이블에서 충돌이 일어나도 key - value 쌍들을 모두 저장할 수 있습니다. 이번 챕터에서는 해시 테이블의 개념을 배우고 직접 구현해볼 건데요. 지난 챕터에서 만들었던 링크드 리스트 클래스도 한 번 해시 테이블에서 사용할 수 있게 바꿔볼게요.

더블리 링크드 리스트를 이용하겠습니다.

### Node 클래스
여기서는 크게 바꿀 건 없는데요. 영상에서 본 것처럼 그냥 링크드 리스트 노드가 변수 data 대신 key와 value를 저장하도록 해줄게요.
```python
class Node:
    """링크드 리스트의 노드 클래스"""
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.next = None  # 다음 노드에 대한 레퍼런스
        self.prev = None  # 전 노드에 대한 레퍼런스
```
### LinkedList 클래스
링크드 리스트 클래스에서는 필요한 메소드들만 가지고 와서 쓰면 됩니다. 노드 클래스랑 마찬가지로 그대로 사용할 수는 없고요. 조금씩 고쳐서 써야합니다.

다행히 \_\_init\_\_ 메소드는 바꾸지 않아도 됩니다.
```python
class LinkedList:
    """링크드 리스트 클래스"""
    def __init__(self):
        self.head = None  # 링크드 리스트의 가장 앞 노드
        self.tail = None  # 링크드 리스트의 가장 뒤 노드
```
#### 탐색 메소드
```python
def find_node_with_key(self, key):
    """링크드 리스트에서 주어진 데이터를 갖고있는 노드를 리턴한다. 단, 해당 노드가 없으면 None을 리턴한다"""
    iterator = self.head   # 링크드 리스트를 돌기 위해 필요한 노드 변수

    while iterator is not None:
        if iterator.key == key:
            return iterator

        iterator = iterator.next

    return None
```
탐색 메소드는 이제 특정 데이터를 갖는 노드를 찾는 게 아니라 특정 key를 갖는 노드를 찾습니다. 이에 맞게 링크드 리스트를 처음부터 끝까지 돌면서 원하는 key를 갖는 노드를 리턴해주도록 수정해줍니다. 코드에서는 기존에 data 변수를 다 key로 바꿔주면 되죠.

#### 추가 (맨 뒤 삽입) 메소드
```python
def append(self, key, value):
    """링크드 리스트 추가 연산 메소드"""
    new_node = Node(key, value)

    # 빈 링크드 리스트라면 head와 tail을 새로 만든 노드로 지정
    if self.head is None:
        self.head = new_node
        self.tail = new_node
    # 이미 노드가 있으면
    else:
        self.tail.next = new_node  # tail의 다음 노드로 추가
        new_node.prev = self.tail
        self.tail = new_node  # tail 업데이트
```
추가 메소드 append는 이제 파라미터로 data 변수 대신 key와 value를 받습니다. 링크드 리스트에 데이터를 더해줄 때는 항상 새로운 노드를 만들어줘야 되는데요. 파라미터로 받은 정보를 key와 value를 갖는 새로운 노드를 만들어줍니다. 새 노드를 링크드 리스트에 연결해주는 부분 코드는 똑같습니다.

#### 삭제 메소드
```python
def delete(self, node_to_delete):
    """더블리 링크드 리스트 삭제 연산 메소드"""

    # 링크드 리스트에서 마지막 남은 데이터를 삭제할 때
    if node_to_delete is self.head and node_to_delete is self.tail:
        self.tail = None
        self.head = None

    # 링크드 리스트 가장 앞 데이터 삭제할 때
    elif node_to_delete is self.head:
        self.head = self.head.next
        self.head.prev = None

    # 링크드 리스트 가장 뒤 데이터 삭제할 떄
    elif node_to_delete is self.tail:
        self.tail = self.tail.prev
        self.tail.next = None

    # 두 노드 사이에 있는 데이터 삭제할 때
    else:
        node_to_delete.prev.next = node_to_delete.next
        node_to_delete.next.prev = node_to_delete.prev
```
원래 링크드 리스트 삭제 메소드에서는 노드를 삭제할 때 삭제하는 노드의 데이터를 리턴했는데요. 이 부분을 빼줄게요.

나머지 부분은 바꿔줄 필요 없습니다. 더블리 링크드 리스트 삭제 메소드는 어차피 노드가 주어졌을 때 그 노드를 링크드 리스트에서 삭제해주죠? 기존 data 변수나 key, value 변수와 전혀 관계가 없는 메소드기 때문에 나머지 코드를 바꿀 필요가 없는 거죠.

#### 문자열 메소드
문자열 메소드는 출력 형식을 조금 바꿔줄게요.
```python
def __str__(self):
    """링크드 리스트를 문자열로 표현해서 리턴하는 메소드"""
    res_str = ""

    # 링크드 리스트 안에 모든 노드를 돌기 위한 변수. 일단 가장 앞 노드로 정의한다.
    iterator = self.head

    # 링크드 리스트 끝까지 돈다
    while iterator is not None:
        # 각 노드의 데이터를 리턴하는 문자열에 더해준다
        res_str += "{}: {}\n".format(iterator.key, iterator.value)
        iterator = iterator.next # 다음 노드로 넘어간다

    return res_str
```
원래는 링크드 리스트에 2, 3, 5, 7, 11이 들어있으면 이런 식으로 링크드 리스트의 모든 data 변수를 한 줄에 순서대로 출력했잖아요?
```
2 | 3 | 5 | 7 | 11
```
이제는 key - value 쌍을 저장하니까 출력 형식도 바꿔주는 거죠.

링크드 리스트에 101: “최지웅”, 204: “강영훈”, 305: “성태호”이 들어 있다고 할게요. 그러면 아래와 같이 이 링크드 리스트를 출력했을 때 한 줄에 한 key, value 쌍 하나씩 나오도록 바꿔준 거죠.
```
101: 최지웅
204: 강영훈
305: 성태호
```

<br/><br/>

## 08. Chaining을 쓰는 해시 테이블 탐색 연산

해시 테이블 연산
- 탐색
- 삽입
- 삭제

탐색  
- 배열과 링크드 리스트는 접근 연산이 있지만 해시 테이블은 순서 관계가 없으므로 접근 연산을 쓰지 않고 탐색 연산을 사용함  
- 원하는 key에 해당하는 value를 찾는 연산
- 예시: 101: "최지웅"을 찾고 싶을 때
    - 101을 해시테이블에 넣어서 20이라는 값을 return 받으면, 배열의 인덱스 20에 접근해 링크드 리스트를 받아온다.
    - 링크드 리스트의 가장 앞 노드부터, 끝까지 원하는 key가 있는지 확인한다.
    - 원하는 데이터를 찾으면 value를 return한다.
- 탐색 연산 시간 복잡도
    - 해시 함수 계산: $O(1)$
    - 배열 인덱스 접근: $O(1)$
    - 링크드 리스트 탐색: $O(n)$
    - 총합: $O(1 + 1 + n) = O(n)$
