# 6 추상 자료형

23.01.11

## 01. 기능 vs 구현

삽입 연산(insert operation)의 기능과 구현?  

### 기능
연산이 "무엇"을 하는지
- 삽입 연산 기능: "순서 데이터에서 원하는 위치에 데이터를 저장"

### 구현
기능을 "어떻게" 하는지
- 동적 배열 삽입: 데이터 삽입할 때 인덱스와 인덱스 뒤에 있는 모든 인덱스를 뒤로 한 칸씩 뒤로 미룬 뒤 빈 인덱스에 데이터 삽입
- 링크드 리스트 삽입: 저장하려는 위치 바로 전 노드에 접근한 후, 앞 뒤 노드들의 레퍼런스들을 수정해서 원하는 위치에 데이터 삽입

<br/><br/>

## 02. 추상화

### 추상화
구현을 몰라도 기능만 알면 프로그래밍을 할 수 있게 해주는 개념

```python
def insert(data_type, index, element):
    """자료형 data_type의 위치 index에 데이터 element를 삽입해주는 함수"""
```

개발자들이 이 함수를 사용하고 싶으면 이 함수가 뭘 하는지만 알면, 어떻게 구현돼있는지 몰라도 충분히 사용할 수 있음  
이 함수의 기능만 알아도 사용할 수 있는 것  
이를 "추상화를 했다"고 표현함  
추상화를 하면 이미 쓴 코드를 재활용하고 개발자들끼리 협력하기 쉬워짐  
자료구조 사용할 때에도 추상화 많이 사용함

### 추상 자료형
- 자료 구조를 추상화 한 것
- 데이터를 저장/사용할 때 기능만 생각
- 구현은 신경쓰지 않아도 됨

<br/><br/>

## 03. 추상 자료형 vs 자료 구조

### 추상 자료형(Abstract Data Type, ADT)  
자료구조를 추상화한 개념  

#### 리스트
- 데이터간 순서 관계를 유지할 수 있다
- 접근 연산: 특정 위치에 있는 데이터를 가지고 오거나 수정한다
- 탐색 연산: 특정 조건을 만족하는 데이터를 찾는다
- 삽입 연산: 특정 위치에 새로운 데이터를 저장한다
- 삭제 연산: 특정 위치에 있는 데이터를 지운다

리스트는 대표적인 추상 자료형  
리스트는 데이터에 접근, 탐색, 삽입, 삭제를 할 수 있음  
데이터에 무엇을 하고 싶은지(기능) 포함됨, 어떻게(구현)은 포함되지 않음

### 자료 구조

#### 동적 배열
- 데이터를 메모리에 순서대로 그리고 연속적으로 저장한다
- 접근 연산: 인덱스 주소를 한 번에 계산해서 메모리에 접근한다
- 탐색 연산: 가장 앞 인덱스부터 선형적으로 모든 데이터를 확인한다
- 삽입 연산: 인덱스 뒤 데이터를 한 칸씩 뒤로 밀고, 데이터를 저장한다
- 삭제 연산: 데이터를 지우고 뒤 인덱스들을 하나씩 앞으로 옮겨서 저장한다

자료구조는 정확히 어떻게 기능을 할 것인지에 대해 구현을 묶어놓은 개념  
동적 배열은 리스트의 모든 연산들을 갖고 있는 자료 구조  
이때 리스트는 동적 배열로 구현할 수 있다고 표현함  
리스트를 구현하는 자료 구조가 동적 배열만 있는 것은 아님  
링크드 리스트도 접근, 탐색, 삽입, 삭제 연산이 다 있으므로 리스트를 구현하는 자료 구조  

따라서 리스트라는 추상 자료형을 동적 배열이라는 자료 구조 또는 링크드 리스트라는 자료 구조로 구현할 수 있음  
둘 중 어느 것을 사용해야 할지는 상황에 따라 다름  

### 추상 자료형을 알아야 하는 이유
프로그래밍을 할 때 바로 자료 구조를 떠올리는 것보다 추상 자료형을 떠올리는 게 편함  
큰틀에서 생각할 때 도움이 됨  
추상 자료형을 생각하면 코드의 흐름에 집중할 수 있다!

<br/><br/>

## 04. 추상 자료형 vs 자료 구조 현실 비유

### 추상 자료형 vs 자료 구조 현실 비유
추상 자료형과 자료 구조의 차이를 좀 더 현실에 가까운 예시를 들어서 설명해 볼게요.

사실 우리는 프로그래밍할 때 말고 실생활에서도 많은 물건들이나 개념들을 추상화해서 사용합니다. 남녀노소 누구나 가지고 있는 “핸드폰”도 추상화의 한 예시인데요.

“핸드폰”이라는 개념을 어떻게 정의할 수 있을까요? 주변을 보면 핸드폰인 많은 물건들은 있지만 딱 “핸드폰은 X다”라고 하기 쉽지가 않습니다. 한 번 핸드폰의 가장 기본적인 기능들을 정리해서 핸드폰이 뭔지 간단하게 정의해볼게요.

핸드폰은:

특징
- 전기선 없이 이곳저곳 들고 다닐 수 있다

행동
- 전화를 걸 수 있다
- 전화를 받을 수 있다
- 문자 메시지를 보낼 수 있다
- 문자 메시지를 받을 수 있다

이런 기능들을 갖는 것입니다. 핸드폰이 뭔지 물어봤을 때 딱 정확히 손가락으로 가리켜서 “이거다”라고 하기는 힘들지만 “저 기능들을 갖는 어떤 것이다”라고는 얘기할 수 있는 거죠.

조금 다르게 생각해보면 저 기능들을 갖는 존재들을 다 핸드폰이라고도 할 수도 있습니다. 기술적으로 어떻게 구현했는지는 기계가 핸드폰인지 아닌지와 전혀 상관이 없습니다. 그러니까 핸드폰은 구현은 없고 기능으로만 정의한 개념인 추상 자료형과 비슷한 거죠.

추상 자료형을 핸드폰에 비유할 수 있으면, 자료 구조는 뭐에 비유할 수 있을까요? 자료 구조는 핸드폰의 기능들을 가지고 있는 기계 모델들에 비유할 수 있습니다.

아이폰 6s, 삼성 갤럭시 S10, LG v50 이렇게 특정 방식에 의해서 전화와 문자를 보내거나 받을 수 있는 것들이 자료 구조에 해당하는 거죠.

실제로 어떤 모델 또는 회사인지에 따라 부수적으로 갖는 기능들도 다를 수도 있고 전화를 거는 구체적인 방식이 모두 다를 수는 있긴 합니다. 하지만 핸드폰의 모든 기능들을 모두 갖고 있습니다. 실질적으로 “핸드폰”의 기능을 모두 할 수 있으면, 그러니까 핸드폰을 “구현”하고 있으면 핸드폰이라고 부르고 사용할 수 있는 거죠.

여러분들은 평소에 여러분의 핸드폰에 대해 어떤 식으로 얘기를 하시나요? “내 핸드폰 어딨지?”, “너 핸드폰 번호 뭐야?” 이런 식으로 실제 사용하는 핸드폰의 모델명 대신, 추상화해서 핸드폰이라고 표현하면서 사용하는 경우가 많을 텐데요. 물론 “내 갤럭시 S10” 어딨지 이런 식으로 구체적인 모델 이름을 사용해도 틀린 건 아니지만 일반적으로 그렇게 얘기하지는 않죠?

### 컴퓨터 과학에서 추상 자료형
추상 자료형의 개념도 똑같습니다. 추상 자료형 리스트에 대해서 생각해봅시다.

특징
- 데이터 사이 순서 관계를 유지할 수 있다

연산
- 접근 연산: 특정 위치에 있는 데이터를 가지고 오거나 수정할 수 있다
- 탐색 연산: 특정 조건을 만족하는 데이터를 찾을 수 있다
- 삽입 연산: 특정 위치에 새로운 데이터를 저장해줄 수 있다
- 삭제 연산: 특정 위치에 데이터를 지울 수 있다

핸드폰이라는 추상적인 개념과 똑같이 이런 특징과 연산들을 가지는 존재를 “리스트”라고 부르는 겁니다. 여러분들이 핸드폰을 찾을 때 “내 핸드폰 어딨지“ 이런 식으로 얘기하는 것처럼, 데이터를 저장하고 사용할 때도 “리스트를 사용해야겠다!”이런 식으로 추상적으로 얘기할 수 있는 거죠.

### 추상 자료형 vs 자료 구조 뭐가 더 중요할까?
추상 자료형과 자료 구조는 뭐가 더 중요한 건 없습니다. 그냥 서로 다른 개념이죠. 기능을 중점적으로 얘기하고 싶을 때나, 흐름을 생각할 때와 같이 구현에 집중할 필요가 없을 때 추상 자료형을, 그리고 코드의 성능을 분석하거나 최적화 시켜야 될 때나(성능을 최대로 끌어올리고 싶을 때) 자료 구조를 중심적으로 생각하면 됩니다.

핸드폰이라는 개념과 단어가 우리한테 굉장히 중요하고 널리 쓰이는 거 만큼, 정확히 어떤 핸드폰을 쓰는지, 그러니까 아이폰 6s, 삼성 갤럭시 S10, LG v50 중에 어떤 모델을 쓰는지도 많은 사람들한테 굉장히 중요합니다.

그러니까 아이폰 6s보다는 아이폰 11 pro가 훨씬 빠르고, LG v50는 화면이 두 개고, 삼성 갤럭시 노트는 화면이 크고… 이런 구체적인 핸드폰의 세부 구현들도 핸드폰이라는 개념만큼 중요하다는 말이죠.

컴퓨터 과학을 공부하는 우리에게 추상 자료형들과 자료 구조들의 개념이 모두 중요한 거랑 비슷하죠.

<br/><br/>

## 05. 리스트 개념  

파이썬  
- 추상화가 많이 된 고수준 언어
- 개발자들이 구현보다 기능에 집중할 수 있게 해줌
- 많은 자료형 이름이 추상 자료형!
- 파이썬 자료형 list는 구현을 몰라도 기능만 알고 사용할 수 있음!

```python
# 파이썬 리스트 생성
trending = []

# 특정 위치에 데이터 삽입
trending.insert(0, "연예인 A씨")
trending.insert(1, "잠실 콘서트")
trending.insert(2, "한국 휴일 수")
trending.insert(3, "추석 음식")

print(trending)  # 리스트 출력
# ['연예인 A씨', '잠실 콘서트', '한국 휴일 수', '추석 음식']


# 괄호를 이용한 인덱스 접근
print(trending[0])  # 연예인 A씨
print(trending[1])  # 잠실 콘서트

trending[2] = 4

print(trending)
# ['연예인 A씨', '잠실 콘서트', 4, '추석 음식']


# in 을 이용한 탐색
print("연예인 A씨" in trending)  # True
print("연예인 B씨" in trending)  # False


# del 을 이용한 삭제
del trending[0]

print(trending)
# ['잠실 콘서트', 4, '추석 음식']
```

추상 자료형으로서 리스트의 핵심은, 개발자들이 리스트를 떠올릴 때 이걸 정확히 어떻게 구현하고 내부적으로 어떤 자료 구조를 어떻게 사용했는지 전혀 몰라도 됨. 리스트라는 게 무엇을 할 수 있는지, 기능들만 알고 사용할 수 있음

<br/><br/>

## 06. 리스트 구현

리스트 구현은 동적 배열 또는 링크드 리스트로 할 수 있음  
둘 중 어느 걸 사용해야 할까?

|             |     동적 배열    | 더블리 링크드 리스트 |
|:-----------:|:----------------:|:--------------------:|
|     접근    |      $O(1)$      |        $O(n)$        |
|     탐색    |      $O(n)$      |        $O(n)$        |
| 접근 + 삽입 |      $O(n)$      |        $O(n)$        |
| 접근 + 삭제 |      $O(n)$      |        $O(n)$        |
|             |                  |                      |
|  맨 앞 삽입 |      $O(n)$      |        $O(1)$        |
|  맨 앞 삭제 |      $O(n)$      |        $O(1)$        |
|  맨 뒤 삽입 | 분할 상환 $O(1)$ |        $O(1)$        |
|  맨 뒤 삭제 | 분할 상환 $O(1)$ |        $O(1)$        |

어떤 기능을 많이 사용할지를 생각해야 함  
접근을 많이 하고 싶은지, 맨 앞에 삽입을 많이 사용할 것인지  
각 자료구조에서 많이 사용할 연산의 시간 복잡도 비교해서 고르면 됨

접근을 많이 하고 싶을 때, 동적 배열은 $O(1)$, 더블리 링크드 리스트는 $O(n)$이기 때문에 이 경우에는 동적 배열을 사용하면 됨  
가장 앞에 데이터를 계속 삽입하고 싶다면, 동적 배열 사용하면 $O(n)$, 링크드 리스트 사용하면 $O(1)$이기 때문에 링크드 리스트를 사용하면 됨

파이썬 리스트는 내부적으로 동적 배열로 구현되어 있음  

<br/><br/>

23.01.12

## 07. 큐 개념

### 큐(Queue)  
- 리스트와 마찬가지로 데이터 간 순서를 약속하는 추상자료형
- 한국어로 대기열이라고도 함
- 영국에서는 사람들이 줄을 서 있을 때 이 줄을 큐라고도 함
- 마트에서 물건을 살 때: 맨 앞 사람부터 계산하고 나가고, 맨 뒤부터 줄을 섬
- 이처럼 큐는 데이터를 삭제할 떄는 맨 앞에서 삭제하고, 삽입할 때는 가장 뒤에서만 삽입해주는 추상자료형
- FIFO: First In First Out
- 즉, 가장 먼저 들어온 데이터가 가장 먼저 삭제됨

### 큐의 기능
- 데이터 간 순서 관계를 유지할 수 있다
- 맨 뒤 데이터 추가
- 맨 앞 데이터 삭제
- 맨 앞 데이터 접근

### deque
- 파이썬에서는 deque라는 자료형을 사용해서 큐를 쓸 수 있다  
- Doubly-ended-queue의 약자
- 양면큐라는 뜻
- 맨 앞과 뒤에 데이터를 삽입하고 삭제할 수 있게 해주는 자료형

```python
# deque는 파이썬 collections 모듈에서 가지고 온다
from collections import deque

queue = deque()

# 큐의 맨 끝에 데이터 삽입
queue.append("태호")
queue.append("현승")
queue.append("지웅")
queue.append("동욱")
queue.append("신의")

print(queue)  # 큐 출력
# deque(['태호', '현승', '지웅', '동욱', '신의'])


# 큐의 가장 앞 데이터에 접근
print(queue[0])  # 태호


# 큐 맨 앞 데이터 삭제
print(queue.popleft())  # 태호
print(queue.popleft())  # 현승
print(queue.popleft())  # 지웅

print(queue)  # 큐 출력
# deque(['동욱', '신의'])
```

리스트와 마찬가지로 append를 사용해서 맨 뒤에 데이터를 삽입할 수 있음  
파이썬 자료형들은 같은 행동을 하는 연산들은 메소드 이름도 똑같으니 편하게 쓸 수 있음  

[0] 인덱스 접근으로 큐의 가장 앞 데이터에 접근할 수 있음

popleft() 메소드로 맨 앞 데이터를 삭제함과 동시에 삭제하는 데이터를 return할 수 있음

삽입, 접근, 삭제 이 세 가지 연산을 할 수 있으면 queue  
이 기능을 사용하고 싶으면 복잡한 내부 구현을 떠올릴 필요 없이 queue를 떠올리면 되고,  
파이썬에서 queue를 사용하고 싶으면 deque 자료형을 사용하면 됨

<br/><br/>

23.01.13

## 08. 큐 구현

### 큐(Queue)
- 데이터 간 순서 관계를 유지할 수 있다
- 맨 뒤 데이터 추가
- 맨 앞 데이터 삭제
- 맨 앞 데이터 접근

### 큐 구현
- 동적 배열, 링크드 리스트 두 자료구조로 구현할 수 있음
- 어떤 게 더 효율적일까?

|            |     동적 배열    | 더블리 링크드 리스트 |
|:----------:|:----------------:|:--------------------:|
| 맨 앞 삭제 |      $O(n)$      |        $O(1)$        |
| 맨 뒤 삽입 | 분할 상환 $O(1)$ |        $O(1)$        |
| 맨 앞 접근 |      $O(1)$      |        $O(1)$        |

큐를 구현할 때 링크드 리스트는 모든 연산을 $O(1)$으로 할 수 있지만, 동적 배열은 맨 앞 삭제 연산에 $O(n)$이 걸리므로 링크드 리스트가 더 효율적임  
파이썬에서 queue로 사용했던 자료형 deque도 내부적으로는 더블리 링크드 리스트로 구현되어 있음
