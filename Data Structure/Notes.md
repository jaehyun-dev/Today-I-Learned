22.08.13  

자료구조 = 데이터를 저장하고 관리하기 위해 사용하는 구조  
데이터의 효율적인 접근 및 조작을 가능하게 해주는 저장 및 관리 방식  
  
  
22.08.14  
각 상황에 알맞은 자료구조를 사용해야 시간적으로 효율적임 
  
22.08.15 23:45  
예시) python에서 0부터 1000000까지의 정수가 저장되어있는 리스트와 세트가 있을 때, 세트에서 1000000이라는 원소를 찾는 게 라스트에서 찾는 것보다 3000배 정도 빠르다.  
상황에 따라 효율적인 자료구조는 다르고, 각 자료구조마다 장점과 단점이 있기 때문에 모든 경우에 제일 좋은 자료구조는 없다.  
자료구조를 잘 배우면 어떤 자료구조들이 존재하고 어떤 상황에서 어느 자료구조를 써야 하는지 알 수 있다.  
  
22.08.16 23:49  
자료구조의 목적 = 자료를 구조화하여 데이터를 효율적으로 사용하는 것  
컴퓨터에 데이터가 어떻게 저장되는지 알아야 됨  
데이터가 저장되는 곳 두 가지  
1. 스토리지  
데이터가 영구적으로 저장되는 곳  
사진, 음성, 문서파일 등  
사용자가 지우거나 심각한 충격이 있지 않은 이상 사라지지 않음  
데이터를 저장하는 데 오래 걸린다  
데이터를 받아오는 데 오래 걸린다  
창고 같은 역할  
지금 당장 사용하는 게 아니라 나중에 사용할 파일, 정확히 언제 사용할지 모르겠는 파일 저장  
2. 메모리  
데이터가 임시로 저장되는 곳  
데이터를 저장하는 데 빠르다  
데이터를 받아오는 데 빠르다  
책상 서랍 같은 역할  
지금 당장 사용하는 파일 저장  
  
워드 프로세서에서 작성하던 내용은 메모리에 저장됨  
이 상황에서 컴퓨터가 꺼지면 메모리에 있던 내용 사라짐  
만약 작업 도중 저장 버튼을 누르면, 내용은 스토리지에 저장되고 컴퓨터가 꺼져도 사라지지 않음  
  
자료구조를 배울 때는 메모리가 스토리지보다 더 중요함  
메모리에서 데이터를 효율적으로 사용하기 위한 것이 자료구조
  
22.08.17 23:23  
메모리  
일정한 칸으로 나눠져 있는 긴 띠로 비유할 수 있음  
각 칸에 데이터를 저장할 수 있음  
각 칸은 자신만의 주소가 있음  

RAM(Random Access Memory, 임의 접근 메모리)  
임의 접근: 저장 위치를 알면 접근할 때 항상 일정한 시간이 걸림  
따라서 메모리에 저장한 데이터 접근 시간 복잡도: O(1)  
  
비디오 테이프의 경우 원하는 위치로 가려면 한참 걸림  
순차 접근: 저장된 위치까지 가는 데 한 단계씩 거쳐야 됨  
임의 접근이 순차 접근보다 압도적으로 효율적임  

자료 구조 배울 때  
메모리에 데이터를 저장한다  
메모리에 저장된 데이터를 찾는다  
등의 표현은 항상 임의 접근으로 하고 있고 O(1)임을 기억해야 함  
  
  
  
22.08.18 23:30  
메모리는 하나의 긴 띠라고도 표현했는데요. 이 띠는  
  
1. 일정한 칸으로 나눠져 있고  
2. 각 칸에 데이터를 저장할 수 있고  
3. 각 칸은 자신만의 주소가 있습니다  
  
이 메모리 한 칸이 저장할 수 있는 가장 기본적인 용량의 단위는 바이트, 영어로는 byte입니다. 자료 구조를 공부하면서 바이트라는 단위가 정확히 얼만큼의 정보를 저장하는 단위인지는 모르셔도 됩니다. 그냥 엄청 작은 단위라고만 알고 계시면 됩니다.  
  
바이트가 아닌 다른 크기의 용량을 담는 저장 장치들도 있긴 한데요. 대부분의 현대 컴퓨터 시스템들은 메모리 한 칸에 바이트만큼의 데이터를 저장합니다.  
  
일상 생활 속에서도 많은 분들께서 이미 바이트라는 용어를 들어보셨을 텐데요. 흔히 영상, 문서, 음성 파일이나, RAM 또는 컴퓨터의 스토리지의 크기를 표현할 때,  
  
* 160 킬로 바이트(kB)  
* 10 메가 바이트(MB)  
* 32 기가 바이트(GB)  
이런 식으로 많이 표현하는데요. 킬로 바이트, 메가 바이트, 기가 바이트는 그냥 데이터의 용량이 몇 바이트인지 표현한 겁니다. 정확히 얘기하자면,  
  
* 킬로 바이트 = 1,000 바이트  
* 메가 바이트 = 1,000,000 바이트  
* 기가 바이트 = 1,000,000,000 바이트  
이만큼의 저장 공간 용량들이죠.  

자료 구조를 배우면서 바이트나 다른 저장 공간 단위들을 심도 있게 다루지는 않을 건데요. 그래도 자료 구조에서는 이해하면 도움이 되는 개념/용어이니까,  
  
1. 바이트는 컴퓨터 저장 공간 용량을 나태내는 단위다.  
2. 메모리 한 칸에 담기는 데이터 용량은 1 바이트다.  
이 정도는 이해하고 넘어가시면 나중에 나오는 내용을 이해하는 데 조금 더 수월할 거예요!  
  
  
  
22.08.19 23:21  
x = 95  
95라는 정수값을 변수 x에 지정하면 변수 x는 정수 95를 갖는다.  
"x는 95다"는 파이썬에서 틀린 표현.  
x는 95라는 값 자체를 갖는 게 아니라, 95가 담겨있는 메모리 주소를 갖는다.  
이 메모리 주소를 이용해서 정수값 95를 찾아오는 것.   
"x는 95를 가리킨다"가 맞는 표현.  

데이터에 접근하게 해주는 값 = 레퍼런스(reference)  
주소와 레퍼런스는 다르다.  
주소는 메모리의 진짜 실질적인 주소를 말한다.  
레퍼런스는 추상적인 개념, 데이터에 접근할 수 있게 해주는 값, "주소"보다 조금 더 포괄적인 표현.  
하지만 자료구조를 배울 때는 "주소 = 레퍼런스"라고 생각해도 됨.  
  
변수를 사용할 때
```python
x = 95
print(x + 5)
```
실제로 변수를 사용할 때는 저장된 값을 알아서 받아옴.  
파이썬이 메모리에 있는 95를 받아와서, 95 + 5를 print하게 됨.  
  
    
22.08.20 23:24  
## 05. 데이터의 주소  
### 파이썬 id 함수  
데이터가 저장되어 있는 주소를 알아내는 방법을 볼게요.  
id 함수를 이용하면 저장한 데이터의 메모리 주소를 정수로 표현한 값을 알아낼 수 있습니다. 여러 타입의 데이터를 저장하고 id 함수를 써서 메모리 주소를 출력시켜보겠습니다.  
```python
# 여러 데이터를 저장한다
list1 = [1, 2]
int1 = 0
float1 = 3.14
set1 = set()
tuple1 = (2, 3)
    
# 저장한 데이터의 메모리 저장 위치를 받아온다
print(id(list1))
print(id(int1))
print(id(float1))
print(id(set1))
print(id(tuple1))
```
```python
140237662138184
4450309504
140237661913472
140237664406888
140237662993992
```
데이터가 각각 다른 메모리 주소에 저장돼 있군요.  
주소는 코드를 돌릴 때마다 다르게 나오니까 여러분 컴퓨터에 다르게 출력되어도 놀라지 마세요!  

## 같은 주소에 저장돼 있는 데이터  
좀 당연한 말같이 들리실 수도 있는데요. 똑같은 주소에 저장돼 있는 데이터는 똑같은 데이터입니다.  
```python
# 리스트를 정의한다
list1 = [1, 2]
list3 = [1, 2, 3]
    
# Aliasing을 통해 list1과 list2를 같게 한다
list2 = list1
    
# 두 데이터의 메모리를 출력한다
print(id(list1))  # 140657629409160
print(id(list2))  # 140657629409160
print(id(list3))  # 140657629409096
```
위 코드를 살펴봅시다. 세 변수 list1, list2, list3를 만들었습니다.  
list1은 정수 1, 2를, 그리고 list3은 1, 2, 3을 담고 있는 리스트입니다.  
그리고 list2에  list1를 지정했습니다. 메모리에서 만든 하나의 같은 리스트를 list1, list2라는 두 개의 다른 변수가 가리키고 있는 거죠. 이렇게 여러 변수가 같은 메모리를 가리키는 것을 Aliasing이라고 합니다.  
id 함수를 써서 list1과 list2의 메모리 주소를 출력해 보면 같다고 나오죠? list3는 다른 주소에 저장되어 있습니다. list1과 list2는 서로 같은 리스트를 가리키고 있기 때문에 똑같은 메모리가 출력되고, list3는 전혀 다른 리스트를 가리키고 있기 때문에 다른 메모리가 출력되는 거죠.
  
22.08.21 22:10  
질문 1  
  
다음 중 RAM에 대한 설명으로 옳지 않은 것을 모두 고르시오.  
  
1 RAM은 임의 접근 방식을 이용해서 저장한 데이터에 빠르게 접근할 수 있다.  
2 RAM은 동일한 크기의 칸으로 나눠진 굉장히 긴 띠라고 생각하면 편하다.  
3 RAM의 한 칸에 저장되는 데이터의 용량은 1 킬로 바이트다.  
4 RAM에서 데이터에 접근할 때, 더 멀리 있는 주소에 접근하려면 시간이 더 오래 걸린다.  
5 RAM에 저장된 데이터는 임시적으로 저장된다. 데이터를 영구적으로 저장하고 싶으면 스토리지에 저장해야 된다.  
  
  
답> 3번, 4번  

퀴즈 해설  
3: RAM의 한 칸에 저장되는 데이터의 용량은 1 바이트다.  
4: RAM은 접근하려는 데이터의 주소에 상관없이 항상 일정한 시간 내에 접근할 수 있다.  
  
22.08.22 22:55  
질문 2  

다음 문장이 옳은지 틀린지 고르시오.  

x = 5 이 파이썬 코드에서 x는 5라는 데이터 자체를 담고 있는게 아니라 5가 저장된 곳의 레퍼런스를 갖고 있다.  

1 옳다.  
2 틀리다.  

답> 1번  

퀴즈 해설  
파이썬 변수는 실제 데이터를 저장하지 않고 저장한 데이터를 찾는 방법(레퍼런스)을 저장한다.  
print(x + 10) 이렇게 변수에 저장한 데이터를 받아와야 될 때는, 파이썬이 알아서 변수 x에 저장한 데이터인 5를 찾아와서 10에 더해준다. (실제 레퍼런스와 10을 더하지는 않는다)  
  
  
22.08.23 23:59  
배열  
(파이썬 리스트와 비슷)  
파이썬 언어는 C언어 기반으로 만들어졌고, 파이썬 리스트는 C의 배열을 이용해서 만들어졌음  
차이점  
파이썬 리스트에서는 append 메소드를 쓰면 계속해서 요소를 추가할 수 있음  
C 배열은 크기가 고정돼 있음(처음에 크기를 정해놓고 시작)  
배열의 각 요소를 다른 값으로 수정할 수는 있지만, 지우거나 삭제할 수는 없음  
파이썬 리스트에서는 다양한 타입의 값들을 담을 수 있지만, C 배열에서는 같은 타입의 데이터만 담을 수 있음  

```c
int numAraay[4];
```
정수 4개 배열   
메모리에 필요한만큼의 공간을 미리 할당한다  
배열이 쓸 공간을 미리 예약하는 것  
C언어에서 정수는 보통 4byte  
정수 4개 배열은 총 16byte의 메모리가 필요  
연속적인 16칸 예약  
사용할 메모리 공간 정했으면 값들을 채워넣을 수 있음  
```c
numArray[0] = 2;
numArray[1] = 3;
numArray[2] = 5;
numArray[3] = 7;
```
1-4째 칸에 2를 저장    
5-8째 칸에 3을 저장    
9-12째 칸에 5를 저장    
13-16째 칸에 7을 저장    

```python
num_list = [2, 3, 5, 7]
```
파이썬 리스트는 2, 3, 5, 7 값들이 메모리 아예 다른 곳에 저장돼있을 수 있음  
연속적인 공간에 있을 수도 있고 아닐 수도 있음  
16byte 예약된 메모리 공간에는 2, 3, 5, 7이 저장된 레퍼런스가 저장됨  
2, 3, 5, 7을 저장하고 있는 게 아니고 가리키고 있는 개념  
값 자체가 저장되는 게 아니기 때문에, 자료들의 크기가 상관이 없게 됨  
아무리 큰 값이나 작은 값이더라도 가리키기만 하기 때문에, C 배열과 다르게 다양한 타입의 값들을 저장할 수 있음 
  
배열은 가장 기본적인 자료 구조이기 떄문에 중요!

22.08.24 22:38  
배열에 데이터를 저장하고 가지고 오는 법  
```c
int numArray[4];
```
정수는 보통 4byte이기에 정수 4개의 배열을 저장하기 위해서는 16byte 메모리가 필요  
컴퓨터는 메모리에서 사용하고 있지 않은 공간 중 연속적인 16byte인 공간을 찾음  
예를 들어 주소값 1000에서 1015까지  
```c
numArray[0] = 2;
numArray[1] = 3;
numArray[2] = 5;
numArray[3] = 7;
```
정수 2는 주소 1000-1003까지 차지  
정수 3는 주소 1004-1007까지 차지  
정수 5는 주소 1008-1011까지 차지  
정수 7는 주소 1012-1015까지 차지  
배열의 요소들이 메모리에 순서대로, 그리고 연속적으로 저장  
  
불러올 때는 인덱스를 사용하면 됨 
```c
printf("%d", numArray[0]); // 0번 인덱스 값 출력
printf("%d", numArray[1]); // 1번 인덱스 값 출력
printf("%d", numArray[2]); // 2번 인덱스 값 출력
printf("%d", numArray[3]); // 3번 인덱스 값 출력
```
내부적으로 어떻게 이루어지고 있을까?  
numArray는 배열이 시작되는 지점의 주소를 가리키고 있음(1000)
몇 번 인덱스를 받아오고 싶냐에 따라 주소를 찾는다  
예를 들어 2번 인덱스를 받아오고 싶으면  
인덱스 2 주소: 1000 + 4 x 2 = 1008  
인덱스 i 주소: 1000 + 4 x i  
배열이 시작하는 지점의 주소만 알면 어떤 인덱스이든 주소를 쉽게 계산할 수 있음  
  
램은 임의접근 메모리이기에 주소가 있으면 어디에 있든 상관없이 효율적으로 접근할 수 있음(O(1))  
배열의 어떤 인덱스의 값을 받아오려면 그 값의 주소를 알아야 함  
그 주소는 간단한 계산으로 구할 수 있음  
주소를 알면 O(1)으로 접근 가능함  
배열에서 값을 받아오는 건 O(1)으로 할 수 있으므로 굉장히 효율적  
값을 저장하는 것도 똑같음  
특정 인덱스의 값을 저장하기 위해서는 그 인덱스의 주소를 알아야 하는데 값을 받아올 때와 똑같이 주소를 찾아서 그 주소에 O(1)으로 접근하고 거기에 값을 저장하면 됨  
배열 인덱스 접근: O(1)  
배열의 가장 큰 장점  
주소만 정확히 알고 있으면 한 번에 접근할 수 있는 램의 특성을 똑똑하게 이용하는 자료구조  
