# 1 그래프란?

23.02.02

## 01. 연결 관계 데이터와 그래프

### 그래프
- 연결 데이터를 저장할 수 있는 자료 구조

자료구조를 공부하는 이유는 상황에 맞는 방식으로 데이러를 저장하고 사용하기 위함  
데이터의 관계에 따라 적절한 자료구조를 골라서 사용해야 함  
앞과 뒤의 관계가 있으면 배열, 링크드 리스트 등 선형 자료구조 사용하면 됨  
계층적 자료구조를 저장하고 싶으면 트리를 사용하면 됨  

그래프는 연결관계를 표현하기 위해 사용함

연결 관계가 무엇일까?

예시:

### 위치 데이터  
지하철 역 사이의 거리, 걸리는 시간 등이 연결 관계를 나타냄  
연결 관계가 있으면 최단 경로 등을 계산할 수 있음  

### 사회 연결망
SNS 친구관계, 팔로우 관계 등  
추천 친구 뜨는 것도 연결 관계를 이용하는 것  

### 다양한 연결 관계
- 통신: 수많은 컴퓨터들의 연결 관계인 인터넷
- 생물: 유전자와 단백질의 상호 작용 관계

이런 연결 관계를 그래프라는 자료구조를 통해 나타낼 수 있음

<br/><br/>

## 02. 그래프 기본

### 그래프 기본 개념들  
링크드 리스트의 기본 데이터 단위: 노드  
노드에는 저장하려는 데이터와 다른 노드에 대한 레퍼런스 저장  
레퍼런스를 통해 데이터 사이의 선형적 관계를 만듦  

그래프도 노드라는 데이터 단위를 사용  
친구 관계를 예시로  연결 관계를 나타낼 때, 노드는 각각의 사람 한 명 한 명을 나타냄  
그래프에서 노드들 사이의 관계를 엣지라고 하고, 노드 사이에 선으로 표현함  
두 노드(사람) 사이에 엣지(선)를 만들면 연결 관계(친구 관계)라는 뜻  
노드 A와 노드 B가 엣지로 연결되어 있으면, (A, B) 엣지 또는 (B, A) 엣지라고 부름  

### 자주 사용하는 용어:

#### 인접  
두 노드가 엣지로 연결되어 있을 때 서로 인접하다, 인접해있다고 표현함

#### 경로
두 노드가 직접 엣지로 연결되어있지는 않지만, 다른 노드와 모두 연결되어 있어 엣지를 따라 연결된다면, 둘 사이를 잇는 이 길을 경로라고 함  
이때 두 노드는 경로를 통해 연결되었다고 하며, 경로에 포함되는 엣지의 개수를 **거리**라고 함  
두 노드를 연결하는 경로는 없거나 여러 개일 수 있음  
그 중 거리가 가장 작은 경로를 **최단 경로**라고 함  
특정 노드에서 다시 그 노드로 돌아오는 경로는 **싸이클**이라고 함  

#### 차수  
한 노드가 갖고 있는 엣지의 개수  
친구 관계 그래프에서 노드의 차수는 각 사람의 친구가 몇 명인지 나타냄

<br/><br/>

## 03. 방향 그래프

### 무방향 그래프(undirected graph)
친구 관계 그래프처럼, A와 B가 친구이면 B와 A도 친구인 양방향 관계를 나타내는 그래프를 무방향 그래프라고도 함  

인스타그램 팔로우와 같이 양방향, 무방향이 아니라 방향이 있는 관계도 존재  
이럴 때 화살표로 엣지의 방향을 나타낼 수 있음  
A에서 B를 향해 화살표 엣지가 그려져있으면, A를 떠나서 B로 들어가는 엣지라고 표현함  
떠나는 노드를 앞에, 들어가는 노드를 뒤에 적어줌: (A, B) 엣지  
반대 방향으로도 화살표 엣지 그려주면 양방향 관계 성립함  

무방향 그래프와 달라지는 것들  

#### 경로  
A에서 B로 가는 경로가 존재하려면 방향도 A에서 떠나는 엣지와 B로 들어가는 엣지가 존재해야 함

#### 차수  
방향 그래프에서는 차수를 **출력 차수**와 **입력 차수** 두 가지로 나눔  

<br/><br/>

23.02.03  

## 04. 가중치 그래프
엣지에 특정 숫자값을 지정해줄 수 있는 그래프  

예시)  
인천, LA, 뉴욕 노드를 항공선 엣지로 연결하면, 세 공항 사이에 비행기가 다니는 연결 관계를 나타낼 수 있음  
그런데 거리가 다르기 때문에 똑같은 엣지로만 연결하면 불공평함  
이때 (인천, LA) 엣지에는 9, (LA, 뉴욕) 엣지에는 5, (인천, 뉴욕) 엣지에는 13의 가중치를 두어 거리를 나타낼 수 있음  

이처럼 공항 데이터, 도로 데이터 등에서 활용  

무가중치 그래프에서 경로의 거리는 경로에 포함된 엣지의 개수이지만, 가중치 그래프에서는 경로에 있는 모든 엣지의 가중치의 합  
예시)  
무가중치 그래프: 인천 - LA - 뉴욕 경로 거리: 2  
가중치 그래프: 인천 - LA - 뉴욕 경로 거리: 9 + 5 = 14

<br/><br/>

## 05. 그래프 기본 용어/성질 정리  

### 그래프 기본 용어

![image](https://bakey-api.codeit.kr/files/2455/HUdiCM?name=1.png)  

- 노드: 그래프에서 하나의 데이터 단위를 나타내는 객체. SNS 그래프에서는 하나의 유저가 하나의 노드입니다. 위 그래프에서는 노란색 원이 노드를 나타냅니다.  
- 엣지: 그래프에서 두 노드의 직접적인 연결 관계 데이터. 예를 들어, 페이스북 유저 그래프에서는 두 유저의 친구 관계에 해당하는 데이터입니다. 위 이미지에서는 흰 선들이 그래프의 엣지에 해당하죠. 두 노드 사이에 엣지가 있을 때, “두 노드는 인접해 있다” 라고 표현합니다. 엣지가 갖는 특성에 따라 그래프의 종류가 나뉘기도 하는데요.
    - 방향 그래프 (directed graph): 방향 그래프에서는 엣지들이 방향을 갖습니다. 인스타그램의 팔로우 관계처럼 한 유저가 다른 유저를 팔로우하는 일방적인 관계를 나타낼 수 있게 해줍니다.
    - 가중치 그래프 (weighted graph): 가중치 그래프에서는 엣지들이 연결 관계뿐만 아니라 어떤 정보를 나타내는 수치를 가집니다. 그 정보는 예를 들자면 친구 관계에서는 친밀도, 위치 정보 그래프면 두 장소 사이의 거리같은 것입니다.
- 차수: 하나의 노드에 연결된 엣지들의 수입니다.
    - 무방향 그래프에서는 하나의 노드에 연결된 엣지들의 수를 나타내고, 방향 그래프에서는 노드를 떠나는 엣지의 수를 출력 차수, 노드에 들어오는 엣지의 수를 입력 차수로 구별해서 부릅니다.
    - 위 그래프에서 현승 노드의 차수는 3, 영훈 노드의 차수는 2입니다.
- 경로: 한 노드에서 다른 노드까지 가는 길. 지웅 노드와 규리 노드는 서로 인접해 있지 않은데요. 그래도 지웅 노드에서 규리 노드로 갈 수 없는 건 아닙니다. 지금 지웅과 규리는 둘 다 소원 노드와 친구인데요. 그래서 “지웅 - 소원 - 규리” 이 길을 따라가면 지웅 노드에서 규리 노드로 갈 수 있습니다. “지웅 - 소원 - 규리” 이런 길을 경로라고 합니다.
    - 경로의 거리
        - 비가중치 그래프: 한 경로에 있는 엣지의 수.
        - 가중치 그래프: 한 경로에 있는 엣지의 가중치의 합.
    - 최단 경로: 두 노드 사이의 경로 중 거리가 가장 짧은 경로.
    - 사이클: 한 노드에서 시작해서 같은 노드로 돌아오는 경로.

### 연결된 그래프
그래프는 여러 개의 노드와 엣지들을 갖는데요. 그렇다고 해서 그래프 안에 있는 모든 노드들이 서로 경로를 통해 연결될 필요는 없습니다.

SNS 유저 그래프를 만든다고 생각해볼게요. 세상의 모든 유저들이 서로 어떻게든 꼭 연결되어 있는 것은 아니죠?

그래서 아래 그림처럼 서로 연결된 노드들이, 서로 나눠져 있을 수도 있습니다. 보기에는 2개의 무리로 나눠져 있지만 어쨌든 하나의 SNS 유저 그래프라고 할 수 있습니다.

![image](https://bakey-api.codeit.kr/files/2455/uBODov?name=2.png)  

조금 더 극단적인 예시를 보면 심지어 이렇게 아예 엣지가 없고 노드만 있는 그래프도 있을 수 있는 거죠.  

![image](https://bakey-api.codeit.kr/files/2455/fLEV3o?name=3.png)

<br/><br/>

23.02.04  

## 06. 그래프 노드 구현

그래프를 구현하는 것은 노드를 구현하는 것과 엣지를 구현하는 것으로 나뉨  

노드 구현 먼저  

class로 노드 정의  
이때 class의 이름은 Node로 해도 되고, 만들고 싶은 그래프에 따라서 정해주면 됨  
예를 들어 지하철 노선도를 그래프로 표현하고 싶으면, StationNode 등  
init으로 초기화할 때 필요한 정보 넣으면 됨  
역명으로 name, 출구의 개수 num_exits 등  
이외에도 몇 호선인지 line 등 원하는대로 클래스 변수 지정해주면 됨  

먼저 노드 인스턴스를 생성하고 나면, 어떻게 노드에 접근하면 될까?  

링크드 리스트나 트리 같은 경우 head node나 root node를 지정해서 거기서부터 출발  
하지만 연결 관계를 나타내는 그래프는 모든 노드가 동등하기 때문에 먼저 접근하게 되는 특별한 노드가 딱히 없음  
항상 모든 노드에 바로 접근할 수 있게끔 만들면 됨

첫 번째 방법: 배열 또는 동적 배열(파이썬의 리스트 등)에 저장  
이렇게 하면 각 노드마다 인덱스(고윳값)를 지정받고, 원하는 노드에 효율적으로(O(1)) 접근 가능함  

두 번째 방법: 해시 테이블(파이썬의 딕셔너리 등)에 저장  
역 이름을 key, 해당하는 노드를 value로 저장하면 직관적으로 노드를 가지고 올 수 있음  
해시 테이블도 원하는 노드에 효율적으로(O(1)) 접근 가능함  
주의할 점은 만약 SNS 유저와 같이 동명이인이 있을 때 겹치는 key 값을 쓰면 안 되므로, email 등 고윳값을 사용해야 함

[main1_06.py](https://github.com/jaehyun-dev/Today-I-Learned/blob/3d422baa0b2f0b068448cb41953468ce3b0b9cc8/Data%20Structure/3%20Graph/1%20Graph/main1_06.py) 참고  

<br/><br/>

## 07. 그래프 노드 만들어보기

### 실습 설명
지하철 역 정보를 저장하고 있는 텍스트 파일 stations.txt를 사용할 건데요. 안에 데이터가 어떤 형식으로 저장돼 있는지 봅시다. stations.txt의 가장 위 줄을 가지고 올게요.
```
소요산 - 동두천 - 보산 -  동두천중앙 - 지행 -  덕정 -  덕계 -  양주 -  녹양 -  가능 -  의정부 - 회룡 -  망월사 - 도봉산 - 도봉 -  방학 -  창동 -  녹천 -  월계 -  성북 -  석계 -  신이문 - 외대앞 - 회기 -  청량리 - 제기동 - 신설동 - 동묘앞 - 동대문 - 종로5가 -  종로3가 -  종각 -  시청 -  서울역 - 남영 -  용산 -  노량진 - 대방 -  신길 -  영등포 - 신도림 - 구로 -  구일 -  개봉 -  오류동 - 온수 -  역곡 -  소사 -  부천 -  중동 -  송내 -  부개 -  부평 -  백운 -  동암 -  간석 -  주안 -  도화 -  제물포 - 도원 -  동인천 - 인천 -  광명 -  가산디지털단지 - 독산 -  금천구청 -  석수 -  관악 -  안양 -  명학 -  금정 -  군포 -  당정 -  의왕 -  성균관대 -  화서 -  수원 -  세류 -  병점 -  세마 -  오산대 - 오산 -  진위 -  송탄 -  서정리 - 지제 -  평택 -  성환 - 직산 - 두정 -  천안 -  봉명 -  쌍용 -  아산 -  배방 -  온양온천 -  신창 -  서동탄
```
이 줄이 너무 길어서 줄바꿈이 있는 거처럼 보이실 수도 있는데요. 이게 다 한 줄입니다. 내용을 살펴보면 서울 지하철 1호선 노선 데이터가 있죠? 소요산역부터 서동탄역까지 순서대로 저장돼 있고, "-"로 구별돼 있습니다.

stations.txt 파일의 각 줄은 하나의 지하철 노선의 데이터를 저장하고 있습니다. 이번 과제에서는 이 텍스트 파일의 바탕으로 서울 지하철역 노드들을 만들어 볼게요.

#### StationNode 클래스
본격적으로 시작하기 전에 기본으로 제공되는 코드를 설명드리겠습니다.
```python
class StationNode:
    """간단한 지하철 역 노드 클래스"""
    def __init__(self, station_name):
        self.station_name = station_name
```
먼저 제공되는 클래스는 지하철 역 노드 클래스입니다. 이미 영상에서 그래프역 노드들 클래스로 만드는 걸 보셨는데요. 저희는 그보다 간단한 지하철역 노드를 사용할게요. 각 노드 인스턴스는 변수로 역 이름만을 저장하고 있습니다.

#### create_station_nodes() 함수
다음에는 함수 create_station_nodes()를 볼게요. 함수 create_station_nodes()는 파라미터로 input_file을 받습니다. input_file은 문자열이고, 지하철 데이터를 저장하고 있는 파일의 이름입니다. 이 파일의 정보로 지하철 노드들을 만들고, 딕셔너리에 저장해서 리턴합니다.
```python
def create_station_nodes(input_file):
    """input_file에서 데이터를 읽어 와서 지하철 그래프 노드들을 리턴하는 함수"""
    stations = {}  # 지하철 역 노드들을 담을 딕셔너리

    # 파라미터로 받은 input_file 파일을 연다
    with open(input_file) as stations_raw_file:
        for line in stations_raw_file:  # 파일을 한 줄씩 받아온다
            subway_line = line.strip().split("-")  # 앞 뒤 띄어쓰기를 없애고 "-"를 기준점으로 데이터를 나눈다

            for name in subway_line:
                station_name = name.strip()  # 앞 뒤 띄어쓰기 없애기

                # 여기에 코드를 작성하세요

    return stations
```
먼저 파이썬에서 텍스트 파일을 열고 사용하는 게 익숙하지 않으신 분들이 계실 텐데요. 파일은 열고 안에 있는 내용을 전처리하는 부분의 코드는 제공해 드립니다. 한 줄씩 설명드릴게요.
```python
stations = {}  # 지하철 역 노드들을 담을 딕셔너리
```
먼저 stations라는 빈 딕셔너리를 만듭니다. stations.txt 파일에서 데이터로 그래프 노드로 만든 후 여기에 저장할 건데요. 마지막 줄을 보면 이 딕셔너리를 리턴해 줍니다.
```python
# 파라미터로 받은 input_file 파일을 연다
with open(input_file) as stations_raw_file:
```
이 코드는 파라미터로 받은 input_file 파일을 열어줍니다. 파라미터로 받는 input_file은 문자열 타입인데요. 그 이름을 갖는 파일을 열어주는 거죠. 그리고 이 파일을 with문 안에서는 stations_raw_file로 불러준다는 말입니다.
```python
for line in stations_raw_file:  # 파일을 한 줄씩 받아온다
```
연 파일을 for문을 사용해서 살펴봅니다. 변수 line에는 반복문을 한 번 돌 때마다 파일의 한 줄이 위부터 차례대로 저장됩니다.
```python
subway_line = line.strip().split("-")  # 앞 뒤 띄어쓰기를 없애고 "-"를 기준점으로 데이터를 나눈다
```
이건 데이터 전처리 코드인데요. line에는 이런 문자열이 저장돼 있습니다.
```
소요산 - 동두천 - 보산 -  동두천중앙 - 지행 -  덕정 -  덕계 -  양주 -  녹양 -  가능 -  의정부 - 회룡 -  망월사 - 도봉산 - 도봉 -  방학 -  창동 -  녹천 -  월계 -  성북 -  석계 -  신이문 - 외대앞 - 회기 -  청량리 - 제기동 - 신설동 - 동묘앞 - 동대문 - 종로5가 -  종로3가 -  종각 -  시청 -  서울역 - 남영 -  용산 -  노량진 - 대방 -  신길 -  영등포 - 신도림 - 구로 -  구일 -  개봉 -  오류동 - 온수 -  역곡 -  소사 -  부천 -  중동 -  송내 -  부개 -  부평 -  백운 -  동암 -  간석 -  주안 -  도화 -  제물포 - 도원 -  동인천 - 인천 -  광명 -  가산디지털단지 - 독산 -  금천구청 -  석수 -  관악 -  안양 -  명학 -  금정 -  군포 -  당정 -  의왕 -  성균관대 -  화서 -  수원 -  세류 -  병점 -  세마 -  오산대 - 오산 -  진위 -  송탄 -  서정리 - 지제 -  평택 -  성환 - 직산 - 두정 -  천안 -  봉명 -  쌍용 -  아산 -  배방 -  온양온천 -  신창 -  서동탄
```
strip() 메소드를 사용하면 앞 뒤 띄어쓰기를 없애 줍니다. 그리고 split() 메소드는 파라미터로 받은 "-"를 기준으로 데이터들을 나눠 주죠. "소요산", "동두천","보산"… 이런 역 이름 문자열이 담긴 리스트를 리턴합니다. 이 리스트를subway_line 리스트에 저장했습니다.
```python
for name in subway_line:
    station_name = name.strip()  # 앞 뒤 띄어쓰기 없애기
```
다음은 제공된 코드의 마지막 부분인데요. subway_line 리스트에 저장된 각 역을 도는 코드입니다. name은 "소요산 ", " 동두천 ", " 보산 " 이런식으로 앞이나 뒤 또는 둘 다 띄어쓰기가 포함된 문자열입니다. 그러니까 마지막으로 strip() 메소드를 사용해서 전처리해 줍니다. 이러면 이제 station_name에는 역 이름 자체만 남아 있겠죠?

이 역 이름을 갖고 그래프 노드를 만들고 딕셔너리에 저장해 주는 코드를 쓰면 됩니다. 영상에서 본 것처럼 문자열 역 이름을 key로, 그리고 노드 인스턴스를 value로 저장합니다.

### 실습 결과
(전체 결과는 너무 길어서, 일부만 예시로 보여 드립니다.)
```
가능
가락시장
가산디지털단지
가양
가좌
가평
간석
간석오거리
갈매
갈산
강남
강남구청
강동
강동구청
강변
...
```

### 해설

#### create_station_nodes() 함수 완성하기
```python
def create_station_nodes(input_file):
    """input_file에서 데이터를 읽어 와서 지하철 그래프 노드들을 리턴하는 함수"""
    stations = {}  # 지하철 역 노드들을 담을 딕셔너리

    # 파라미터로 받은 input_file 파일을 연다
    with open(input_file) as stations_raw_file:
        for line in stations_raw_file:  # 파일을 한 줄씩 받아온다
            subway_line = line.strip().split("-")  # 앞 뒤 띄어쓰기를 없애고 "-"를 기준점으로 데이터를 나눈다

            for name in subway_line:
                station_name = name.strip()  # 앞 뒤 띄어쓰기 없애기

                # 여기에 코드를 작성하세요

    return stations
```
파일의 각 줄에는 하나의 지하철 노선이 저장돼 있잖아요? 어떤 역들은 여러 개의 호선에 속해 있습니다. 그럼 분명히 반복문을 돌면서 여러번 나오는 역들이 생길 텐데요. 한 번 저장한 역이 또 나오면 굳이 다시 저장할 필요는 없습니다.

station_name을 이미 딕셔너리 key로 저장했는지 확인하고 저장을 안 했을 경우만 새로 인스턴스를 만들어서 저장해 줍니다.
```python
# 지하철 역 이름이 이미 저장한 key 인지 확인
if station_name not in stations:
```
그 다음에는 stations 딕셔너리에 station_name을 key로, 새로만든 역 인스턴스를 value로 저장해 주면 되겠죠?
```python
# 지하철 역 이름이 이미 저장한 key 인지 확인
if station_name not in stations:
    current_station = StationNode(station_name)  # 새로운 인스턴스를 생성하고
    stations[station_name] = current_station  # dictionary에 역 이름은 key로, 역 노드 인스턴스를 value로 저장한다
```

### 모범 답안
create_station_nodes() 함수를 정리하면 이렇게 됩니다.
```python
def create_station_nodes(input_file):
    """input_file에서 데이터를 읽어 와서 지하철 그래프 노드들을 리턴하는 함수"""
    stations = {}  # 지하철 역 노드들을 담을 딕셔너리

    # 파라미터로 받은 input_file 파일을 연다
    with open(input_file) as stations_raw_file:
        for line in stations_raw_file:  # 파일을 한 줄씩 받아온다
            subway_line = line.strip().split("-")  # 앞 뒤 띄어쓰기를 없애고 "-"를 기준점으로 데이터를 나눈다

            for name in subway_line:
                station_name = name.strip()  # 앞 뒤 띄어쓰기 없애기

                # 지하철 역 이름이 이미 저장한 key 인지 확인
                if station_name not in stations:
                    current_station = StationNode(station_name)  # 새로운 인스턴스를 생성하고
                    stations[station_name] = current_station  # dictionary에 역 이름은 key로, 역 노드 인스턴스를 value로 저장한다

    return stations
```

### 테스트 코드
코드가 제대로 돌아가는지 한번 확인해 볼게요.
```python
stations = create_station_nodes("./stations.txt")  # stations.txt 파일로 그래프 노드들을 만든다

# stations에 저장한 역들 이름 출력 (체점을 위해 역 이름 순서대로 출력)
for station in sorted(stations.keys()):
    print(stations[station].station_name)
```

### 실습 결과
원하는 대로 결과가 나오는 걸 확인할 수 있습니다. (전체 결과는 너무 길어서, 일부만 예시로 보여 드립니다.)
```
가능
가락시장
가산디지털단지
가양
가좌
가평
간석
간석오거리
갈매
갈산
강남
강남구청
강동
강동구청
강변
...
```

[main07.py](https://github.com/jaehyun-dev/Today-I-Learned/blob/27eb378acda0505584889d326db0e61b02aae67f/Data%20Structure/3%20Graph/1%20Graph/main1_07.py) 참고  

<br/><br/>

## 08. 엣지 구현 I: 인접 행렬

그래프의 엣지를 구현할 때 두 가지 방법 중 한 방법, 인접 행렬  
모든 노드에 고유 인덱스가 있다  
인접은 연결되었다는 것  
행렬은 2차원 배열, 리스트  

### 인접 행렬
- 노드들의 연결 관계(엣지)를 나타내는 2차원 리스트  

인접 행렬의 각 리스트는 해당 인덱스를 갖는 노드와 연결된 노드 정보를 저장하기 위한 리스트  
리스트 안의 각 원소는 해당 인덱스를 갖는 노드와 연결 되었는지 여부(0은 연결되지 않음, 1은 연결됨)  
예를 들어 인접 행렬 adjacent_matrix[0][1] = 1이면 노드 0과 노드 1이 서로 연결되었다는 의미  
이때 모든 노드는 스스로와 연결되지 않은 것(0)으로 표시  

가중치 그래프에서는 1 대신 가중치로 표시  
방향 그래프에서는, 출력 엣지가 있으면 1, 엣지가 없거나 입력 엣지만 있으면 0  
노드 i와 노드 j가 연결되었는지 알려면 adj_matrix[i][j]로 확인할 수 있음  
만약 노드 i에 연결된 모든 노드를 보려면 adj_matrix[i]로 확인할 수 있음  

### 정리  
- 각 노드를 리스트에 저장해 고유 정수 인덱스를 준다  
- 노드 수 X 노드 수 크기의 행렬을 만든다
- 노드들의 엣지 유무 및 가중치에 따라 행렬의 요소를 채운다  
