# 4 링크드 리스트
22.09.05 23:18  
  
## 01. 링크드 리스트 개념  
  
### 링크드 리스트(Linked List)
- 데이터를 순서대로 저장해준다
- 요소를 계속 추가할 수 있다

동적 배열과 비슷하지만 구현 방식이 조금 복잡함  
처음 배울 때는 굳이 이걸 왜 쓰나 싶을 수 있지만, 상황에 따라 링크드 리스트 사용하는 게 더 적합할 때가 있음  
   
링크드 리스트는 "노드"라는 단위의 데이터를 저장하고 데이터가 저장된 각 노드들을 순서대로 연결시켜서 만든 자료구조  
  
예시) 노드: 박스  
각 박스에는 이름이 있음  
규리, 태호, 동욱, 유나, 현승 등  
박스에는 칸막이 같은 게 있어서 왼쪽 오른쪽에 각각 뭔가를 넣을 수 있음  
왼쪽에는 저장하고 싶은 값을 넣으면 됨  
2, 3, 5, 7, 11을 저장하고 싶다고 가정  
각 박스의 왼쪽 칸에 값을 저장  
규리 박스 왼쪽 칸에 2, 태호 박스 왼쪽 칸에 3 등  
그 후에 2, 3, 5, 7, 11을 순서대로 나열하고 싶으면  
박스들의 이름을 이용하여, 박스의 오른쪽 칸에 다음 박스의 이름을 저장  
2가 담겨있는 규리 박스 오른쪽 칸에 3이 담겨있는 박스의 이름 태호를 넣으면 됨  
같은 식으로 하면 규리, 태호, 동욱, 유나, 현승 박스가 차례로 연결됨
오른쪽 칸이 비어있는 현승 박스는 마지막 박스  

<br/><br/>

22.09.06 23:47  
## 02. 링크드 리스트 프로그래밍적으로 생각하기
노드(Node)  
각 노드는 하나의 객체로 표현됨  
각 노드 객체에는 두 가지 속성이 있음  
데이터와 넥스트  
데이터에는 우리가 저장하고 싶은 정보를 넣음  
박스 비유에서 왼쪽 칸에 넣는 정보를 데이터 속성에 넣는 것  
넥스트 속성은 다음 노드에 대한 레퍼런스  
박스 비유에서 오른쪽 칸과 비슷함  
다음 박스의 이름 대신에 다음 노드에 대한 레퍼런스를 넣는 것  
예를 들어 n_1과 n_2 노드객체가 있다고 가정  
만약 n_1의 다음 노드를 n_2로 설정해주고 싶다면, n_1.next = n_2 지정하면 됨  
n_1.next는 n_2에 대한 레퍼런스  
노드 객체를 여러 개 만들었다고 가정  
이 노드 객체들은 서로 딱히 관계가 없음  
메모리에 연속적으로 저장된 게 아니라 각자 알아서 어딘가에 흩어져있음  
그런데 각 노드는 다음 노드에 대한 레퍼런스가 있음  
노드 객체의 next 속성을 보면 다음 노드가 어디에 저장돼있는지 알 수 있음  
가장 첫번째 노드 객체의 메모리 주소만 알고 있으면 next 타고 타고 가서 연결된 모든 노드 접근 가능  
링크드 리스트의 시작점 역할을 하는 첫 번째 노드 객체를 head라고 함  
head 노드만 있으면 흩어져있는 다른 노드들을 연결지어 순서를 저장할 수 있음  
배열이나 동적 배열처럼 정보를 원하는 순서로 저장할 수 있음  
주의사항  
앞으로 링크드 리스트 나타낼 때 마치 이 객체들이 순서대로 나열되어 있는 것처럼 보여주겠지만 이건 우리의 이해를 돕기 위한 것  
실제 메모리에서는 여기저기 흩어져있음  
  
<br/><br/>

22.09.07 23:04  
## 03. 노드 클래스 만들기
링크드 리스트는 노드 객체로 이루어져있음  
노드 객체를 만들려면 노드 클래스를 정의해야 함  
```python
class Node:
    """링크드 리스트의 노드 클래스"""

    def __init__(self, data):
        self.data = data  # 노드가 저장하는 데이터
        self.next = None  # 다음 노드에 대한 레퍼런스


# 데이터 2, 3, 5, 7, 11을 담는 노드들 생성, 이름을 짓고 변수에 지정
head_node = Node(2)
node_1 = Node(3)
node_2 = Node(5)
node_3 = Node(7)
tail_node = Node(11)
```

<br/><br/>

## 04. 간단한 링크드 리스트 만들기  

```python
class Node:
    """링크드 리스트의 노드 클래스"""

    def __init__(self, data):
        self.data = data  # 노드가 저장하는 데이터
        self.next = None  # 다음 노드에 대한 레퍼런스


# 데이터 2, 3, 5, 7, 11을 담는 노드들 생성, 이름을 짓고 변수에 지정
head_node = Node(2)
node_1 = Node(3)
node_2 = Node(5)
node_3 = Node(7)
tail_node = Node(11)

# 노드들을 연결
head_node.next = node_1
node_1.next = node_2
node_2.next = node_3
node_3.next = tail_node

# 노드 순서대로 출력
iterator = head_node

while iterator is not None:
    print(iterator.data)
    iterator = iterator.next
```
```
2
3
5
7
11
```

<br/><br/>

22.12.30  
## 05. 링크드 리스트 추가 연산  
위에까지는 Node Class를 정의하고 인스턴스를 만들어 연결을 해주었다.  
링크드 리스트라고 할 수는 있는데, 더 체계적으로 관리하기 위해 LinkedList Class 만들 수 있다.  
append 메소드.

[main4_05.py](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/Data%20Structure/main4_05.py) 참고

<br/><br/>

## 06. 링크드 리스트 \_\_str\_\_ 메소드
### \_\_str\_\_ 메소드
링크드 리스트를 클래스로 만들었으니까 링크드 리스트를 문자열로 표현해주는 \_\_str\_\_ 메소드를 정의해봅시다. \_\_str\_\_ 메소드가 기억 안 나시는 분들은 그냥 링크드 리스트를 출력할 때 자동으로 링크드 리스트의 내용을 사람들이 이해할 수 있는 문자열로 리턴해주는 메소드로 이해하시면 됩니다.

### 링크드 리스트 \_\_str\_\_ 메소드
```python
class LinkedList:
    """링크드  리스트 클래스"""
    def __init__(self):
        self.head = None  # 링크드 리스트의 가장 앞 노드
        self.tail = None  # 링크드 리스트의 가장 뒤 노드

    def append(self, data):
        """링크드 리스트 추가 연산 메소드"""
        new_node = Node(data)
        
        # 링크드 리스트가 비어 있으면 새로운 노드가 링크드 리스트의 처음이자 마지막 노드다
        if self.head is None:
            self.head = new_node
            self.tail = new_node
        # 링크드 리스트가 비어 있지 않으면
        else:
            self.tail.next = new_node  # 가장 마지막 노드 뒤에 새로운 노드를 추가하고
            self.tail = new_node  # 마지막 노드를 추가한 노드로 바꿔준다

    def __str__(self):
        """링크드 리스트를 문자열로 표현해서 리턴하는 메소드"""
        res_str = "|"

        # 링크드  리스트 안에 모든 노드를 돌기 위한 변수. 일단 가장 앞 노드로 정의한다.
        iterator = self.head

        # 링크드  리스트 끝까지 돈다
        while iterator is not None:
            # 각 노드의 데이터를 리턴하는 문자열에 더해준다
            res_str += f" {iterator.data} |"
            iterator = iterator.next  # 다음 노드로 넘어간다

        return res_str
```
\_\_str\_\_ 메소드는 문자열을 리턴하니까 일단 리턴 시킬 res_str 변수를 빈 문자열로 정의합니다. iterator을 써서 링크드 리스트를 도는 방법은 이미 배웠죠?
1. iterator 변수를 링크드 리스트의 head를 가리키게 합니다
2. iterator 변수가 None이 아닐 때까지 (링크드 리스트의 처음부터 끝 노드까지) iterator 변수의 data를 res_str 변수에 추가해 줍니다. iterator 변수의 next 속성을 이용해서 while 문을 돌 때마다 다음 노드로 갑니다.
3. 링크드 리스트를 다 돈 후에 res_str 변수를 리턴합니다.

한 번 제대로 코드를 작성했는지 확인해봅시다.
```python
# 새로운 링크드 리스트 생성
linked_list = LinkedList()

# 링크드 리스트에 데이터 추가
linked_list.append(2)
linked_list.append(3)
linked_list.append(5)
linked_list.append(7)
linked_list.append(11)
```
영상에서와 동일하게 링크드 리스트에 노드를 추가해줬습니다.
```python
print(linked_list)  # 링크드 리스트 출력
```
그다음에 이렇게 링크드 리스트 인스턴스를 출력할 건데요. 이때 노트 위에서 정의한 __str__ 메소드가 호출되는 거죠.
```
| 2 | 3 | 5 | 7 | 11 |
```
링크드 리스트의 내용이 원하는 대로 잘 출력되는군요! 앞으로 링크드 리스트에 저장되어 있는 데이터를 확인하기 위해서 \_\_str\_\_ 메소드를 자주 쓸 건데요. 이번 노트에서 정의해놨으니까 다음 레슨들에서 그냥 자연스럽게 사용할게요.

<br/><br/>

## 07. 링크드 리스트 접근

### 배열 접근 연산
```python
int_array[0]
int_array[1] = 11
```
- 특정 위치에 저장한 데이터를 가지고 오거나 바꿔주는 연산

### 링크드 리스트 접근 연산
- 특정 위치에 있는 **노드**를 리턴하는 연산
- 헤드 노드에서 시작해서 다음 노드들을 하나씩 돌면서 원하는 위치의 노드에 접근
- 인덕스 x에 있는 노드에 접근하려면 head에서 다음 노드로 x번 가면 됨

### 링크드 리스트 접근 시간 복잡도
- 인덱스 x에 있는 노드에 접근하려면 head에서 다음 노드로 x번 가면 됨
- 마지막 노드에 접근하려면 head에서 다음 노드로 n-1 번 가야 됨
- 접근 연산 시간 복잡도: $O(n)$

[main4_07.py](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/Data%20Structure/main4_07.py) 참고

<br/><br/>

## 08. 링크드 리스트 탐색 연산

### 실습 설명
탐색 연산은 자료 구조에서 원하는 조건의 데이터를 찾아내는 연산입니다.

링크드 리스트 탐색 연산은 특정 데이터를 갖는 노드를 리턴합니다.

이렇게
```
| 2 | 3 | 5 | 7 | 11
```
링크드 리스트에 2, 3, 5, 7, 11이 저장돼 있다고 합시다. 여기서 5를 갖는 노드를 탐색하면, 링크드 리스트 안에서 5를 가지고 있는 노드를 찾아서 리턴하는 거죠.

배열에서 탐색 연산을 어떻게 하셨는지 기억 나시나요? 선형적으로 가장 앞부터 마지막 인덱스까지 돌면서 탐색을 했습니다. 링크드 리스트도 배열과 마찬가지로 선형 탐색을 사용합니다. 가장 앞 노드부터 끝 노드까지 돌면서 원하는 데이터를 갖는 노드를 리턴하죠.

이번 과제에서는 링크드 리스트의 탐색 연산을 직접 구현해 볼게요.

메소드 find_node_with_data는 찾으려는 데이터를 파라미터 data로 받아서 링크드 리스트 내에서 원하는 데이터를 갖고 있는 노드를 리턴합니다.

단, 원하는 데이터가 링크드 리스트 안에 없을 때는 None을 리턴합니다.

### 실습 결과
```
2
11
6을 갖는 노드는 없습니다
```

<br/><br/>

### 해설
해설 노트에서 링크드 리스트 클래스를 전부 다 보여주기에는 공간이 너무 많이 차지되기 때문에 과제마다 해당 메소드와 실행 코드만 보여드리겠습니다!

#### find_node_with_data 메소드
```python
def find_node_with_data(self, data):
    """링크드 리스트에서 탐색 연산 메소드. 단, 해당 노드가 없으면 None을 리턴한다"""
    iterator = self.head  # 링크드 리스트를 돌기 위해 필요한 노드 변수
```
링크드 리스트를 처음부터 끝까지 돌 때는 \_\_str\_\_ 메소드나 find_node_at 메소드를 쓸 때랑 똑같이 iterator 변수를 사용합니다. 처음에 iterator 변수는 링크드 리스트의 헤드 노드를 가리키게 합니다.
```python
# 링크드 리스트 전체를 돈다
while iterator is not None:
    # iterator 노드의 데이터가 찾는 데이터면 iterator를 리턴한다
    if iterator.data == data:
        return iterator
    iterator = iterator.next  # 다음 노드로 넘어간다
```
그리고 링크드 리스트를 도는데요. while문을 이용해서 head에서 tail 노드까지 돕니다. iterator 변수가 반복문을 돌 때마다 다음 순서에 있는 노드를 가리키는데요. iterator가 None이면 더이상 다음 노드가 없다는 말, 그러니까 링크드 리스트 끝까지 도달했다는 뜻입니다.

반복문 안에서는 if문을 사용해서 현재 보고 있는 노드 iterator 변수의 속성이 파라미터로 받은 data인지 확인해 줍니다. 맞다면 iterator 변수, 즉 현재 돌면서 확인하고 있는 노드를 리턴하는 거죠.
```python
    # 링크드 리스트 안에 원하는 데이터가 없었기 때문에 None 리턴한다
    return None
```
링크드 리스트의 모든 노드를 다 돌았는데 원하는 조건의 노드를 못 찾은 경우는 뭘까요? 원하는 조건의 노드가 링크드 리스트 안에 없다는 거죠. 이 때는 None을 리턴합니다.



### 모범 답안
위 해설 코드를 다 합치면 이렇게 되겠죠?
```python
def find_node_with_data(self, data):
    """링크드 리스트에서 탐색 연산 메소드. 단, 해당 노드가 없으면 None을 리턴한다"""
    iterator = self.head  # 링크드 리스트를 돌기 위해 필요한 노드 변수

    # 링크드 리스트 전체를 돈다
    while iterator is not None:
        # iterator 노드의 데이터가 찾는 데이터면 iterator를 리턴한다
        if iterator.data == data:
            return iterator
        iterator = iterator.next  # 다음 노드로 넘어간다

    # 링크드 리스트 안에 원하는 데이터가 없었기 때문에 None 리턴한다
    return None 
```
#### 테스트 코드
제대로 동작하는지 실행 코드를 돌려 볼게요.
```python
# 새로운 링크드 리스트 생성
linked_list = LinkedList()

# 여러 데이터를 링크드 리스트 마지막에 추가
linked_list.append(2)
linked_list.append(3)
linked_list.append(5)
linked_list.append(7)
linked_list.append(11)

# 데이터 2를 갖는 노드 탐색
node_with_2 = linked_list.find_node_with_data(2)

if not node_with_2 is None:
    print(node_with_2.data)
else:
    print("2를 갖는 노드는 없습니다")

# 데이터 11을 갖는 노드 탐색
node_with_11 = linked_list.find_node_with_data(11)

if not node_with_11 is None:
    print(node_with_11.data)
else:
    print("11를 갖는 노드는 없습니다")

# 데이터 6 갖는 노드 탐색
node_with_6 = linked_list.find_node_with_data(6)

if not node_with_6 is None:
    print(node_with_6.data)
else:
    print("6을 갖는 노드는 없습니다")
```
결과가 제대로 출력되는 걸 확인할 수 있습니다.
```
2
11
6을 갖는 노드는 없습니다
```

[main4_08.py](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/Data%20Structure/main4_08.py) 참고

<br/><br/>

23.01.02  
## 09. 링크드 리스트 삽입 연산

append 메소드는 Linked List 끝에 새로운 데이터를 추가하는 방법  
Linked List의 Node가 주어졌을 때 그 노드 바로 뒤에 새로운 Node를 삽입하는 insert_after도 생각할 수 있다

[main4_09.py](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/Data%20Structure/main4_09.py) 참고

<br/><br/>

## 10. prepend: 링크드 리스트 가장 앞 삽입

### 실습 설명
저번 레슨에서는 링크드 리스트에서 주어진 노드 뒤에 새로운 노드를 삽입하는 연산을 배웠는데요. 이 연산을 메소드로 구현했을 때는 insert_after 메소드로 구현했습니다.

사실 이 연산에는 한 가지 흠이 있는데요. 이 연산은 항상 주어진 노드 다음에 노드를 삽입하잖아요? 파라미터로 가장 앞 노드 head를 넘겨줘도 head 노드 앞에는 새로운 노드를 추가할 수 없습니다. 링크드 리스트 가장 앞에는 삽입할 수 없다는 거죠.

이 문제를 해결해주는 새로운 메소드를 정의해 줍시다. 이 메소드는 prepend라고 부르고요, 파라미터로 데이터 data를 받아서 링크드 리스트의 가장 앞에 데이터를 data로 갖는 새로운 노드를 추가시켜 줍니다.

주의 사항: prepend 메소드를 작성할 때 링크드 리스트가 비어 있는 경우도 생각해서 작성하셔야 됩니다!

### 실습 결과
```
| 2 | 3 | 5 | 7 | 11 |
2
11
```

[main4_10.py](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/Data%20Structure/main4_10.py) 참고

<br/><br/>

## 11. 링크드 리스트 삭제  

삭제 연산 메소드 delete_after  
파라미터로 previous_node 받고 그 다음 순서 데이터를 지워줌  
삭제하려는 노드가 tail노드인지 아닌지 두 경우로 나뉨  
각 경우 나누어 삭제 및 남은 노드 연결해주고  
삭제하는 노드의 데이터를 보여주는 게 관습이기 때문에 삭제되는 데이터를 return

[main4_11.py](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/Data%20Structure/main4_11.py) 참고

<br/><br/>

23.01.03  

## 12. popleft 링크드 리스트 가장 앞 삭제

### 실습 설명
바로 전 레슨에서 배운 삭제는 삽입과 마찬가지의 문제가 있는데요. 주어진 노드의 다음 노드를 삭제하기 때문에 head 노드를 삭제할 수 없습니다. 전과 마찬가지로 head 노드도 지울 수 있도록 메소드를 추가하겠습니다.

메소드 pop_left는 파라미터로 self 이외에 아무것도 받지 않으며, 링크드 리스트의 head 노드를 삭제해줍니다. pop_left 메소드는 링크드 리스트에서 삭제하는 노드의 데이터를 리턴합니다.

### 주의 사항
- pop_left 메소드를 호출함으로 인해서 링크드 리스트가 비어지는 경우를 생각해서 작성하셔야 됩니다! (지우려는 노드가 링크드 리스트의 마지막 남은 노드일 때)
- pop_left를 호출할 때 링크드 리스트가 비어 있는 경우는 없다고 가정해도 됩니다.
- pop_left 메소드는 삭제하는 노드의 데이터를 리턴합니다.

### 실습 결과
```
2
3
5
7
11
|
None
None
```

<br/><br/>

### 해설
#### 경우 1: 삭제하려는 노드가 마지막 남은 노드일 때
```python
def pop_left(self):
    """링크드 리스트의 가장 앞 노드 삭제 메소드. 단, 링크드 리스트에 항상 노드가 있다고 가정한다"""
    # 지우려는 데이터가 링크드 리스트의 마지막 남은 데이터일 때
    if self.head is self.tail:
        self.head = None
        self.tail = None
```
링크드 리스트에 하나의 노드만 남은 경우는 가장 앞 노드가 동시에 가장 마지막 노드인 경우입니다. 이 경우는 if self.head is self.tail의 if문으로 찾을 수 있습니다.

이 경우에는 링크드 리스트에 남은 노드가 하나도 없게 해야 됩니다. head와 tail 속성을 모두 None을 가리키게 하면 되죠.

#### 경우 2: 삭제하려는 노드가 마지막 남은 노드가 아닐 때
```python
else:
    # 링크드 리스트의 head를 지금 head의 다음 노드로 지정해준다
    self.head = self.head.next
```
경우가 두 개밖에 없기 때문에 else문을 사용해서 두 번째 경우를 찾습니다.

head 노드를 더 이상 찾을 수 없게 해주는 동시에 인덱스 1에 있는 노드를 head로 만들어 줘야 되는데요. 이때 그냥 self.head 속성이 현재 head 노드의 다음 노드를 가리키게 하면 됩니다. 그럼 링크드 리스트 안에 원래 head 노드를 가리키는 레퍼런스는 없어지고, 링크드 리스트의 가장 앞 노드가 한 순서 뒤로 밀렸으니까 head 노드를 삭제했다고 할 수 있겠죠?

#### 삭제하는 데이터 리턴
```python
def pop_left(self):
    """링크드 리스트의 가장 앞 노드 삭제 메소드. 단, 링크드 리스트에 항상 노드가 있다고 가정한다"""
    data = self.head.data  # 삭제할 노드를 미리 저장해놓는다

    # 지우려는 데이터가 링크드 리스트의 마지막 남은 데이터일 때
    if self.head is self.tail:
        self.head = None
        self.tail = None
    else: 
        self.head = self.head.next

    return data  # 삭제된 노드의 데이터를 리턴한다
```
이렇게 메소드 가장 위 부분에 삭제하는 노드의 데이터를 변수에 저장하고, 마지막에 리턴해 주면 됩니다.

코드가 제대로 실행되는지 볼게요.

#### 테스트 코드
```python
# 새로운 링크드 리스트 생성
linked_list = LinkedList()

# 여러 데이터를 링크드 리스트 앞에 추가
linked_list.prepend(11)
linked_list.prepend(9)
linked_list.prepend(5)
linked_list.prepend(3)
linked_list.prepend(2)

print(linked_list) # 링크드 리스트 출력

# 가장 앞 노드 계속 삭제
print(linked_list.pop_left())
print(linked_list.pop_left())
print(linked_list.pop_left())
print(linked_list.pop_left())
print(linked_list.pop_left())

print(linked_list) # 링크드 리스트 출력
print(linked_list.head)
print(linked_list.tail)
```

### 실습 결과
```
2
3
5
7
11
|
None
None
```
[main4_12.py](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/Data%20Structure/main4_12.py) 참고



<br/><br/>



23.01.04  
## 13. 링크드 리스트 시간 복잡도

### 링크드 리스트 연산들 시간 복잡도
이번 챕터 내내 링크드 리스트가 무엇이고 어떤 연산들을 할 수 있는지 봤는데요. 접근, 탐색, 삽입, 그리고 삭제 연산들을 봤습니다. 이 네 개의 연산들의 시간 복잡도를 평가해볼게요.

#### 접근
접근부터 봅시다. 사실 접근은 이미 시간 복잡도를 알아봤는데요. 복습하는 느낌으로 볼게요. 인덱스 x에 있는 데이터에 접근하려면 링크드 리스트의 head 노드부터 x 번 다음 노드를 찾아서 가야 됩니다.

원하는 노드에 접근하는 시간은 몇 번째 인덱스인지에 비례하는 건데요.

그러니까 인덱스 1에 있는 노드는 head 노드에서 한 번만 다음 노드로 가면 되고 인덱스 5에 있는 노드는 head 노드에서 연속해서 5 번 이동하면 되는 거죠. 링크드 리스트 안에 있는 노드의 수를 $n$이라고 하면, 마지막 순서에 있는 노드에 접근해야 되는 최악의 경우에는 head 노드에서 총 $n - 1$ 번 다음 노드로 가야 됩니다. 걸리는 시간은 $n$에 비례하기 때문에 접근 연산은 최악의 경우 $O(n)$의 시간 복잡도를 갖습니다.

#### 탐색
링크드 리스트 탐색 연산은 배열을 탐색할 때와 같은 방법으로 합니다. 가장 앞 노드부터 다음 노드를 하나씩 보면서 원하는 데이터를 갖는 찾습니다. 이런 탐색 방법을 선형 탐색이라고 했는데요. 접근과 마찬가지로 링크드 리스트 안에 찾는 데이터가 없을 때 또는 찾으려는 데이터가 마지막 노드에 있는 최악의 경우, $n$ 개의 노드를 모두 다 봐야 됩니다. 그렇기 때문에 탐색도 접근과 마찬가지로 최악의 경우 $O(n)$의 시간 복잡도를 갖습니다.

#### 삽입/삭제
링크드 리스트의 삽입과 삭제 연산은 배열 삽입과 조금 차이가 있었는데요. insert_after, delete_after 메소드들을 한 번 살펴보세요.
```python
def insert_after(self, previous_node, data):
    """파라미터 data를 데이터로 갖는 새로운 노드를 만들어서 node 파라미터 뒤에 삽입시킨"""
    new_node = Node(data) # 새로운 노드 만들기

    # tail 노드 다음에 새로운 노드를 삽입할 때
    if previous_node == self.tail: 
        previous_node.next = new_node
        self.tail = new_node
    # 두 노드 사이에 새로운 노드를 삽입할 때
    else:
        new_node.next = previous_node.next
        previous_node.next = new_node

def delete_after(self, previous_node):
    """파라미터로 받은 노드 다음 노드를 삭제한다. 단, 파라미터 previous노드로 인해서 에러는 안 난다고 가정한다"""
    data = previous_node.next.data

    # 지우려는 노드가 tail 노드일 때
    if previous_node.next == self.tail:
        self.tail = previous_node
        self.tail.next = None
    # 두 노드 사이의 노드를 지울 
    else:
        previous_node.next = previous_node.next.next

    return data
```
삽입, 삭제는 그냥 삽입, 삭제할 인덱스의 주변 노드들에 연결된 레퍼런스만 수정합니다.

그러니까 이 연산들이 실행되는데 걸리는 시간은 특정 값에 비례하지 않고 항상 일정하다는 말인데요. 파라미터로 받는 이 노드가 어떤 순서에 있는 노드든 상관없이 걸리는 시간은 변하지 않는 거죠. $O(1)$의 시간 복잡도를 갖는다고 할 수 있습니다.

#### 시간 복잡도
모든 걸 종합해보면 이렇게 나타낼 수 있습니다.  
| 연산 | 시간 복잡도 |
|:----:|:-----------:|
| 접근 |   $O(n)$  |
| 탐색 |   $O(n)$  |
| 삽입 |   $O(1)$  |
| 삭제 |   $O(1)$  |  

접근과 탐색은 $O(n)$, 삽입과 삭제는 $O(1)$이죠.

#### 현실적인 삽입/삭제 시간 복잡도
하지만 조금 더 현실적으로 생각해봅시다. 삽입과 삭제 연산들은 특정 노드를 넘겨줘서 이 노드 다음 순서에 데이터를 삽입하거나 삭제했잖아요? 그럼 이 연산들에 넘겨주는 노드, 파라미터 previous_node를 먼저 찾아야 되는데요. head와 tail 노드는 항상 저장해주기 때문에 빨리 찾을 수 있는데, 나머지 노드들은 탐색이나 접근 연산을 통해서 가지고 와야 됩니다.

그러니까 현실적으로는 이렇게 되는 거죠.  
|                 연산                | 링크드 리스트 |
|:-----------------------------------:|:-------------:|
|                 접근                |      $O(n)$     |
|                 탐색                |      $O(n)$     |
| 원하는 노드에 접근 또는 탐색 + 삽입 |    $O(n + 1)$   |
| 원하는 노드에 접근 또는 탐색 + 삭제 |    $O(n + 1)$   |   

사실상 삽입과 삭제 연산은 접근 또는 탐색의 시간 복잡도인 $O(n)$를 공유한다고 볼 수 있습니다.

#### 삽입 삭제 연산 특수 경우 시간 복잡도
근데 아까 얘기했듯이, head와 tail 노드는 항상 한 번에 찾을 수 있었죠? 접근하는데 $O(1)$, 연산을 하는 데 $O(1)$이 걸리는데요. 그렇기 때문에 이 두 노드와 관련있는 삽입이나 삭제 연산들은 $O(1)$로 할 수 있습니다.
append, prepend, pop_left 메소드를 살펴보면 head 노드와 tail 노드를 한 번에 가지고 와서 레퍼런스를 바꿔주죠?
```python
def pop_left(self):
    """링크드 리스트의 가장 앞 노드를 삭제해주는 메소드, 단 링크드 리스트에 항상 노드가 있다고 가정한다"""
    data = self.head.data  # 삭제할 노드를 미리 저장해놓는다

    # 지우려는 데이터가 링크드 리스트의 마지막 남 데이터일 때
    if self.head is self.tail:
        self.head = None
        self.tail = None
    else:
        self.head = self.head.next

    return data  # 삭제된 노드의 데이터를 리턴한다


def prepend(self, data):
    """링크드 리스트의 가장 앞에 데이터 삽입"""
    new_node = Node(data)  # 새로운 노드를 만든다

    # 링크드 리스트가 비었는지 확인
    if self.head is None:
        self.tail = new_node
    else:
        new_node.next = self.head   # 새로운 노드의 다음 노드를 head 노드로 정해주고

    self.head = new_node   # 리스트의 head_node를 새롭게 삽입한 노드로 정해준다


def append(self, data):
    """파라미터로 받은 데이터를 갖는 노드를 생성한다"""
    new_node = Node(data)

    # 링크드 리스트가 비어 있으면 새로운 노드가 링크드 리스트의 처음이자 마지막 노드다
    if self.head == None:
        self.head = new_node
        self.tail = new_node
    # 링크드 리스트가 비어 있지 않으면
    else:
        self.tail.next = new_node  # 가장 마지막 노드 뒤에 새로운 노드를 추가하고
        self.tail = new_node  # 마지막 노드를 추가한 노드로 바꿔준다
```
링크드 리스트 안에 몇 개의 노드가 있던 상관없이, 항상 한 번에 받아와서 레퍼런스를 바꿔줍니다.

이렇게 표현할 수 있겠네요.  
|          연산         | 링크드 리스트 |
|:---------------------:|:-------------:|
| 가장 앞에 접근 + 삽입 |    $O(1 + 1)$   |
| 가장 앞에 접근 + 삭제 |    $O(1 + 1)$   |
| 가장 뒤에 접근 + 삽입 |    $O(1 + 1)$   |  

양 끝에서 하는 삽입/삭제 연산들 중 유일하게 tail 노드를 삭제하는 경우는 빠졌죠?

tail 노드를 삭제하기 위해서는 바로 전 노드가 필요한데요. 이 노드를 찾으려면 head 노드에서 $n - 2$번 다음 노드로 가야 됩니다. 접근하는데 $O(n - 2)$, 그러니까 $O(n)$의 시간 복잡도가 걸립니다. 접근한 노드에서 다음 노드를 삭제하는 건 $O(1)$이 걸리잖아요?. 그러니까 tail 노드 전 노드에 접근해서 tail 노드를 삭제하는 건 $O(n + 1)$, 결국 $O(n)$인 거죠.
|                         연산                        |  링크드 리스트 |
|:---------------------------------------------------:|:--------------:|
|                가장 앞에 접근 + 삽입                | $O(1)$ |
|                가장 앞에 접근 + 삭제                | $O(1)$ |
|                가장 뒤에 접근 + 삽입                | $O(1)$ |
| 뒤에서 두 번째 노드 (tail 노드 전 노드) 접근 + 삭제 | $O(n)$ |  

링크드 리스트 가장 뒤 노드 삭제 연산은 나머지 세 연산만큼 효율적으로 할 수 없습니다.

<br/><br/>

23.01.05  
## 14. 더블리 링크드 리스트  

### 싱글리 링크드 리스트
지금까지 배운 개념은 싱글리 링크드 리스트  
각 노드가 바로 다음 노드에 대한 레퍼런스만 갖고 있음  
개념적으로 이해하고 구현하기 쉬움  
이번 레슨부터 각 노드가 다음 노드에 더해 이전 노드에 대한 레퍼런스도 저장하고 있는 더블리 링크드 리스트에 대해 배울 것  

### 더블리 링크드 리스트
각 노드는 뒤 노드와 앞 노드의 레퍼런스를 모두 가짐  

싱글리 링크드 리스트 노드는 data와 next를 저장함  
next를 이용해서 head에서 원하는 노드까지 찾아감  

더블리 링크드 리스트 노드는 전 노드에 대한 레퍼런스 prev(previous의 줄임)도 저장함  
뒤 뿐만 아니라 앞에 있는 노드도 찾을 수 있음  

[main4_14.py](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/Data%20Structure/main4_14.py) 참고

<br/><br/>

## 15. 더블리 링크드 리스트 겹치는 메소드

### 더블리 링크드 리스트 겹치는 연산들
사실 더블리 링크드 리스트는 \_\_init\_\_ 메소드 말고도 싱글리 링크드 리스트에서 안 바꿔도 되는 메소드들이 좀 있는데요.

구체적으로 말하면 find_node_at(접근 연산), find_node_with_data(탐색 연산), 그리고 \_\_str\_\_  메소드가 싱글리 링크드 리스트랑 겹칩니다.

그래서 더블리 링크드 리스트를 배울 때도 이 메소드들은 이미 있다는 가정하에 배울 건데요. 참고하시기 편하게 아래에 메소드 별로 적어놨습니다.

혹시 이번 노트에서 보시는 메소드 중에서 이해가 안 되는 부분이 있으면 챕터 앞 부분의 레슨들을 복습하시고 넘어가시는 걸 추천드릴게요.

#### 접근
```python
def find_node_at(self, index):
    """링크드 리스트 접근 연산 메소드. 파라미터 인덱스는 항상 있다고 가정한다"""
    
    iterator = self.head  # 링크드 리스트를 돌기 위해 필요한 노드 변수
    
    # index 번째 있는 노드로 간다
    for _ in range(index):
        iterator = iterator.next
    
    return iterator
```
#### 탐색
```python
def find_node_with_data(self, data):
    """링크드 리스트에서 주어진 데이터를 갖고있는 노드를 리턴한다. 단, 해당 노드가 없으면 None을 리턴한다"""
    iterator = self.head  # 링크드 리스트를 돌기 위해 필요한 노드 변수
    
    while iterator is not None:
        if iterator.data == data:
            return iterator

        iterator = iterator.next

    return None
```
#### \_\_str\_\_ 메소드
```python
def __str__(self):
    """링크드 리스트를 문자열로 표현해서 리턴하는 메소드"""
    res_str = "|"

    # 링크드 리스트 안에 모든 노드를 돌기 위한 변수. 일단 가장 앞 노드로 정의한다.
    iterator = self.head

    # 링크드 리스트 끝까지 돈다
    while iterator is not None:
        # 각 노드의 데이터를 리턴하는 문자열에 더해준다
        res_str += " {} |".format(iterator.data)
        iterator = iterator.next  # 다음 노드로 넘어간다

    return res_str
```

[main4_15.py](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/Data%20Structure/main4_15.py) 참고

<br/><br/>

## 16. 더블리 링크드 리스트 추가 연산

싱글리 링크드 리스트와 거의 비슷하고, new_node의 prev를 지정해주는 것만 추가해주면 

```python
def append(self, data):
    """링크드 리스트 추가 연산 메소드"""
    new_node = Node(data)  # 새로운 데이터를 저장하는 노드

    # 링크드 리스트가 비어 있는 경우
    if self.head is None:
        self.head = new_node
        self.tail = new_node
    # 링크드 리스트에 이미 노드가 있는 경우
    else:
        self.tail.next = new_node
        new_node.prev = self.tail
        self.tail = new_node
```

[main4_16.py](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/Data%20Structure/main4_16.py) 참고

<br/><br/>

## 17. 더블리 링크드 리스트 삽입 연산 개념

tail 노드 뒤에 삽입하는 경우와, 두 노드 사이에 삽입하는 경우로 나누어서 생각해야 함  
1. tail 노드 뒤에 삽입하는 경우는 append와 동일  
2. 두 노드 사이에 삽입하는 경우는  
    1. new_node의 prev에 previous_node를, new_node의 next에 previous_node.next를 연결한다
    2. previous_node.next.prev에 new_node를, previous_node.next에 new_node를 연결한다

[main4_17.py](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/Data%20Structure/main4_17.py) 참고

<br/><br/>

## 18. 더블리 링크드 리스트 삽입 연산 구현

### 실습 설명
저번 영상에서는 더블리 링크드 리스트에 노드 삽입을 어떻게 하는지 두 개의 경우를 나눠서 봤는데요. 이번 과제에서는 영상에서 배운 내용을 바탕으로 직접 삽입 연산을 하는 메소드 insert_after를 작성해 볼게요.

insert_after 메소드는 파라미터로 노드 previous_node와 삽입할 정보 data를 받습니다. 그리고 previous_node 다음 위치에 data를 저장하는 노드를 삽입합니다.

insert_after 메소드를 직접 코드로 구현해 보세요!

### 실습 결과
```
| 2 | 3 | 5 | 7 | 11 |
| 2 | 3 | 5 | 7 | 11 | 5 |
5
| 2 | 3 | 5 | 7 | 3 | 11 | 5 |
| 2 | 3 | 5 | 2 | 7 | 3 | 11 | 5 |
```

<br/><br/>

### 해설

#### 새로운 노드 생성
```python
def insert_after(self, previous_node, data):
    """주어진 노드 다음에 데이터를 추가시켜주는 메소드"""
    new_node = Node(data)  # 새로운 노드 생성
```
링크드 리스트에 새로운 데이터를 더해줄 때는 항상 그 데이터를 저장하는 새로운 노드를 만듭니다. 파라미터 data를 저장하는 노드를 만들고 변수 new_node에 저장해 줄게요.

#### 경우 1: tail 노드 뒤에 삽입할 때:
```python
# tail 노드 다음에 노드를 삽입할 때
if previous_node is self.tail:
    self.tail.next = new_node  # 새로운 노드를 tail 노드의 다음 노드로 지정한다
    new_node.prev = self.tail  # tail 노드를 새로운 노드의 전 노드로 지정한다
    self.tail = new_node  # 새로운 노드를 tail 노드로 지정한다
```
먼저 tail 노드 뒤에 데이터를 삽입하는 경우부터 봅시다. tail 노드 뒤에 삽입하는 경우는 insert_after 메소드가 파라미터로 받은 previous_node가 tail 노드인지 확인합니다. insert_after 메소드는 previous_node 뒤에 새로운 노드를 삽입하잖아요? 그러니까 previous_node가 tail 노드인지 확인하면 tail 노드 뒤에 삽입하는 경우인지를 알 수 있는 거죠.

이 경우에는 new_node를 기존 tail 노드와 연결시켜주고, tail 노드를 new_node로 만들어 주면 됩니다.

영상에서 봤듯이 아래 세 가지를 해주면 되죠.
1. 새로운 노드를 tail 노드의 다음 노드로 지정한다
2. tail 노드를 새로운 노드의 전 노드로 지정한다
3. 새로운 노드를 tail 노드로 지정한다

#### 경우 2: 두 노드 사이에 삽입할 때:
```python
else:
    # 새롭게 생성한 노드를 이미 있는 링크드 리스트에 연결시키고
    new_node.prev = previous_node 
    new_node.next = previous_node.next

    # 이미 있는 노드들의 앞과 다음 레퍼런스를 새롭게 생성한 노드로 지정한다
    previous_node.next.prev = new_node
    previous_node.next = new_node
```
두 노드 사이에 삽입하는 경우는 else문을 써서 처리해 줍니다. 이 경우는 새롭게 만든 노드를 링크드 리스트에 연결하고, 링크드 리스트에 있는 노드들을 새롭게 만든 노드에 연결하면 됩니다.

1. 새롭게 만든 노드를 링크드 리스트에 연결시킨다
    1. new_node를 previous_node의 다음 노드로 지정한다
    2. new_node를 previous_node의 다음 노드의 전 노드로 지정한다
2. 이미 있던 노드들에 새롭게 만든 노드를 연결시킨다
    1. previous_node의 다음 노드의 전 노드를 new_node로 지정한다
    2. previous_node의 다음 노드를 new_node로 지정한다

이 네 가지를 해주면 되는 거죠.

### 모범 답안
위에서 작성한 코드들을 다 합쳐 볼게요.
```python
def insert_after(self, previous_node, data):
    """주어진 노드 다음에 데이터를 추가시켜주는 메소드"""
    new_node = Node(data)  # 새로운 노드 생성

    # tail 노드 다음에 노드를 삽입할 때
    if previous_node is self.tail:
        self.tail.next = new_node  # 새로운 노드를 tail 노드의 다음 노드로 지정한다
        new_node.prev = self.tail  # tail 노드를 새로운 노드의 전 노드로 지정한다
        self.tail = new_node  # 새로운 노드를 tail 노드로 지정한다

    else:
        # 새롭게 생성한 노드를 이미 있는 링크드 리스트에 연결시키고
        new_node.prev = previous_node 
        new_node.next = previous_node.next

        # 이미 있는 노드들의 앞과 다음 레퍼런스를 새롭게 생성한 노드로 지정한다
        previous_node.next.prev = new_node
        previous_node.next = new_node
```

### 테스트 코드
한 번 코드가 제대로 돌아가는지 확인해 봅시다.
```python
tail_node = my_list.tail  # tail 노드
my_list.insert_after(tail_node, 6)  # tail 노드 뒤에 노드 추가
print(my_list)
print(my_list.tail.data)  # 새로운 tail 노드 데이터 출력

# 링크드 리스트 중간에 데이터 삽입
node_at_index_3 = my_list.find_node_at(3)  # 노드 접근
my_list.insert_after(node_at_index_3, 3)
print(my_list)

# 링크드 리스트 중간에 데이터 삽입
node_at_index_2 = my_list.find_node_at(2)  # 노드 접근
my_list.insert_after(node_at_index_2, 2)
print(my_list)
```
```
| 2 | 3 | 5 | 7 | 11 |
| 2 | 3 | 5 | 7 | 11 | 5 |
5
| 2 | 3 | 5 | 7 | 3 | 11 | 5 |
| 2 | 3 | 5 | 2 | 7 | 3 | 11 | 5 |
```
원하는 위치에 원하는 데이터가 삽입된 것을 확인할 수 있습니다!

[main4_18.py](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/Data%20Structure/main4_18.py) 

<br/><br/>

23.01.06
## 19. 더블리 링크드 리스트 prepend 메소드

[main4_19.py](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/Data%20Structure/main4_19.py) 참고

<br/><br/>

## 20. 더블리 링크드 리스트 삭제 연산 개념

싱글리 링크드 리스트에서는 delete_after 이용해 삭제하려는 앞 노드를 parameter로 넘겨줬다  
하지만 더블리 링크드 리스트에서는 앞 뒤 노드 모두 연결되어 있기 때문에 삭제하려는 노드 자체를 parameter로 넘겨줘도 됨

1. 지우려는 노드가 링크드 리스트의 유일한 노드인 경우: head와 tail을 None으로 지정하면 됨
2. 지우려는 노드가 링크드 리스트의 head 노드인 경우(유일하지 않음): head의 next를 head로 지정하면 됨
3. 지우려는 노드가 링크드 리스트의 tail 노드인 경우(유일하지 않음): tail의 prev를 tail로 지정하면 됨
4. 지우려는 노드가 두 노드 사이에 있는 노드인 경우: 삭제하려는 노드의 전후 노드를 서로 연결하면 됨

시간복잡도: $O(1)$

<br/><br/>

## 21. 더블리 링크드 리스트 삭제 연산 구현

[main4_21.py](https://github.com/jaehyun-dev/Today-I-Learned/blob/main/Data%20Structure/main4_21.py) 

<br/><br/>

## 22. 더블리 링크드 리스트 시간 복잡도

### 더블리 링크드 리스트 연산 & 시간 복잡도
| 연산 | 링크드 리스트 |
|:----:|:-------------:|
| 접근 |    $O(n)$   |
| 탐색 |    $O(n)$   |
| 삽입 |    $O(1)$   |
| 삭제 |    $O(1)$   |

더블리 링크드 리스트에는 접근, 탐색, 삽입, 삭제 연산을 할 수 있습니다.

#### 접근 & 탐색 연산
접근과 탐색 연산은 싱글리 링크드 리스트 접근과 탐색이랑 똑같이 한다고 했는데요. 그러니까 head 노드부터 하나씩 다음 노드로 가면서 원하는 위치에 있거나 데이터를 갖는 노드를 찾았습니다. 링크드 리스트의 길이가 $n$이라고 할 때, 최악의 경우, 걸리는 시간은 이 $n$에 비례하니까 접근과 탐색은 $O(n)$이 걸립니다.

#### 삽입 & 삭제 연산
삽입과 삭제 연산은 얼마나 걸리는지 생각해볼까요?

삽입 연산은 특정 노드가 주어졌을 때 그다음 위치에 새로운 노드를 더해줬는데요. 그냥 앞과 뒤 노드의 레퍼런스 몇 개만 바꿔주면 됐었죠? 링크드 리스트의 길이와 상관없이 항상 일정하게 노드를 삽입할 수 있습니다. $O(1)$이죠.

삭제 연산은 파라미터로 지우려는 노드를 받아서 그 노드를 링크드 리스트에서 지웠습니다. 이때는 경우가 4 개로 좀 많긴 했는데요. 모든 경우 다 그냥 레퍼런스 두 개만 바꿔주면 노드를 지울 수 있었죠. 삽입과 마찬가지로 항상 일정한 시간, $O(1)$이 걸립니다.

#### 현실적인 시간 복잡도
싱글리 링크드 리스트와 마찬가지로 더블리 링크드 리스트의 삽입과 삭제 연산을 하기 위해서는 특정 노드가 필요합니다. 그 특정 노드를 접근 또는 탐색한 후에야 삽입과 삭제도 할 수 있다는 말인데요.

링크드 리스트 연산에 삽입과 삭제를 포함시키지 않는 건 좀 불공평한 분석입니다. 그래서 현실적으로 더블리 링크드 리스트 연산들은 아래 표만큼 걸립니다.

|                 연산                | 링크드 리스트 |
|:-----------------------------------:|:-------------:|
|                 접근                |      $O(n)$     |
|                 탐색                |      $O(n)$     |
| 원하는 노드에 접근 또는 탐색 + 삽입 |    $O(n + 1)$   |
| 원하는 노드에 접근 또는 탐색 + 삭제 |    $O(n + 1)$   |

#### 삽입 & 삭제 연산 특수 경우
링크드 리스트는 head와 tail 노드를 변수로 갖고 있어서 바로 접근할 수 있습니다. 이 특성을 이용하면 링크드 리스트의 가장 앞과 뒤에 삽입이나 삭제 연산을 할 때 좀 더 효율적으로 할 수 있습니다. append와 prepend 메소드를 떠올려 보세요. 파라미터를 안 받고 그냥 바로 head 노드에 접근해서 양 끝에 새로운 데이터를 삽입할 수 있었죠?

마찬가지로 더블리 링크드의 delete 메소드에 파라미터로 head나 tail 노드를 가지고와서 넘겨주면 양 끝 데이터를 한번에 $O(1)$으로 삭제할 수 있습니다.

|          연산         | 더블리 링크드 리스트 |
|:---------------------:|:--------------------:|
| 가장 앞에 접근 + 삽입 |    $O(1 + 1)$    |
| 가장 앞에 접근 + 삭제 |    $O(1 + 1)$    |
| 가장 뒤에 접근 + 삽입 |    $O(1 + 1)$    |
| 가장 뒤에 접근 + 삭제 |    $O(1 + 1)$    |

#### 싱글리 vs 더블리 링크드 리스트 tail 노드 삭제
|          연산         | 싱글리 링크드 리스트 | 더블리 링크드 리스트 |
|:---------------------:|:--------------------:|:--------------------:|
| 가장 앞에 접근 + 삽입 |    $O(1 + 1)$    |    $O(1 + 1)$    |
| 가장 앞에 접근 + 삭제 |    $O(1 + 1)$    |    $O(1 + 1)$    |
| 가장 뒤에 접근 + 삽입 |    $O(1 + 1)$    |    $O(1 + 1)$    |
| 가장 뒤에 접근 + 삭제 |    $O(n + 1)$    |    $O(1 + 1)$    |

싱글리 링크드 리스트의 삭제 연산은 지우려는 노드의 바로 전 위치의 노드를 파라미터로 받습니다. 그렇기 때문에 tail 노드를 지우기 위해서는 tail 노드 전 노드에 접근해서 이걸 파라미터로 넘겨줘야 됐는데요. 맨 뒤 노드 바로 이전 노드에 접근하는 데 $O(n)$이 걸렸기 때문에 효율적으로 할 수 없었습니다.

아까 말했듯이, 더블리 링크드 리스트는 삭제 연산을 할 때 지우려는 노드 자체를 파라미터로 받습니다. tail 노드는 링크드 리스트의 속성으로 저장하고 있기 때문에 바로 가지고 와서 삭제 연산의 파라미터로 넘겨주면 효율적으로 tail 노드를 삭제할 수 있습니다. head 노드도 마찬가지로 한 번에 삭제할 수 있죠.

링크드 리스트를 사용해야 되는 상황에서 tail 노드를 많이 삭제해야 된다면 싱글리 링크드 리스트보다 더블리 링크드 리스트를 사용하는 게 더 효율적인 거죠.

<br/><br/>

## 23. 싱글리 vs 더블리 링크드 리스트

레퍼런스를 저장하기 때문에 추가적 공간이 필요함  
노드가 n개 있을 때 싱글리 링크드 리스트는 n - 1개, 더블리 링크드 리스트는 2n - 2개의 레퍼런스가 필요함  
둘 모두 공간 복잡도는 $O(n)$이나, 실제로는 더블리 링크드 리스트가 싱글리 링크드 리스트의 2배 필요하므로, 만약 공간 효율성이 반드시 필요한 상황이라면 싱글리 링크드 리스트를 쓰는 게 좋음  

<br/><br/>

## 24. 링크드 리스트 퀴즈  

질문 1  
다음 중 링크드 리스트에 관한 내용으로 옳지 않은 내용을 고르시오.  

1 링크드 리스트는 배열과 같이 데이터를 순서대로 저장해주는 자료 구조다.  
2 링크드 리스트는 각 노드가 다음 노드에 대한 레퍼런스만 저장하는지, 아니면 다음과 전 노드에 대한 레퍼런스를 모두 저장하는지에 따라 싱글리 링크드 리스트와 더블리 링크드 리스트로 구별할 수 있다.  
3 링크드 리스트 노드들은 메모리에 연속적이거나 순서대로 저장되지는 않는다. 메모리 이곳저곳 아무 데나 저장돼 있을 수 있다.  
4 싱글리 링크드 리스트는 배열과 같이 처음부터 크기를 정해야 되고, 이보다 더 많은 데이터를 저장할 수 없다.  
5 파이썬에서는 노드 클래스를 정의하고, 인스턴스들을 만들어서 연결하면 링크드 리스트를 구현할 수 있다.  


질문 2  
다음 중 싱글리 링크드 리스트와 더블리 링크드 리스트 연산들에 대한 내용 중 틀린 것을 고르시오.  

1 싱글리 링크드 리스트의 tail 노드를 삭제하려면 tail 노드 전 노드에 접근해서 tail 노드를 삭제하는 데 총  O(n)O(n)의 시간이 걸린다.  
2 더블리 링크드 리스트는 맨 앞과 맨 뒤에 삽입이나 삭제하는 4 개의 연산들을 모두 O(1)O(1)으로 할 수 있다.  
3 싱글리와 더블리 링크드 리스트의 삽입과 삭제 연산은 O(1)O(1)이 걸리기 때문에 새로운 데이터를 계속 저장해주는 연산은 무조건적으로 동적 배열보다 효율적이라고 할 수 있다.  
4 링크드 리스트의 탐색 연산은 동적 배열과 같이 처음부터 끝까지 모든 데이터를 하나씩 보는 선형 탐색 방법을 쓴다.  
5 가장 앞 순서에 데이터를 많이 삽입해야 되는 경우에는 싱글리 링크드 리스트가 동적 배열보다 더 효율적이다.  


질문 3  
다음 중 더블리 링크드 리스트 대신 싱글리 링크드 리스트를 사용하는 것이 좋은 경우를 고르시오.  

1 프로그램이 너무나도 많은 메모리 공간을 사용할 것 같기 때문에 공간을 좀 더 효율적으로 사용하고 싶은 경우.  
2 순서 데이터를 사용하는데 맨 앞 순서에 계속해서 새로운 데이터를 삽입해야 되는 경우.  
3 한 노드에서 앞에 있는 노드들에 꼭 접근을 해야만 하는 경우.  
4 순서 데이터를 사용하는데 맨 뒤 순서에 계속해서 새로운 데이터를 삽입해야 되는 경우.  


질문 4  
다음 중 더블리 링크드 리스트를 사용하는 게 다른 경우들보다 비효율적인 경우를 고르시오.  

1 게임 캐릭터들의 순위 정보를 더블리 링크드 리스트에 저장해 놓고 이 순서를 이용해서 데이터에 접근해야될 때.  
2 게임 프로그램에서 캐릭터가 죽는 순서대로 저장을 해야되서 캐릭터가 죽을 때마다 더블리 링크드 리스트 맨 뒤에 추가해야될 때.  
3 온라인 상담소에서 더블리 링크드 리스트에 접수가 들어오는 순서대로 저장하고 가장 앞에 있는 문의부터 처리하고 지워야될 때.  

<br/><br/>

### 해설  
질문 1  
정답:  4  
퀴즈 해설  
싱글리 링크드 리스트는 처음에 크기를 정하지 않아도 그냥 새로운 노드를 만들어서 기존 노드들에 연결만 시켜주면 계속해서 새로운 데이터를 더해줄 수 있습니다.  

질문 2  
정답: 3  
퀴즈 해설  
싱글리와 더블리 링크드 리스트 일반적인 경우의 삽입 삭제 연산들은 파라미터로 노드를 받습니다. 이 노드를 가지고 있으면 삽입과 삭제 연산을 $O(1)$으로 할 수 있는 거죠. 하지만 실질적으로는 이 노드를 가지고 오는데 최악의 경우 $O(n)$이 걸립니다. 그러니까 필요한 노드를 가지고 온 후, 삽입 삭제 연산들을 하는 총 시간을 따지고 보면 $O(n)$이 걸리는 거죠.  
필요한 노드를 한 번에 바로 가지고 올 수 있는 경우나, 이미 필요한 노드를 가지고 있는 경우를 제외하고는 동적 배열보다 항상 효율적이라고 할 1수는 없습니다.  

질문 3  
정답: 1  
퀴즈 해설  
싱글리 링크드 리스트 노드는 저장하려는 데이터와 다음 노드에 대한 레퍼런스를 저장합니다. 반면 더블리 링크드 리스트 노드는 저장하려는 데이터, 다음 노드에 대한 레퍼런스, 앞 노드에 대한 레퍼런스를 저장하죠. 그렇기 때문에 더블리 링크드 리스트가 싱글리 링크드 리스트보다 약 두 배 정도 많은 추가적인 저장 공간이 필요한데요. 혹시나도 공간이 부족해질 수도 있는 상황에서는 더블리 링크드 리스트보다 싱글리 링크드 리스트를 사용하는 게 더 낫겠죠?  

질문 4  
정답: 1  
퀴즈 해설  
보기 1: 더블리 링크드 리스트에서 순서를 이용해서 저장한 데이터에 접근하는 건 $O(n)$이 걸립니다.  
보기 2, 3: 반면 더블리 링크드 리스트는 head와 tail 노드를 변수로 저장하고 있기 때문에 양 끝에 데이터를 삽입하거나 삭제하는 연산을 굉장히 효율적으로 할 수 있죠. 정확히는 $O(1)$으로 할 수 있습니다.
